{"version":3,"sources":["turbopack:///[project]/node_modules/@polkadot/util/is/promise.js","turbopack:///[project]/node_modules/@polkadot/extension-dapp/bundle.js","turbopack:///[project]/node_modules/@polkadot/extension-dapp/util.js","turbopack:///[project]/node_modules/@polkadot/extension-dapp/packageInfo.js","turbopack:///[project]/node_modules/@polkadot/extension-dapp/wrapBytes.js"],"sourcesContent":["import { isOnObject } from './helpers.js';\nexport const isPromise = /*#__PURE__*/ isOnObject('catch', 'then');\n","import { isPromise, objectSpread, u8aEq } from '@polkadot/util';\nimport { decodeAddress, encodeAddress } from '@polkadot/util-crypto';\nimport { documentReadyPromise } from './util.js';\nexport { packageInfo } from './packageInfo.js';\nexport { unwrapBytes, wrapBytes } from './wrapBytes.js';\nconst win = window;\nwin.injectedWeb3 = win.injectedWeb3 || {};\nlet isWeb3Injected = web3IsInjected();\nlet web3EnablePromise = null;\nexport { isWeb3Injected, web3EnablePromise };\n/** @internal true when anything has been injected and is available */\nfunction web3IsInjected() {\n    return Object\n        .values(win.injectedWeb3)\n        .filter(({ connect, enable }) => !!(connect || enable))\n        .length !== 0;\n}\n/** @internal throw a consistent error when not extensions have not been enabled */\nfunction throwError(method) {\n    throw new Error(`${method}: web3Enable(originName) needs to be called before ${method}`);\n}\n/** @internal map from Array<InjectedAccount> to Array<InjectedAccountWithMeta> */\nfunction mapAccounts(source, list, ss58Format) {\n    return list.map(({ address, genesisHash, name, type }) => ({\n        address: address.length === 42\n            ? address\n            : encodeAddress(decodeAddress(address), ss58Format),\n        meta: { genesisHash, name, source },\n        type\n    }));\n}\n/** @internal filter accounts based on genesisHash and type of account */\nfunction filterAccounts(list, genesisHash, type) {\n    return list.filter((a) => (!a.type || !type || type.includes(a.type)) &&\n        (!a.genesisHash || !genesisHash || a.genesisHash === genesisHash));\n}\n/** @internal retrieves all the extensions available on the window */\nfunction getWindowExtensions(originName) {\n    return Promise\n        .all(Object\n        .entries(win.injectedWeb3)\n        .map(([nameOrHash, { connect, enable, version }]) => Promise\n        .resolve()\n        .then(() => connect\n        // new style, returning all info\n        ? connect(originName)\n        : enable\n            // previous interface, leakages on name/version\n            ? enable(originName).then((e) => objectSpread({ name: nameOrHash, version: version || 'unknown' }, e))\n            : Promise.reject(new Error('No connect(..) or enable(...) hook found')))\n        .catch(({ message }) => {\n        console.error(`Error initializing ${nameOrHash}: ${message}`);\n    })))\n        .then((exts) => exts.filter((e) => !!e));\n}\n/** @internal Ensure the enable promise is resolved and filter by extensions */\nasync function filterEnable(caller, extensions) {\n    if (!web3EnablePromise) {\n        return throwError(caller);\n    }\n    const sources = await web3EnablePromise;\n    return sources.filter(({ name }) => !extensions ||\n        extensions.includes(name));\n}\n/**\n * @summary Enables all the providers found on the injected window interface\n * @description\n * Enables all injected extensions that has been found on the page. This\n * should be called before making use of any other web3* functions.\n */\nexport function web3Enable(originName, compatInits = []) {\n    if (!originName) {\n        throw new Error('You must pass a name for your app to the web3Enable function');\n    }\n    const initCompat = compatInits.length\n        ? Promise.all(compatInits.map((c) => c().catch(() => false)))\n        : Promise.resolve([true]);\n    web3EnablePromise = documentReadyPromise(() => initCompat.then(() => getWindowExtensions(originName)\n        .then((values) => values.map((e) => {\n        // if we don't have an accounts subscriber, add a single-shot version\n        if (!e.accounts.subscribe) {\n            e.accounts.subscribe = (cb) => {\n                e.accounts\n                    .get()\n                    .then(cb)\n                    .catch(console.error);\n                return () => {\n                    // no ubsubscribe needed, this is a single-shot\n                };\n            };\n        }\n        return e;\n    }))\n        .catch(() => [])\n        .then((values) => {\n        const names = values.map(({ name, version }) => `${name}/${version}`);\n        isWeb3Injected = web3IsInjected();\n        console.info(`web3Enable: Enabled ${values.length} extension${values.length !== 1 ? 's' : ''}: ${names.join(', ')}`);\n        return values;\n    })));\n    return web3EnablePromise;\n}\n/**\n * @summary Retrieves all the accounts across all providers\n * @description\n * This returns the full list of account available (across all extensions) to\n * the page. Filtering options are available of a per-extension, per type and\n * per-genesisHash basis. Optionally the accounts can be encoded with the provided\n * ss58Format\n */\nexport async function web3Accounts({ accountType, extensions, genesisHash, ss58Format } = {}) {\n    const accounts = [];\n    const sources = await filterEnable('web3Accounts', extensions);\n    const retrieved = await Promise.all(sources.map(async ({ accounts, name: source }) => {\n        try {\n            const list = await accounts.get();\n            return mapAccounts(source, filterAccounts(list, genesisHash, accountType), ss58Format);\n        }\n        catch {\n            // cannot handle this one\n            return [];\n        }\n    }));\n    retrieved.forEach((result) => {\n        accounts.push(...result);\n    });\n    console.info(`web3Accounts: Found ${accounts.length} address${accounts.length !== 1 ? 'es' : ''}`);\n    return accounts;\n}\n/**\n * @summary Subscribes to all the accounts across all providers\n * @description\n * This is the subscription version of the web3Accounts interface with\n * updates as to when new accounts do become available. The list of filtering\n * options are the same as for the web3Accounts interface.\n */\nexport async function web3AccountsSubscribe(cb, { accountType, extensions, genesisHash, ss58Format } = {}) {\n    const sources = await filterEnable('web3AccountsSubscribe', extensions);\n    const accounts = {};\n    const triggerUpdate = () => cb(Object\n        .entries(accounts)\n        .reduce((result, [source, list]) => {\n        result.push(...mapAccounts(source, filterAccounts(list, genesisHash, accountType), ss58Format));\n        return result;\n    }, []));\n    const unsubs = sources.map(({ accounts: { subscribe }, name: source }) => subscribe((result) => {\n        accounts[source] = result;\n        try {\n            const result = triggerUpdate();\n            if (result && isPromise(result)) {\n                result.catch(console.error);\n            }\n        }\n        catch (error) {\n            console.error(error);\n        }\n    }));\n    return () => {\n        unsubs.forEach((unsub) => {\n            unsub();\n        });\n    };\n}\n/**\n * @summary Finds a specific provider based on the name\n * @description\n * This retrieves a specific source (extension) based on the name. In most\n * cases it should not be needed to call it directly (e.g. it is used internally\n * by calls such as web3FromAddress) but would allow operation on a specific\n * known extension.\n */\nexport async function web3FromSource(source) {\n    if (!web3EnablePromise) {\n        return throwError('web3FromSource');\n    }\n    const sources = await web3EnablePromise;\n    const found = source && sources.find(({ name }) => name === source);\n    if (!found) {\n        throw new Error(`web3FromSource: Unable to find an injected ${source}`);\n    }\n    return found;\n}\n/**\n * @summary Find a specific provider that provides a specific address\n * @description\n * Based on an address, return the provider that has makes this address\n * available to the page.\n */\nexport async function web3FromAddress(address) {\n    if (!web3EnablePromise) {\n        return throwError('web3FromAddress');\n    }\n    const accounts = await web3Accounts();\n    let found;\n    if (address) {\n        const accountU8a = decodeAddress(address);\n        found = accounts.find((account) => u8aEq(decodeAddress(account.address), accountU8a));\n    }\n    if (!found) {\n        throw new Error(`web3FromAddress: Unable to find injected ${address}`);\n    }\n    return web3FromSource(found.meta.source);\n}\n/**\n * @summary List all providers exposed by one source\n * @description\n * For extensions that supply RPC providers, this call would return the list\n * of RPC providers that any extension may supply.\n */\nexport async function web3ListRpcProviders(source) {\n    const { provider } = await web3FromSource(source);\n    if (!provider) {\n        console.warn(`Extension ${source} does not expose any provider`);\n        return null;\n    }\n    return provider.listProviders();\n}\n/**\n * @summary Start an RPC provider provider by a specific source\n * @description\n * For extensions that supply RPC providers, this call would return an\n * enabled provider (initialized with the specific key) from the\n * specified extension source.\n */\nexport async function web3UseRpcProvider(source, key) {\n    const { provider } = await web3FromSource(source);\n    if (!provider) {\n        throw new Error(`Extension ${source} does not expose any provider`);\n    }\n    const meta = await provider.startProvider(key);\n    return { meta, provider };\n}\n","export function documentReadyPromise(creator) {\n    return new Promise((resolve) => {\n        if (document.readyState === 'complete') {\n            resolve(creator());\n        }\n        else {\n            window.addEventListener('load', () => resolve(creator()));\n        }\n    });\n}\n","export const packageInfo = { name: '@polkadot/extension-dapp', path: (import.meta && import.meta.url) ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf('/') + 1) : 'auto', type: 'esm', version: '0.62.1' };\n","import { U8A_WRAP_ETHEREUM, U8A_WRAP_POSTFIX, U8A_WRAP_PREFIX, u8aIsWrapped, u8aUnwrapBytes, u8aWrapBytes } from '@polkadot/util';\nexport const ETHEREUM = U8A_WRAP_ETHEREUM;\nexport const POSTFIX = U8A_WRAP_POSTFIX;\nexport const PREFIX = U8A_WRAP_PREFIX;\nexport const isWrapped = u8aIsWrapped;\nexport const unwrapBytes = u8aUnwrapBytes;\nexport const wrapBytes = u8aWrapBytes;\n"],"names":[],"mappings":"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","ignoreList":[0,1,2,3,4]}