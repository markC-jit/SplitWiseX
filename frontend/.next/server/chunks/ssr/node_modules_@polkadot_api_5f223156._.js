module.exports = [
"[project]/node_modules/@polkadot/api/packageInfo.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "packageInfo",
    ()=>packageInfo
]);
const __TURBOPACK__import$2e$meta__ = {
    get url () {
        return `file://${__turbopack_context__.P("node_modules/@polkadot/api/packageInfo.js")}`;
    }
};
const packageInfo = {
    name: '@polkadot/api',
    path: __TURBOPACK__import$2e$meta__ && __TURBOPACK__import$2e$meta__.url ? new URL(__TURBOPACK__import$2e$meta__.url).pathname.substring(0, new URL(__TURBOPACK__import$2e$meta__.url).pathname.lastIndexOf('/') + 1) : 'auto',
    type: 'esm',
    version: '16.4.8'
};
}),
"[project]/node_modules/@polkadot/api/packageDetect.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2d$derive$2f$packageInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api-derive/packageInfo.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$rpc$2d$core$2f$packageInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/rpc-core/packageInfo.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$rpc$2d$provider$2f$packageInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/rpc-provider/packageInfo.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2f$packageInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/types/packageInfo.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2d$known$2f$packageInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/types-known/packageInfo.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$detectPackage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/detectPackage.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$packageInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/packageInfo.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$detectPackage$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["detectPackage"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$packageInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["packageInfo"], null, [
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$rpc$2d$core$2f$packageInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["packageInfo"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2d$derive$2f$packageInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["packageInfo"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2d$known$2f$packageInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["packageInfo"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$rpc$2d$provider$2f$packageInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["packageInfo"],
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2f$packageInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["packageInfo"]
]);
}),
"[project]/node_modules/@polkadot/api/index.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$packageDetect$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/packageDetect.js [app-ssr] (ecmascript)");
;
;
}),
"[project]/node_modules/@polkadot/api/bundle.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
;
;
;
;
;
;
}),
"[project]/node_modules/@polkadot/api/submittable/Result.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SubmittableResult",
    ()=>SubmittableResult
]);
const recordIdentity = (record)=>record;
function filterAndApply(events, section, methods, onFound) {
    return events.filter(({ event })=>section === event.section && methods.includes(event.method)).map((record)=>onFound(record));
}
function getDispatchError({ event: { data: [dispatchError] } }) {
    return dispatchError;
}
function getDispatchInfo({ event: { data, method } }) {
    return method === 'ExtrinsicSuccess' ? data[0] : data[1];
}
function extractError(events = []) {
    return filterAndApply(events, 'system', [
        'ExtrinsicFailed'
    ], getDispatchError)[0];
}
function extractInfo(events = []) {
    return filterAndApply(events, 'system', [
        'ExtrinsicFailed',
        'ExtrinsicSuccess'
    ], getDispatchInfo)[0];
}
class SubmittableResult {
    dispatchError;
    dispatchInfo;
    internalError;
    events;
    status;
    txHash;
    txIndex;
    blockNumber;
    constructor({ blockNumber, dispatchError, dispatchInfo, events, internalError, status, txHash, txIndex }){
        this.dispatchError = dispatchError || extractError(events);
        this.dispatchInfo = dispatchInfo || extractInfo(events);
        this.events = events || [];
        this.internalError = internalError;
        this.status = status;
        this.txHash = txHash;
        this.txIndex = txIndex;
        this.blockNumber = blockNumber;
    }
    get isCompleted() {
        return this.isError || this.status.isInBlock || this.status.isFinalized;
    }
    get isError() {
        return this.status.isDropped || this.status.isFinalityTimeout || this.status.isInvalid || this.status.isUsurped;
    }
    get isFinalized() {
        return this.status.isFinalized;
    }
    get isInBlock() {
        return this.status.isInBlock;
    }
    get isWarning() {
        return this.status.isRetracted;
    }
    /**
     * @description Filters EventRecords for the specified method & section (there could be multiple)
     */ filterRecords(section, method) {
        return filterAndApply(this.events, section, Array.isArray(method) ? method : [
            method
        ], recordIdentity);
    }
    /**
     * @description Finds an EventRecord for the specified method & section
     */ findRecord(section, method) {
        return this.filterRecords(section, method)[0];
    }
    /**
     * @description Creates a human representation of the output
     */ toHuman(isExtended) {
        return {
            dispatchError: this.dispatchError?.toHuman(),
            dispatchInfo: this.dispatchInfo?.toHuman(),
            events: this.events.map((e)=>e.toHuman(isExtended)),
            internalError: this.internalError?.message.toString(),
            status: this.status.toHuman(isExtended)
        };
    }
}
}),
"[project]/node_modules/@polkadot/api/promise/index.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
;
}),
"[project]/node_modules/@polkadot/api/base/find.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "findCall",
    ()=>findCall,
    "findError",
    ()=>findError
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$u8a$2f$toU8a$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/u8a/toU8a.js [app-ssr] (ecmascript)");
;
function findCall(registry, callIndex) {
    return registry.findMetaCall((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$u8a$2f$toU8a$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u8aToU8a"])(callIndex));
}
function findError(registry, errorIndex) {
    return registry.findMetaError((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$u8a$2f$toU8a$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u8aToU8a"])(errorIndex));
}
}),
"[project]/node_modules/@polkadot/api/util/logging.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "l",
    ()=>l
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/logger.js [app-ssr] (ecmascript)");
;
const l = /*#__PURE__*/ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["logger"])('api/util');
}),
"[project]/node_modules/@polkadot/api/util/filterEvents.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "filterEvents",
    ()=>filterEvents
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$compact$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/is/compact.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$logging$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/util/logging.js [app-ssr] (ecmascript)");
;
;
function filterEvents(txHash, { block: { extrinsics, header } }, allEvents, status) {
    // extrinsics to hashes
    for (const [txIndex, x] of extrinsics.entries()){
        if (x.hash.eq(txHash)) {
            return {
                blockNumber: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$compact$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isCompact"])(header.number) ? header.number.unwrap() : header.number,
                events: allEvents.filter(({ phase })=>phase.isApplyExtrinsic && phase.asApplyExtrinsic.eqn(txIndex)),
                txIndex
            };
        }
    }
    // if we do get the block after finalized, it _should_ be there
    // only warn on filtering with isInBlock (finalization finalizes after)
    if (status.isInBlock) {
        const allHashes = extrinsics.map((x)=>x.hash.toHex());
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$logging$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["l"].warn(`block ${header.hash.toHex()}: Unable to find extrinsic ${txHash.toHex()} inside ${allHashes.join(', ')}`);
    }
    return {};
}
}),
"[project]/node_modules/@polkadot/api/util/isKeyringPair.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "isKeyringPair",
    ()=>isKeyringPair
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$function$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/is/function.js [app-ssr] (ecmascript)");
;
function isKeyringPair(account) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$function$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isFunction"])(account.sign);
}
}),
"[project]/node_modules/@polkadot/api/submittable/createClass.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createClass",
    ()=>createClass
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/cjs/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$noop$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/noop.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$bn$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/is/bn.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$function$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/is/function.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/is/number.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/is/string.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$u8a$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/is/u8a.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$object$2f$spread$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/object/spread.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$filterEvents$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/util/filterEvents.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$isKeyringPair$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/util/isKeyringPair.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$submittable$2f$Result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/submittable/Result.js [app-ssr] (ecmascript)");
;
;
;
;
function makeEraOptions(api, registry, partialOptions, { header, mortalLength, nonce }) {
    if (!header) {
        if (partialOptions.era && !partialOptions.blockHash) {
            throw new Error('Expected blockHash to be passed alongside non-immortal era options');
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(partialOptions.era)) {
            // since we have no header, it is immortal, remove any option overrides
            // so we only supply the genesisHash and no era to the construction
            delete partialOptions.era;
            delete partialOptions.blockHash;
        }
        return makeSignOptions(api, partialOptions, {
            nonce
        });
    }
    return makeSignOptions(api, partialOptions, {
        blockHash: header.hash,
        era: registry.createTypeUnsafe('ExtrinsicEra', [
            {
                current: header.number,
                period: partialOptions.era || mortalLength
            }
        ]),
        nonce
    });
}
function makeSignAndSendOptions(partialOptions, statusCb) {
    let options = {};
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$function$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isFunction"])(partialOptions)) {
        statusCb = partialOptions;
    } else {
        options = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$object$2f$spread$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectSpread"])({}, partialOptions);
    }
    return [
        options,
        statusCb
    ];
}
function makeSignOptions(api, partialOptions, extras) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$object$2f$spread$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectSpread"])({
        blockHash: api.genesisHash,
        genesisHash: api.genesisHash
    }, partialOptions, extras, {
        runtimeVersion: api.runtimeVersion,
        signedExtensions: api.registry.signedExtensions,
        version: api.extrinsicType
    });
}
function optionsOrNonce(partialOptions = {}) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$bn$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isBn"])(partialOptions) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$number$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isNumber"])(partialOptions) ? {
        nonce: partialOptions
    } : partialOptions;
}
function createClass({ api, apiType, blockHash, decorateMethod }) {
    // an instance of the base extrinsic for us to extend
    const ExtrinsicBase = api.registry.createClass('Extrinsic');
    const extrinsicInfoMap = new WeakMap();
    class Submittable extends ExtrinsicBase {
        #ignoreStatusCb;
        #transformResult = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$noop$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["identity"];
        constructor(registry, extrinsic){
            super(registry, extrinsic, {
                version: api.extrinsicType
            });
            this.#ignoreStatusCb = apiType === 'rxjs';
        }
        get hasDryRun() {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$function$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isFunction"])(api.rpc.system?.dryRun);
        }
        get hasPaymentInfo() {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$function$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isFunction"])(api.call.transactionPaymentApi?.queryInfo);
        }
        // dry run an extrinsic
        dryRun(account, optionsOrHash) {
            if (!this.hasDryRun) {
                throw new Error('The system.dryRun RPC call is not available in your environment');
            }
            if (blockHash || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isString"])(optionsOrHash) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$u8a$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isU8a"])(optionsOrHash)) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                return decorateMethod(()=>api.rpc.system.dryRun(this.toHex(), blockHash || optionsOrHash));
            }
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call
            return decorateMethod(()=>this.#observeSign(account, optionsOrHash).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["switchMap"])(()=>api.rpc.system.dryRun(this.toHex()))))();
        }
        // calculate the payment info for this transaction (if signed and submitted)
        paymentInfo(account, optionsOrHash) {
            if (!this.hasPaymentInfo) {
                throw new Error('The transactionPaymentApi.queryInfo runtime call is not available in your environment');
            }
            if (blockHash || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isString"])(optionsOrHash) || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$u8a$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isU8a"])(optionsOrHash)) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                return decorateMethod(()=>api.callAt(blockHash || optionsOrHash).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["switchMap"])((callAt)=>{
                        const u8a = this.toU8a();
                        return callAt.transactionPaymentApi.queryInfo(u8a, u8a.length);
                    })));
            }
            const [allOptions] = makeSignAndSendOptions(optionsOrHash);
            const address = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$isKeyringPair$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isKeyringPair"])(account) ? account.address : account.toString();
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call
            return decorateMethod(()=>api.derive.tx.signingInfo(address, allOptions.nonce, allOptions.era).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["first"])(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["switchMap"])((signingInfo)=>{
                    // setup our options (same way as in signAndSend)
                    const eraOptions = makeEraOptions(api, this.registry, allOptions, signingInfo);
                    const signOptions = makeSignOptions(api, eraOptions, {});
                    // 1. Don't use the internal objects inside the new tx (hence toU8a)
                    // 2. Don't override the data from existing signed extrinsics
                    // 3. Ensure that this object stays intact, with no new sign after operation
                    const u8a = api.tx(this.toU8a()).signFake(address, signOptions).toU8a();
                    return api.call.transactionPaymentApi.queryInfo(u8a, u8a.length);
                })))();
        }
        // send implementation for both immediate Hash and statusCb variants
        send(statusCb) {
            const isSubscription = api.hasSubscriptions && (this.#ignoreStatusCb || !!statusCb);
            const updatedInfo = extrinsicInfoMap.get(this);
            extrinsicInfoMap.delete(this);
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call
            return decorateMethod(isSubscription ? ()=>this.#observeSubscribe(updatedInfo) : ()=>this.#observeSend(updatedInfo))(statusCb);
        }
        /**
         * @description Signs a transaction, returning `this` to allow chaining. E.g.: `signAsync(...).send()`. Like `.signAndSend` this will retrieve the nonce and blockHash to send the tx with.
        */ signAsync(account, partialOptions) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call
            return decorateMethod(()=>this.#observeSign(account, partialOptions).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["map"])((info)=>{
                    // If we got a full signed transaction from the signer, attach it
                    if (info.signedTransaction) {
                        const extrinsic = new Submittable(api.registry, info.signedTransaction);
                        extrinsicInfoMap.set(this, info);
                        return extrinsic;
                    }
                    // Fallback if signer didnâ€™t return signedTransaction
                    return this;
                })))();
        }
        // signAndSend implementation for all 3 cases above
        signAndSend(account, partialOptions, optionalStatusCb) {
            const [options, statusCb] = makeSignAndSendOptions(partialOptions, optionalStatusCb);
            const isSubscription = api.hasSubscriptions && (this.#ignoreStatusCb || !!statusCb);
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call
            return decorateMethod(()=>this.#observeSign(account, options).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["switchMap"])((info)=>isSubscription ? this.#observeSubscribe(info) : this.#observeSend(info))) // FIXME This is wrong, SubmittableResult is _not_ a codec
            )(statusCb);
        }
        // adds a transform to the result, applied before result is returned
        withResultTransform(transform) {
            this.#transformResult = transform;
            return this;
        }
        #observeSign = (account, partialOptions)=>{
            const address = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$isKeyringPair$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isKeyringPair"])(account) ? account.address : account.toString();
            const options = optionsOrNonce(partialOptions);
            return api.derive.tx.signingInfo(address, options.nonce, options.era).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["first"])(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["mergeMap"])(async (signingInfo)=>{
                const eraOptions = makeEraOptions(api, this.registry, options, signingInfo);
                let updateId = -1;
                let signedTx = null;
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$isKeyringPair$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isKeyringPair"])(account)) {
                    this.sign(account, eraOptions);
                } else {
                    const result = await this.#signViaSigner(address, eraOptions, signingInfo.header);
                    updateId = result.id;
                    if (result.signedTransaction) {
                        signedTx = result.signedTransaction;
                    }
                }
                return {
                    options: eraOptions,
                    signedTransaction: signedTx,
                    updateId
                };
            }));
        };
        #observeStatus = (txHash, status)=>{
            if (!status.isFinalized && !status.isInBlock) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["of"])(this.#transformResult(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$submittable$2f$Result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SubmittableResult"]({
                    status,
                    txHash
                })));
            }
            const blockHash = status.isInBlock ? status.asInBlock : status.asFinalized;
            return api.derive.tx.events(blockHash).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["map"])(({ block, events })=>this.#transformResult(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$submittable$2f$Result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SubmittableResult"]({
                    ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$filterEvents$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["filterEvents"])(txHash, block, events, status),
                    status,
                    txHash
                }))), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["catchError"])((internalError)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["of"])(this.#transformResult(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$submittable$2f$Result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SubmittableResult"]({
                    internalError,
                    status,
                    txHash
                })))));
        };
        #observeSend = (info)=>{
            return api.rpc.author.submitExtrinsic(info?.signedTransaction || this).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tap"])((hash)=>{
                this.#updateSigner(hash, info);
            }));
        };
        #observeSubscribe = (info)=>{
            const txHash = this.hash;
            return api.rpc.author.submitAndWatchExtrinsic(info?.signedTransaction || this).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["switchMap"])((status)=>this.#observeStatus(txHash, status)), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tap"])((status)=>{
                this.#updateSigner(status, info);
            }));
        };
        #signViaSigner = async (address, options, header)=>{
            const signer = options.signer || api.signer;
            const allowCallDataAlteration = options.allowCallDataAlteration ?? true;
            if (!signer) {
                throw new Error('No signer specified, either via api.setSigner or via sign options. You possibly need to pass through an explicit keypair for the origin so it can be used for signing.');
            }
            const payload = this.registry.createTypeUnsafe('SignerPayload', [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$object$2f$spread$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectSpread"])({}, options, {
                    address,
                    blockNumber: header ? header.number : 0,
                    method: this.method
                })
            ]);
            let result;
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$function$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isFunction"])(signer.signPayload)) {
                result = await signer.signPayload(payload.toPayload());
                if (result.signedTransaction && !options.withSignedTransaction) {
                    throw new Error('The `signedTransaction` field may not be submitted when `withSignedTransaction` is disabled');
                }
                if (result.signedTransaction && options.withSignedTransaction) {
                    const ext = this.registry.createTypeUnsafe('Extrinsic', [
                        result.signedTransaction
                    ]);
                    const newSignerPayload = this.registry.createTypeUnsafe('SignerPayload', [
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$object$2f$spread$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectSpread"])({}, {
                            address,
                            assetId: ext.assetId && ext.assetId.isSome ? ext.assetId.toHex() : null,
                            blockHash: payload.blockHash,
                            blockNumber: header ? header.number : 0,
                            era: ext.era.toHex(),
                            genesisHash: payload.genesisHash,
                            metadataHash: ext.metadataHash ? ext.metadataHash.toHex() : null,
                            method: ext.method.toHex(),
                            mode: ext.mode ? ext.mode.toHex() : null,
                            nonce: ext.nonce.toHex(),
                            runtimeVersion: payload.runtimeVersion,
                            signedExtensions: payload.signedExtensions,
                            tip: ext.tip ? ext.tip.toHex() : null,
                            version: payload.version
                        })
                    ]);
                    if (!ext.isSigned) {
                        throw new Error(`When using the signedTransaction field, the transaction must be signed. Recieved isSigned: ${ext.isSigned}`);
                    }
                    if (!allowCallDataAlteration) {
                        this.#validateSignedTransaction(payload, ext);
                    }
                    // This is only used for signAsync - signAndSend does not need to adjust the super payload or
                    // add the signature.
                    super.addSignature(address, result.signature, newSignerPayload.toPayload());
                    return {
                        id: result.id,
                        signedTransaction: result.signedTransaction
                    };
                }
            } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$function$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isFunction"])(signer.signRaw)) {
                result = await signer.signRaw(payload.toRaw());
            } else {
                throw new Error('Invalid signer interface, it should implement either signPayload or signRaw (or both)');
            }
            // Here we explicitly call `toPayload()` again instead of working with an object
            // (reference) as passed to the signer. This means that we are sure that the
            // payload data is not modified from our inputs, but the signer
            super.addSignature(address, result.signature, payload.toPayload());
            return {
                id: result.id
            };
        };
        #updateSigner = (status, info)=>{
            if (info && info.updateId !== -1) {
                const { options, updateId } = info;
                const signer = options.signer || api.signer;
                if (signer && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$function$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isFunction"])(signer.update)) {
                    signer.update(updateId, status);
                }
            }
        };
        /**
         * When a signer includes `signedTransaction` within the SignerResult this will validate
         * specific fields within the signed extrinsic against the original payload that was passed
         * to the signer.
         */ #validateSignedTransaction = (signerPayload, signedExt)=>{
            const payload = signerPayload.toPayload();
            const errMsg = (field)=>`signAndSend: ${field} does not match the original payload`;
            if (payload.method !== signedExt.method.toHex()) {
                throw new Error(errMsg('call data'));
            }
        };
    }
    return Submittable;
}
}),
"[project]/node_modules/@polkadot/api/submittable/createSubmittable.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createSubmittable",
    ()=>createSubmittable
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$submittable$2f$createClass$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/submittable/createClass.js [app-ssr] (ecmascript)");
;
function createSubmittable(apiType, api, decorateMethod, registry, blockHash) {
    const Submittable = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$submittable$2f$createClass$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createClass"])({
        api,
        apiType,
        blockHash,
        decorateMethod
    });
    return (extrinsic)=>new Submittable(registry || api.registry, extrinsic);
}
}),
"[project]/node_modules/@polkadot/api/util/augmentObject.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "augmentObject",
    ()=>augmentObject
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$lazy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/lazy.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/logger.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$object$2f$clear$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/object/clear.js [app-ssr] (ecmascript)");
;
const l = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["logger"])('api/augment');
function logLength(type, values, and = []) {
    return values.length ? ` ${values.length} ${type}${and.length ? ' and' : ''}` : '';
}
function logValues(type, values) {
    return values.length ? `\n\t${type.padStart(7)}: ${values.sort().join(', ')}` : '';
}
function warn(prefix, type, [added, removed]) {
    if (added.length || removed.length) {
        l.warn(`api.${prefix}: Found${logLength('added', added, removed)}${logLength('removed', removed)} ${type}:${logValues('added', added)}${logValues('removed', removed)}`);
    }
}
function findSectionExcludes(a, b) {
    return a.filter((s)=>!b.includes(s));
}
function findSectionIncludes(a, b) {
    return a.filter((s)=>b.includes(s));
}
function extractSections(src, dst) {
    const srcSections = Object.keys(src);
    const dstSections = Object.keys(dst);
    return [
        findSectionExcludes(srcSections, dstSections),
        findSectionExcludes(dstSections, srcSections)
    ];
}
function findMethodExcludes(src, dst) {
    const srcSections = Object.keys(src);
    const dstSections = findSectionIncludes(Object.keys(dst), srcSections);
    const excludes = [];
    for(let s = 0, scount = dstSections.length; s < scount; s++){
        const section = dstSections[s];
        const srcMethods = Object.keys(src[section]);
        const dstMethods = Object.keys(dst[section]);
        for(let d = 0, mcount = dstMethods.length; d < mcount; d++){
            const method = dstMethods[d];
            if (!srcMethods.includes(method)) {
                excludes.push(`${section}.${method}`);
            }
        }
    }
    return excludes;
}
function extractMethods(src, dst) {
    return [
        findMethodExcludes(dst, src),
        findMethodExcludes(src, dst)
    ];
}
function augmentObject(prefix, src, dst, fromEmpty = false) {
    fromEmpty && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$object$2f$clear$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectClear"])(dst);
    // NOTE: This part is slightly problematic since it will get the
    // values for at least all the sections and the names of the methods
    // (Since methods won't be decorated before lazy, this _may_ be ok)
    if (prefix && Object.keys(dst).length) {
        warn(prefix, 'modules', extractSections(src, dst));
        warn(prefix, 'calls', extractMethods(src, dst));
    }
    const sections = Object.keys(src);
    for(let i = 0, count = sections.length; i < count; i++){
        const section = sections[i];
        const methods = src[section];
        // We don't set here with a lazy interface, we decorate based
        // on the top-level structure (this bypasses adding lazy onto lazy)
        if (!dst[section]) {
            dst[section] = {};
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$lazy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lazyMethods"])(dst[section], Object.keys(methods), (m)=>methods[m]);
    }
    return dst;
}
}),
"[project]/node_modules/@polkadot/api/util/decorate.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "decorateDeriveSections",
    ()=>decorateDeriveSections
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2d$derive$2f$util$2f$lazy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api-derive/util/lazy.js [app-ssr] (ecmascript)");
;
function decorateDeriveSections(decorateMethod, derives) {
    const getKeys = (s)=>Object.keys(derives[s]);
    const creator = (s, m)=>decorateMethod(derives[s][m]);
    const result = {};
    const names = Object.keys(derives);
    for(let i = 0, count = names.length; i < count; i++){
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2d$derive$2f$util$2f$lazy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lazyDeriveSection"])(result, names[i], getKeys, creator);
    }
    return result;
}
}),
"[project]/node_modules/@polkadot/api/util/validate.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "extractStorageArgs",
    ()=>extractStorageArgs
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$undefined$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/is/undefined.js [app-ssr] (ecmascript)");
;
function sig({ lookup }, { method, section }, args) {
    return `${section}.${method}(${args.map((a)=>lookup.getTypeDef(a).type).join(', ')})`;
}
function extractStorageArgs(registry, creator, _args) {
    const args = _args.filter((a)=>!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$undefined$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isUndefined"])(a));
    if (creator.meta.type.isPlain) {
        if (args.length !== 0) {
            throw new Error(`${sig(registry, creator, [])} does not take any arguments, ${args.length} found`);
        }
    } else {
        const { hashers, key } = creator.meta.type.asMap;
        const keys = hashers.length === 1 ? [
            key
        ] : registry.lookup.getSiType(key).def.asTuple.map((t)=>t);
        if (args.length !== keys.length) {
            throw new Error(`${sig(registry, creator, keys)} is a map, requiring ${keys.length} arguments, ${args.length} found`);
        }
    }
    // pass as tuple
    return [
        creator,
        args
    ];
}
}),
"[project]/node_modules/@polkadot/api/base/Events.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Events",
    ()=>Events
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/eventemitter3/index.mjs [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__EventEmitter$3e$__ = __turbopack_context__.i("[project]/node_modules/eventemitter3/index.js [app-ssr] (ecmascript) <export default as EventEmitter>");
;
class Events {
    #eventemitter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$eventemitter3$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__EventEmitter$3e$__["EventEmitter"]();
    emit(type, ...args) {
        return this.#eventemitter.emit(type, ...args);
    }
    /**
     * @description Attach an eventemitter handler to listen to a specific event
     *
     * @param type The type of event to listen to. Available events are `connected`, `disconnected`, `ready` and `error`
     * @param handler The callback to be called when the event fires. Depending on the event type, it could fire with additional arguments.
     *
     * @example
     * <BR>
     *
     * ```javascript
     * api.on('connected', (): void => {
     *   console.log('API has been connected to the endpoint');
     * });
     *
     * api.on('disconnected', (): void => {
     *   console.log('API has been disconnected from the endpoint');
     * });
     * ```
     */ on(type, handler) {
        this.#eventemitter.on(type, handler);
        return this;
    }
    /**
     * @description Remove the given eventemitter handler
     *
     * @param type The type of event the callback was attached to. Available events are `connected`, `disconnected`, `ready` and `error`
     * @param handler The callback to unregister.
     *
     * @example
     * <BR>
     *
     * ```javascript
     * const handler = (): void => {
     *  console.log('Connected !);
     * };
     *
     * // Start listening
     * api.on('connected', handler);
     *
     * // Stop listening
     * api.off('connected', handler);
     * ```
     */ off(type, handler) {
        this.#eventemitter.removeListener(type, handler);
        return this;
    }
    /**
     * @description Attach an one-time eventemitter handler to listen to a specific event
     *
     * @param type The type of event to listen to. Available events are `connected`, `disconnected`, `ready` and `error`
     * @param handler The callback to be called when the event fires. Depending on the event type, it could fire with additional arguments.
     *
     * @example
     * <BR>
     *
     * ```javascript
     * api.once('connected', (): void => {
     *   console.log('API has been connected to the endpoint');
     * });
     *
     * api.once('disconnected', (): void => {
     *   console.log('API has been disconnected from the endpoint');
     * });
     * ```
     */ once(type, handler) {
        this.#eventemitter.once(type, handler);
        return this;
    }
}
}),
"[project]/node_modules/@polkadot/api/base/Decorate.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Decorate",
    ()=>Decorate
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/cjs/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2d$derive$2f$bundle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api-derive/bundle.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$rpc$2d$core$2f$util$2f$memo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/rpc-core/util/memo.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$rpc$2d$core$2f$bundle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/rpc-core/bundle.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$rpc$2d$provider$2f$ws$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/rpc-provider/ws/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2f$metadata$2f$decorate$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/types/metadata/decorate/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2f$extrinsic$2f$Extrinsic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/types/extrinsic/Extrinsic.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2f$interfaces$2f$definitions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__typeDefinitions$3e$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/types/interfaces/definitions.js [app-ssr] (ecmascript) <export * as typeDefinitions>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2f$create$2f$registry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/types/create/registry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2d$known$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/types-known/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$array$2f$chunk$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/array/chunk.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$array$2f$flatten$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/array/flatten.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$assert$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/assert.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bn$2e$js$2f$lib$2f$bn$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__BN$3e$__ = __turbopack_context__.i("[project]/node_modules/bn.js/lib/bn.js [app-ssr] (ecmascript) <export default as BN>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$compact$2f$stripLength$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/compact/stripLength.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$lazy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/lazy.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/logger.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$nextTick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/nextTick.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$object$2f$spread$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/object/spread.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$string$2f$camelCase$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/string/camelCase.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$string$2f$lowerFirst$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/string/lowerFirst.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$u8a$2f$concat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/u8a/concat.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$u8a$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/u8a/toHex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2d$crypto$2f$blake2$2f$asU8a$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util-crypto/blake2/asU8a.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$submittable$2f$createSubmittable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/submittable/createSubmittable.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$augmentObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/util/augmentObject.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$decorate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/util/decorate.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$validate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/util/validate.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$base$2f$Events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/base/Events.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$base$2f$find$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/base/find.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const PAGE_SIZE_K = 1000; // limit aligned with the 1k on the node (trie lookups are heavy)
const PAGE_SIZE_V = 250; // limited since the data may be > 16MB (e.g. misfiring elections)
const PAGE_SIZE_Q = 50; // queue of pending storage queries (mapped together, next tick)
const l = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["logger"])('api/init');
let instanceCounter = 0;
function getAtQueryFn(api, { method, section }) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$assert$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assertReturn"])(api.rx.query[section] && api.rx.query[section][method], ()=>`query.${section}.${method} is not available in this version of the metadata`);
}
class Decorate extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$base$2f$Events$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Events"] {
    #instanceId;
    #runtimeLog = {};
    #registry;
    #storageGetQ = [];
    #storageSubQ = [];
    // HACK Use BN import so decorateDerive works... yes, wtf.
    __phantom = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bn$2e$js$2f$lib$2f$bn$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__BN$3e$__["BN"](0);
    _type;
    _call = {};
    _consts = {};
    _derive;
    _errors = {};
    _events = {};
    _extrinsics;
    _extrinsicType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2f$extrinsic$2f$Extrinsic$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["GenericExtrinsic"].LATEST_EXTRINSIC_VERSION;
    _genesisHash;
    _isConnected;
    _isReady = false;
    _query = {};
    _queryMulti;
    _rpc;
    _rpcCore;
    _runtimeMap = {};
    _runtimeChain;
    _runtimeMetadata;
    _runtimeVersion;
    _rx = {
        call: {},
        consts: {},
        query: {},
        tx: {}
    };
    _options;
    /**
     * This is the one and only method concrete children classes need to implement.
     * It's a higher-order function, which takes one argument
     * `method: Method extends (...args: any[]) => Observable<any>`
     * (and one optional `options`), and should return the user facing method.
     * For example:
     * - For ApiRx, `decorateMethod` should just be identity, because the input
     * function is already an Observable
     * - For ApiPromise, `decorateMethod` should return a function that takes all
     * the parameters from `method`, adds an optional `callback` argument, and
     * returns a Promise.
     *
     * We could easily imagine other user-facing interfaces, which are simply
     * implemented by transforming the Observable to Stream/Iterator/Kefir/Bacon
     * via `decorateMethod`.
     */ _decorateMethod;
    /**
     * @description Create an instance of the class
     *
     * @param options Options object to create API instance or a Provider instance
     *
     * @example
     * <BR>
     *
     * ```javascript
     * import Api from '@polkadot/api/promise';
     *
     * const api = new Api().isReady();
     *
     * api.rpc.subscribeNewHeads((header) => {
     *   console.log(`new block #${header.number.toNumber()}`);
     * });
     * ```
     */ constructor(options, type, decorateMethod){
        super();
        this.#instanceId = `${++instanceCounter}`;
        this.#registry = options.source?.registry || options.registry || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2f$create$2f$registry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TypeRegistry"]();
        this._rx.callAt = (blockHash, knownVersion)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["from"])(this.at(blockHash, knownVersion)).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["map"])((a)=>a.rx.call));
        this._rx.queryAt = (blockHash, knownVersion)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["from"])(this.at(blockHash, knownVersion)).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["map"])((a)=>a.rx.query));
        this._rx.registry = this.#registry;
        this._decorateMethod = decorateMethod;
        this._options = options;
        this._type = type;
        const provider = options.source ? options.source._rpcCore.provider.isClonable ? options.source._rpcCore.provider.clone() : options.source._rpcCore.provider : options.provider || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$rpc$2d$provider$2f$ws$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WsProvider"]();
        // The RPC interface decorates the known interfaces on init
        this._rpcCore = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$rpc$2d$core$2f$bundle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["RpcCore"](this.#instanceId, this.#registry, {
            isPedantic: this._options.isPedantic,
            provider,
            rpcCacheCapacity: this._options.rpcCacheCapacity,
            ttl: this._options.provider?.ttl,
            userRpc: this._options.rpc
        });
        this._isConnected = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BehaviorSubject"](this._rpcCore.provider.isConnected);
        this._rx.hasSubscriptions = this._rpcCore.provider.hasSubscriptions;
    }
    /**
     * @description Return the current used registry
     */ get registry() {
        return this.#registry;
    }
    /**
     * @description Creates an instance of a type as registered
     */ createType(type, ...params) {
        return this.#registry.createType(type, ...params);
    }
    /**
     * @description Register additional user-defined of chain-specific types in the type registry
     */ registerTypes(types) {
        types && this.#registry.register(types);
    }
    /**
     * @returns `true` if the API operates with subscriptions
     */ get hasSubscriptions() {
        return this._rpcCore.provider.hasSubscriptions;
    }
    /**
     * @returns `true` if the API decorate multi-key queries
     */ get supportMulti() {
        return this._rpcCore.provider.hasSubscriptions || !!this._rpcCore.state.queryStorageAt;
    }
    _emptyDecorated(registry, blockHash) {
        return {
            call: {},
            consts: {},
            errors: {},
            events: {},
            query: {},
            registry,
            rx: {
                call: {},
                query: {}
            },
            tx: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$submittable$2f$createSubmittable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createSubmittable"])(this._type, this._rx, this._decorateMethod, registry, blockHash)
        };
    }
    _createDecorated(registry, fromEmpty, decoratedApi, blockHash) {
        if (!decoratedApi) {
            decoratedApi = this._emptyDecorated(registry.registry, blockHash);
        }
        if (fromEmpty || !registry.decoratedMeta) {
            registry.decoratedMeta = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2f$metadata$2f$decorate$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["expandMetadata"])(registry.registry, registry.metadata);
        }
        const runtime = this._decorateCalls(registry, this._decorateMethod, blockHash);
        const runtimeRx = this._decorateCalls(registry, this._rxDecorateMethod, blockHash);
        const storage = this._decorateStorage(registry.decoratedMeta, this._decorateMethod, blockHash);
        const storageRx = this._decorateStorage(registry.decoratedMeta, this._rxDecorateMethod, blockHash);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$augmentObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["augmentObject"])('consts', registry.decoratedMeta.consts, decoratedApi.consts, fromEmpty);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$augmentObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["augmentObject"])('errors', registry.decoratedMeta.errors, decoratedApi.errors, fromEmpty);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$augmentObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["augmentObject"])('events', registry.decoratedMeta.events, decoratedApi.events, fromEmpty);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$augmentObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["augmentObject"])('query', storage, decoratedApi.query, fromEmpty);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$augmentObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["augmentObject"])('query', storageRx, decoratedApi.rx.query, fromEmpty);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$augmentObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["augmentObject"])('call', runtime, decoratedApi.call, fromEmpty);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$augmentObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["augmentObject"])('call', runtimeRx, decoratedApi.rx.call, fromEmpty);
        decoratedApi.findCall = (callIndex)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$base$2f$find$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["findCall"])(registry.registry, callIndex);
        decoratedApi.findError = (errorIndex)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$base$2f$find$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["findError"])(registry.registry, errorIndex);
        decoratedApi.queryMulti = blockHash ? this._decorateMultiAt(decoratedApi, this._decorateMethod, blockHash) : this._decorateMulti(this._decorateMethod);
        decoratedApi.runtimeVersion = registry.runtimeVersion;
        return {
            createdAt: blockHash,
            decoratedApi,
            decoratedMeta: registry.decoratedMeta
        };
    }
    _injectMetadata(registry, fromEmpty = false) {
        // clear the decoration, we are redoing it here
        if (fromEmpty || !registry.decoratedApi) {
            registry.decoratedApi = this._emptyDecorated(registry.registry);
        }
        const { decoratedApi, decoratedMeta } = this._createDecorated(registry, fromEmpty, registry.decoratedApi);
        this._call = decoratedApi.call;
        this._consts = decoratedApi.consts;
        this._errors = decoratedApi.errors;
        this._events = decoratedApi.events;
        this._query = decoratedApi.query;
        this._rx.call = decoratedApi.rx.call;
        this._rx.query = decoratedApi.rx.query;
        const tx = this._decorateExtrinsics(decoratedMeta, this._decorateMethod);
        const rxtx = this._decorateExtrinsics(decoratedMeta, this._rxDecorateMethod);
        if (fromEmpty || !this._extrinsics) {
            this._extrinsics = tx;
            this._rx.tx = rxtx;
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$augmentObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["augmentObject"])('tx', tx, this._extrinsics, false);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$augmentObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["augmentObject"])(null, rxtx, this._rx.tx, false);
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$augmentObject$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["augmentObject"])(null, decoratedMeta.consts, this._rx.consts, fromEmpty);
        this.emit('decorated');
    }
    /**
     * @deprecated
     * backwards compatible endpoint for metadata injection, may be removed in the future (However, it is still useful for testing injection)
     */ injectMetadata(metadata, fromEmpty, registry) {
        this._injectMetadata({
            counter: 0,
            metadata,
            registry: registry || this.#registry,
            runtimeVersion: this.#registry.createType('RuntimeVersionPartial')
        }, fromEmpty);
    }
    _decorateFunctionMeta(input, output) {
        output.meta = input.meta;
        output.method = input.method;
        output.section = input.section;
        output.toJSON = input.toJSON;
        if (input.callIndex) {
            output.callIndex = input.callIndex;
        }
        return output;
    }
    // Filter all RPC methods based on the results of the rpc_methods call. We do this in the following
    // manner to cater for both old and new:
    //   - when the number of entries are 0, only remove the ones with isOptional (account & contracts)
    //   - when non-zero, remove anything that is not in the array (we don't do this)
    _filterRpc(methods, additional) {
        // add any specific user-base RPCs
        if (Object.keys(additional).length !== 0) {
            this._rpcCore.addUserInterfaces(additional);
            // re-decorate, only adding any new additional interfaces
            this._decorateRpc(this._rpcCore, this._decorateMethod, this._rpc);
            this._decorateRpc(this._rpcCore, this._rxDecorateMethod, this._rx.rpc);
        }
        // extract the actual sections from the methods (this is useful when
        // we try and create mappings to runtime names via a hash mapping)
        const sectionMap = {};
        for(let i = 0, count = methods.length; i < count; i++){
            const [section] = methods[i].split('_');
            sectionMap[section] = true;
        }
        // convert the actual section names into an easy name lookup
        const sections = Object.keys(sectionMap);
        for(let i = 0, count = sections.length; i < count; i++){
            const nameA = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$string$2f$lowerFirst$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringUpperFirst"])(sections[i]);
            const nameB = `${nameA}Api`;
            this._runtimeMap[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2d$crypto$2f$blake2$2f$asU8a$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["blake2AsHex"])(nameA, 64)] = nameA;
            this._runtimeMap[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2d$crypto$2f$blake2$2f$asU8a$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["blake2AsHex"])(nameB, 64)] = nameB;
        }
        // finally we filter the actual methods to expose
        this._filterRpcMethods(methods);
    }
    _filterRpcMethods(exposed) {
        const hasResults = exposed.length !== 0;
        const allKnown = [
            ...this._rpcCore.mapping.entries()
        ];
        const allKeys = [];
        const count = allKnown.length;
        for(let i = 0; i < count; i++){
            const [, { alias, endpoint, method, pubsub, section }] = allKnown[i];
            allKeys.push(`${section}_${method}`);
            if (pubsub) {
                allKeys.push(`${section}_${pubsub[1]}`);
                allKeys.push(`${section}_${pubsub[2]}`);
            }
            if (alias) {
                allKeys.push(...alias);
            }
            if (endpoint) {
                allKeys.push(endpoint);
            }
        }
        const unknown = exposed.filter((k)=>!allKeys.includes(k) && !k.includes('_unstable_'));
        if (unknown.length && !this._options.noInitWarn) {
            l.warn(`RPC methods not decorated: ${unknown.join(', ')}`);
        }
        // loop through all entries we have (populated in decorate) and filter as required
        // only remove when we have results and method missing, or with no results if optional
        for(let i = 0; i < count; i++){
            const [k, { method, section }] = allKnown[i];
            if (hasResults && !exposed.includes(k) && k !== 'rpc_methods') {
                if (this._rpc[section]) {
                    delete this._rpc[section][method];
                    delete this._rx.rpc[section][method];
                }
            }
        }
    }
    _rpcSubmitter(decorateMethod) {
        const method = (method, ...params)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["from"])(this._rpcCore.provider.send(method, params));
        };
        return decorateMethod(method);
    }
    _decorateRpc(rpc, decorateMethod, input = this._rpcSubmitter(decorateMethod)) {
        const out = input;
        const decorateFn = (section, method)=>{
            const source = rpc[section][method];
            const fn = decorateMethod(source, {
                methodName: method
            });
            fn.meta = source.meta;
            fn.raw = decorateMethod(source.raw, {
                methodName: method
            });
            return fn;
        };
        for(let s = 0, scount = rpc.sections.length; s < scount; s++){
            const section = rpc.sections[s];
            if (!Object.prototype.hasOwnProperty.call(out, section)) {
                const methods = Object.keys(rpc[section]);
                const decorateInternal = (method)=>decorateFn(section, method);
                for(let m = 0, mcount = methods.length; m < mcount; m++){
                    const method = methods[m];
                    //  skip subscriptions where we have a non-subscribe interface
                    if (this.hasSubscriptions || !(method.startsWith('subscribe') || method.startsWith('unsubscribe'))) {
                        if (!Object.prototype.hasOwnProperty.call(out, section)) {
                            out[section] = {};
                        }
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$lazy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lazyMethod"])(out[section], method, decorateInternal);
                    }
                }
            }
        }
        return out;
    }
    // add all definition entries
    _addRuntimeDef(result, additional) {
        if (!additional) {
            return;
        }
        const entries = Object.entries(additional);
        for(let j = 0, ecount = entries.length; j < ecount; j++){
            const [key, defs] = entries[j];
            if (result[key]) {
                // we have this one already, step through for new versions or
                // new methods and add those as applicable
                for(let k = 0, dcount = defs.length; k < dcount; k++){
                    const def = defs[k];
                    const prev = result[key].find(({ version })=>def.version === version);
                    if (prev) {
                        // interleave the new methods with the old - last definition wins
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$object$2f$spread$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectSpread"])(prev.methods, def.methods);
                    } else {
                        // we don't have this specific version, add it
                        result[key].push(def);
                    }
                }
            } else {
                // we don't have this runtime definition, add it as-is
                result[key] = defs;
            }
        }
    }
    // extract all runtime definitions
    _getRuntimeDefs(registry, specName, chain = '') {
        const result = {};
        const defValues = Object.values(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2f$interfaces$2f$definitions$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__typeDefinitions$3e$__["typeDefinitions"]);
        // options > chain/spec > built-in, apply in reverse order with
        // methods overriding previous definitions (or interleave missing)
        for(let i = 0, count = defValues.length; i < count; i++){
            this._addRuntimeDef(result, defValues[i].runtime);
        }
        this._addRuntimeDef(result, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2d$known$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getSpecRuntime"])(registry, chain, specName));
        this._addRuntimeDef(result, this._options.runtime);
        return Object.entries(result);
    }
    // Helper for _getRuntimeDefsViaMetadata
    _getMethods(registry, methods) {
        const result = {};
        methods.forEach((m)=>{
            const { docs, inputs, name, output } = m;
            result[name.toString()] = {
                description: docs.map((d)=>d.toString()).join(),
                params: inputs.map(({ name, type })=>{
                    return {
                        name: name.toString(),
                        type: registry.lookup.getName(type) || registry.lookup.getTypeDef(type).type
                    };
                }),
                type: registry.lookup.getName(output) || registry.lookup.getTypeDef(output).type
            };
        });
        return result;
    }
    // Maintains the same structure as `_getRuntimeDefs` in order to make conversion easier.
    _getRuntimeDefsViaMetadata(registry) {
        const result = {};
        const { apis } = registry.metadata;
        for(let i = 0, count = apis.length; i < count; i++){
            const { methods, name } = apis[i];
            result[name.toString()] = [
                {
                    methods: this._getMethods(registry, methods),
                    // We set the version to 0 here since it will not be relevant when we are grabbing the runtime apis
                    // from the Metadata.
                    version: 0
                }
            ];
        }
        return Object.entries(result);
    }
    // When the calls are available in the metadata, it will generate them based off of the metadata.
    // When they are not available it will use the hardcoded calls generated in the static types.
    _decorateCalls({ registry, runtimeVersion: { apis, specName, specVersion } }, decorateMethod, blockHash) {
        const result = {};
        const named = {};
        const hashes = {};
        const isApiInMetadata = registry.metadata.apis.length > 0;
        const sections = isApiInMetadata ? this._getRuntimeDefsViaMetadata(registry) : this._getRuntimeDefs(registry, specName, this._runtimeChain);
        const older = [];
        const implName = `${specName.toString()}/${specVersion.toString()}`;
        const hasLogged = this.#runtimeLog[implName] || false;
        this.#runtimeLog[implName] = true;
        if (isApiInMetadata) {
            for(let i = 0, scount = sections.length; i < scount; i++){
                const [_section, secs] = sections[i];
                const sec = secs[0];
                const sectionHash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2d$crypto$2f$blake2$2f$asU8a$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["blake2AsHex"])(_section, 64);
                const section = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$string$2f$camelCase$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringCamelCase"])(_section);
                const methods = Object.entries(sec.methods);
                if (!named[section]) {
                    named[section] = {};
                }
                for(let m = 0, mcount = methods.length; m < mcount; m++){
                    const [_method, def] = methods[m];
                    const method = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$string$2f$camelCase$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringCamelCase"])(_method);
                    named[section][method] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$object$2f$spread$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectSpread"])({
                        method,
                        name: `${_section}_${_method}`,
                        section,
                        sectionHash
                    }, def);
                }
            }
        } else {
            for(let i = 0, scount = sections.length; i < scount; i++){
                const [_section, secs] = sections[i];
                const sectionHash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2d$crypto$2f$blake2$2f$asU8a$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["blake2AsHex"])(_section, 64);
                const rtApi = apis.find(([a])=>a.eq(sectionHash));
                hashes[sectionHash] = true;
                if (rtApi) {
                    const all = secs.map(({ version })=>version).sort();
                    const sec = secs.find(({ version })=>rtApi[1].eq(version));
                    if (sec) {
                        const section = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$string$2f$camelCase$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringCamelCase"])(_section);
                        const methods = Object.entries(sec.methods);
                        if (methods.length) {
                            if (!named[section]) {
                                named[section] = {};
                            }
                            for(let m = 0, mcount = methods.length; m < mcount; m++){
                                const [_method, def] = methods[m];
                                const method = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$string$2f$camelCase$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["stringCamelCase"])(_method);
                                named[section][method] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$object$2f$spread$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectSpread"])({
                                    method,
                                    name: `${_section}_${_method}`,
                                    section,
                                    sectionHash
                                }, def);
                            }
                        }
                    } else {
                        older.push(`${_section}/${rtApi[1].toString()} (${all.join('/')} known)`);
                    }
                }
            }
            // find the runtimes that we don't have hashes for
            const notFound = apis.map(([a, v])=>[
                    a.toHex(),
                    v.toString()
                ]).filter(([a])=>!hashes[a]).map(([a, v])=>`${this._runtimeMap[a] || a}/${v}`);
            if (!this._options.noInitWarn && !hasLogged) {
                if (older.length) {
                    l.warn(`${implName}: Not decorating runtime apis without matching versions: ${older.join(', ')}`);
                }
                if (notFound.length) {
                    l.warn(`${implName}: Not decorating unknown runtime apis: ${notFound.join(', ')}`);
                }
            }
        }
        const stateCall = blockHash ? (name, bytes)=>this._rpcCore.state.call(name, bytes, blockHash) : (name, bytes)=>this._rpcCore.state.call(name, bytes);
        const lazySection = (section)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$lazy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lazyMethods"])({}, Object.keys(named[section]), (method)=>this._decorateCall(registry, named[section][method], stateCall, decorateMethod));
        const modules = Object.keys(named);
        for(let i = 0, count = modules.length; i < count; i++){
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$lazy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lazyMethod"])(result, modules[i], lazySection);
        }
        return result;
    }
    _decorateCall(registry, def, stateCall, decorateMethod) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const decorated = decorateMethod((...args)=>{
            if (args.length !== def.params.length) {
                throw new Error(`${def.name}:: Expected ${def.params.length} arguments, found ${args.length}`);
            }
            const bytes = registry.createType('Raw', (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$u8a$2f$concat$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u8aConcatStrict"])(args.map((a, i)=>registry.createTypeUnsafe(def.params[i].type, [
                    a
                ]).toU8a())));
            return stateCall(def.name, bytes).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["map"])((r)=>registry.createTypeUnsafe(def.type, [
                    r
                ])));
        });
        decorated.meta = def;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return decorated;
    }
    // only be called if supportMulti is true
    _decorateMulti(decorateMethod) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return decorateMethod((keys)=>keys.length ? (this.hasSubscriptions ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt)(keys.map((args)=>Array.isArray(args) ? args[0].creator.meta.type.isPlain ? [
                    args[0].creator
                ] : args[0].creator.meta.type.asMap.hashers.length === 1 ? [
                    args[0].creator,
                    args.slice(1)
                ] : [
                    args[0].creator,
                    ...args.slice(1)
                ] : [
                    args.creator
                ])) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["of"])([]));
    }
    _decorateMultiAt(atApi, decorateMethod, blockHash) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return decorateMethod((calls)=>calls.length ? this._rpcCore.state.queryStorageAt(calls.map((args)=>{
                if (Array.isArray(args)) {
                    const { creator } = getAtQueryFn(atApi, args[0].creator);
                    return creator.meta.type.isPlain ? [
                        creator
                    ] : creator.meta.type.asMap.hashers.length === 1 ? [
                        creator,
                        args.slice(1)
                    ] : [
                        creator,
                        ...args.slice(1)
                    ];
                }
                return [
                    getAtQueryFn(atApi, args.creator).creator
                ];
            }), blockHash) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["of"])([]));
    }
    _decorateExtrinsics({ tx }, decorateMethod) {
        const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$submittable$2f$createSubmittable$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createSubmittable"])(this._type, this._rx, decorateMethod);
        const lazySection = (section)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$lazy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lazyMethods"])({}, Object.keys(tx[section]), (method)=>method.startsWith('$') ? tx[section][method] : this._decorateExtrinsicEntry(tx[section][method], result));
        const sections = Object.keys(tx);
        for(let i = 0, count = sections.length; i < count; i++){
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$lazy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lazyMethod"])(result, sections[i], lazySection);
        }
        return result;
    }
    _decorateExtrinsicEntry(method, creator) {
        const decorated = (...params)=>creator(method(...params));
        // pass through the `.is`
        decorated.is = (other)=>method.is(other);
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return this._decorateFunctionMeta(method, decorated);
    }
    _decorateStorage({ query, registry }, decorateMethod, blockHash) {
        const result = {};
        const lazySection = (section)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$lazy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lazyMethods"])({}, Object.keys(query[section]), (method)=>blockHash ? this._decorateStorageEntryAt(registry, query[section][method], decorateMethod, blockHash) : this._decorateStorageEntry(query[section][method], decorateMethod));
        const sections = Object.keys(query);
        for(let i = 0, count = sections.length; i < count; i++){
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$lazy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["lazyMethod"])(result, sections[i], lazySection);
        }
        return result;
    }
    _decorateStorageEntry(creator, decorateMethod) {
        const getArgs = (args, registry)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$validate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extractStorageArgs"])(registry || this.#registry, creator, args);
        const getQueryAt = (blockHash)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["from"])(this.at(blockHash)).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["map"])((api)=>getAtQueryFn(api, creator)));
        // Disable this where it occurs for each field we are decorating
        /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */ const decorated = this._decorateStorageCall(creator, decorateMethod);
        decorated.creator = creator;
        // eslint-disable-next-line deprecation/deprecation
        decorated.at = decorateMethod((blockHash, ...args)=>getQueryAt(blockHash).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["switchMap"])((q)=>q(...args))));
        decorated.hash = decorateMethod((...args)=>this._rpcCore.state.getStorageHash(getArgs(args)));
        decorated.is = (key)=>key.section === creator.section && key.method === creator.method;
        decorated.key = (...args)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$u8a$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u8aToHex"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$compact$2f$stripLength$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["compactStripLength"])(creator(...args))[1]);
        decorated.keyPrefix = (...args)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$u8a$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u8aToHex"])(creator.keyPrefix(...args));
        decorated.size = decorateMethod((...args)=>this._rpcCore.state.getStorageSize(getArgs(args)));
        // eslint-disable-next-line deprecation/deprecation
        decorated.sizeAt = decorateMethod((blockHash, ...args)=>getQueryAt(blockHash).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["switchMap"])((q)=>this._rpcCore.state.getStorageSize(getArgs(args, q.creator.meta.registry), blockHash))));
        // .keys() & .entries() only available on map types
        if (creator.iterKey && creator.meta.type.isMap) {
            decorated.entries = decorateMethod((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$rpc$2d$core$2f$util$2f$memo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["memo"])(this.#instanceId, (...args)=>this._retrieveMapEntries(creator, null, args)));
            // eslint-disable-next-line deprecation/deprecation
            decorated.entriesAt = decorateMethod((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$rpc$2d$core$2f$util$2f$memo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["memo"])(this.#instanceId, (blockHash, ...args)=>getQueryAt(blockHash).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["switchMap"])((q)=>this._retrieveMapEntries(q.creator, blockHash, args)))));
            decorated.entriesPaged = decorateMethod((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$rpc$2d$core$2f$util$2f$memo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["memo"])(this.#instanceId, (opts)=>this._retrieveMapEntriesPaged(creator, undefined, opts)));
            decorated.keys = decorateMethod((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$rpc$2d$core$2f$util$2f$memo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["memo"])(this.#instanceId, (...args)=>this._retrieveMapKeys(creator, null, args)));
            // eslint-disable-next-line deprecation/deprecation
            decorated.keysAt = decorateMethod((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$rpc$2d$core$2f$util$2f$memo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["memo"])(this.#instanceId, (blockHash, ...args)=>getQueryAt(blockHash).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["switchMap"])((q)=>this._retrieveMapKeys(q.creator, blockHash, args)))));
            decorated.keysPaged = decorateMethod((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$rpc$2d$core$2f$util$2f$memo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["memo"])(this.#instanceId, (opts)=>this._retrieveMapKeysPaged(creator, undefined, opts)));
        }
        if (this.supportMulti && creator.meta.type.isMap) {
            // When using double map storage function, user need to pass double map key as an array
            decorated.multi = decorateMethod((args)=>creator.meta.type.asMap.hashers.length === 1 ? this._retrieveMulti(args.map((a)=>[
                        creator,
                        [
                            a
                        ]
                    ])) : this._retrieveMulti(args.map((a)=>[
                        creator,
                        a
                    ])));
        }
        /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */ return this._decorateFunctionMeta(creator, decorated);
    }
    _decorateStorageEntryAt(registry, creator, decorateMethod, blockHash) {
        const getArgs = (args)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$validate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extractStorageArgs"])(registry, creator, args);
        // Disable this where it occurs for each field we are decorating
        /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */ const decorated = decorateMethod((...args)=>this._rpcCore.state.getStorage(getArgs(args), blockHash));
        decorated.creator = creator;
        decorated.hash = decorateMethod((...args)=>this._rpcCore.state.getStorageHash(getArgs(args), blockHash));
        decorated.is = (key)=>key.section === creator.section && key.method === creator.method;
        decorated.key = (...args)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$u8a$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u8aToHex"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$compact$2f$stripLength$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["compactStripLength"])(creator(...args))[1]);
        decorated.keyPrefix = (...keys)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$u8a$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u8aToHex"])(creator.keyPrefix(...keys));
        decorated.size = decorateMethod((...args)=>this._rpcCore.state.getStorageSize(getArgs(args), blockHash));
        // .keys() & .entries() only available on map types
        if (creator.iterKey && creator.meta.type.isMap) {
            decorated.entries = decorateMethod((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$rpc$2d$core$2f$util$2f$memo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["memo"])(this.#instanceId, (...args)=>this._retrieveMapEntries(creator, blockHash, args)));
            decorated.entriesPaged = decorateMethod((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$rpc$2d$core$2f$util$2f$memo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["memo"])(this.#instanceId, (opts)=>this._retrieveMapEntriesPaged(creator, blockHash, opts)));
            decorated.keys = decorateMethod((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$rpc$2d$core$2f$util$2f$memo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["memo"])(this.#instanceId, (...args)=>this._retrieveMapKeys(creator, blockHash, args)));
            decorated.keysPaged = decorateMethod((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$rpc$2d$core$2f$util$2f$memo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["memo"])(this.#instanceId, (opts)=>this._retrieveMapKeysPaged(creator, blockHash, opts)));
        }
        if (this.supportMulti && creator.meta.type.isMap) {
            // When using double map storage function, user need to pass double map key as an array
            decorated.multi = decorateMethod((args)=>creator.meta.type.asMap.hashers.length === 1 ? this._retrieveMulti(args.map((a)=>[
                        creator,
                        [
                            a
                        ]
                    ]), blockHash) : this._retrieveMulti(args.map((a)=>[
                        creator,
                        a
                    ]), blockHash));
        }
        /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */ return this._decorateFunctionMeta(creator, decorated);
    }
    _queueStorage(call, queue) {
        const query = queue === this.#storageSubQ ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt;
        let queueIdx = queue.length - 1;
        let valueIdx = 0;
        let valueObs;
        // if we don't have queue entries yet,
        // or the current queue has fired (see from below),
        // or the current queue has the max entries,
        // then we create a new queue
        if (queueIdx === -1 || !queue[queueIdx] || queue[queueIdx][1].length === PAGE_SIZE_Q) {
            queueIdx++;
            valueObs = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["from"])(// we delay the execution until the next tick, this allows
            // any queries made in this timeframe to be added to the same
            // queue for a single query
            new Promise((resolve)=>{
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$nextTick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nextTick"])(()=>{
                    // get all the calls in this instance, resolve with it
                    // and then clear the queue so we don't add more
                    // (anything after this will be added to a new queue)
                    const calls = queue[queueIdx][1];
                    delete queue[queueIdx];
                    resolve(calls);
                });
            })).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["switchMap"])((calls)=>query(calls)));
            queue.push([
                valueObs,
                [
                    call
                ]
            ]);
        } else {
            valueObs = queue[queueIdx][0];
            valueIdx = queue[queueIdx][1].length;
            queue[queueIdx][1].push(call);
        }
        return valueObs.pipe(// return the single value at this index
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["map"])((values)=>values[valueIdx]));
    }
    // Decorate the base storage call. In the case or rxjs or promise-without-callback (await)
    // we make a subscription, alternatively we push this through a single-shot query
    _decorateStorageCall(creator, decorateMethod) {
        const memoed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$rpc$2d$core$2f$util$2f$memo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["memo"])(this.#instanceId, (...args)=>{
            const call = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$validate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extractStorageArgs"])(this.#registry, creator, args);
            if (!this.hasSubscriptions) {
                return this._rpcCore.state.getStorage(call);
            }
            return this._queueStorage(call, this.#storageSubQ);
        });
        return decorateMethod(memoed, {
            methodName: creator.method,
            overrideNoSub: (...args)=>this._queueStorage((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$validate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["extractStorageArgs"])(this.#registry, creator, args), this.#storageGetQ)
        });
    }
    // retrieve a set of values for a specific set of keys - here we chunk the keys into PAGE_SIZE sizes
    _retrieveMulti(keys, blockHash) {
        if (!keys.length) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["of"])([]);
        }
        const query = this.hasSubscriptions && !blockHash ? this._rpcCore.state.subscribeStorage : this._rpcCore.state.queryStorageAt;
        if (keys.length <= PAGE_SIZE_V) {
            return blockHash ? query(keys, blockHash) : query(keys);
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["combineLatest"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$array$2f$chunk$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arrayChunk"])(keys, PAGE_SIZE_V).map((k)=>blockHash ? query(k, blockHash) : query(k))).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["map"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$array$2f$flatten$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arrayFlatten"]));
    }
    _retrieveMapKeys({ iterKey, meta, method, section }, at, args) {
        if (!iterKey || !meta.type.isMap) {
            throw new Error('keys can only be retrieved on maps');
        }
        const headKey = iterKey(...args).toHex();
        const startSubject = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BehaviorSubject"](headKey);
        const query = at ? (startKey)=>this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K, startKey, at) : (startKey)=>this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K, startKey);
        const setMeta = (key)=>key.setMeta(meta, section, method);
        return startSubject.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["switchMap"])(query), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["map"])((keys)=>keys.map(setMeta)), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tap"])((keys)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$nextTick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nextTick"])(()=>{
                keys.length === PAGE_SIZE_K ? startSubject.next(keys[PAGE_SIZE_K - 1].toHex()) : startSubject.complete();
            })), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toArray"])(), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["map"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$array$2f$flatten$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arrayFlatten"]));
    }
    _retrieveMapKeysPaged({ iterKey, meta, method, section }, at, opts) {
        if (!iterKey || !meta.type.isMap) {
            throw new Error('keys can only be retrieved on maps');
        }
        const setMeta = (key)=>key.setMeta(meta, section, method);
        const query = at ? (headKey)=>this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey, at) : (headKey)=>this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey);
        return query(iterKey(...opts.args).toHex()).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["map"])((keys)=>keys.map(setMeta)));
    }
    _retrieveMapEntries(entry, at, args) {
        const query = at ? (keys)=>this._rpcCore.state.queryStorageAt(keys, at) : (keys)=>this._rpcCore.state.queryStorageAt(keys);
        return this._retrieveMapKeys(entry, at, args).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["switchMap"])((keys)=>keys.length ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["combineLatest"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$array$2f$chunk$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arrayChunk"])(keys, PAGE_SIZE_V).map(query)).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["map"])((valsArr)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$array$2f$flatten$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["arrayFlatten"])(valsArr).map((value, index)=>[
                        keys[index],
                        value
                    ]))) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["of"])([])));
    }
    _retrieveMapEntriesPaged(entry, at, opts) {
        const query = at ? (keys)=>this._rpcCore.state.queryStorageAt(keys, at) : (keys)=>this._rpcCore.state.queryStorageAt(keys);
        return this._retrieveMapKeysPaged(entry, at, opts).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["switchMap"])((keys)=>keys.length ? query(keys).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["map"])((valsArr)=>valsArr.map((value, index)=>[
                        keys[index],
                        value
                    ]))) : (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["of"])([])));
    }
    _decorateDeriveRx(decorateMethod) {
        const specName = this._runtimeVersion?.specName.toString();
        // Pull in derive from api-derive
        const available = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2d$derive$2f$bundle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getAvailableDerives"])(this.#instanceId, this._rx, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$object$2f$spread$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectSpread"])({}, this._options.derives, this._options.typesBundle?.spec?.[specName || '']?.derives));
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$decorate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decorateDeriveSections"])(decorateMethod, available);
    }
    _decorateDerive(decorateMethod) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$util$2f$decorate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decorateDeriveSections"])(decorateMethod, this._rx.derive);
    }
    /**
     * Put the `this.onCall` function of ApiRx here, because it is needed by
     * `api._rx`.
     */ _rxDecorateMethod = (method)=>{
        return method;
    };
}
}),
"[project]/node_modules/@polkadot/api/base/Init.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Init",
    ()=>Init
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/cjs/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2f$metadata$2f$Metadata$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/types/metadata/Metadata.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2f$create$2f$registry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/types/create/registry.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2f$extrinsic$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/types/extrinsic/constants.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2d$known$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/types-known/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$assert$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/assert.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$bn$2f$consts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/bn/consts.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$undefined$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/is/undefined.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/logger.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$noop$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/noop.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$object$2f$spread$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/object/spread.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$u8a$2f$eq$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/u8a/eq.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$u8a$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/u8a/toHex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$u8a$2f$toU8a$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/u8a/toU8a.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2d$crypto$2f$blake2$2f$asU8a$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util-crypto/blake2/asU8a.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2d$crypto$2f$crypto$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util-crypto/crypto.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$base$2f$Decorate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/base/Decorate.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
const KEEPALIVE_INTERVAL = 10000;
const WITH_VERSION_SHORTCUT = false;
const SUPPORTED_METADATA_VERSIONS = [
    16,
    15,
    14
];
const l = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$logger$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["logger"])('api/init');
function textToString(t) {
    return t.toString();
}
class Init extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$base$2f$Decorate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Decorate"] {
    #atLast = null;
    #healthTimer = null;
    #registries = [];
    #updateSub = null;
    #waitingRegistries = {};
    constructor(options, type, decorateMethod){
        super(options, type, decorateMethod);
        // all injected types added to the registry for overrides
        this.registry.setKnownTypes(options);
        // We only register the types (global) if this is not a cloned instance.
        // Do right up-front, so we get in the user types before we are actually
        // doing anything on-chain, this ensures we have the overrides in-place
        if (!options.source) {
            this.registerTypes(options.types);
        } else {
            this.#registries = options.source.#registries;
        }
        this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);
        this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);
        if (this.supportMulti) {
            this._queryMulti = this._decorateMulti(this._decorateMethod);
            this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);
        }
        this._rx.signer = options.signer;
        this._rpcCore.setRegistrySwap((blockHash)=>this.getBlockRegistry(blockHash));
        this._rpcCore.setResolveBlockHash((blockNumber)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["firstValueFrom"])(this._rpcCore.chain.getBlockHash(blockNumber)));
        if (this.hasSubscriptions) {
            this._rpcCore.provider.on('disconnected', ()=>this.#onProviderDisconnect());
            this._rpcCore.provider.on('error', (e)=>this.#onProviderError(e));
            this._rpcCore.provider.on('connected', ()=>this.#onProviderConnect());
        } else if (!this._options.noInitWarn) {
            l.warn('Api will be available in a limited mode since the provider does not support subscriptions');
        }
        // If the provider was instantiated earlier, and has already emitted a
        // 'connected' event, then the `on('connected')` won't fire anymore. To
        // cater for this case, we call manually `this._onProviderConnect`.
        if (this._rpcCore.provider.isConnected) {
            this.#onProviderConnect().catch(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$noop$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["noop"]);
        }
    }
    /**
     * @description Decorates a registry based on the runtime version
     */ _initRegistry(registry, chain, version, metadata, chainProps) {
        registry.clearCache();
        registry.setChainProperties(chainProps || this.registry.getChainProperties());
        registry.setKnownTypes(this._options);
        registry.register((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2d$known$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getSpecTypes"])(registry, chain, version.specName, version.specVersion));
        registry.setHasher((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2d$known$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getSpecHasher"])(registry, chain, version.specName));
        // for bundled types, pull through the aliases defined
        if (registry.knownTypes.typesBundle) {
            registry.knownTypes.typesAlias = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2d$known$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getSpecAlias"])(registry, chain, version.specName);
        }
        registry.setMetadata(metadata, undefined, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$object$2f$spread$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectSpread"])({}, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2d$known$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getSpecExtensions"])(registry, chain, version.specName), this._options.signedExtensions), this._options.noInitWarn);
    }
    /**
     * @description Returns the default versioned registry
     */ _getDefaultRegistry() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$assert$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["assertReturn"])(this.#registries.find(({ isDefault })=>isDefault), 'Initialization error, cannot find the default registry');
    }
    /**
     * @description Returns a decorated API instance at a specific point in time
     */ async at(blockHash, knownVersion) {
        const u8aHash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$u8a$2f$toU8a$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u8aToU8a"])(blockHash);
        const u8aHex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$u8a$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u8aToHex"])(u8aHash);
        const registry = await this.getBlockRegistry(u8aHash, knownVersion);
        if (!this.#atLast || this.#atLast[0] !== u8aHex) {
            // always create a new decoration - since we are pointing to a specific hash, this
            // means that all queries needs to use that hash (not a previous one already existing)
            this.#atLast = [
                u8aHex,
                this._createDecorated(registry, true, null, u8aHash).decoratedApi
            ];
        }
        return this.#atLast[1];
    }
    async _createBlockRegistry(blockHash, header, version) {
        const registry = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2f$create$2f$registry$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TypeRegistry"](blockHash);
        const metadata = await this._retrieveMetadata(version.apis, header.parentHash, registry);
        const runtimeChain = this._runtimeChain;
        if (!runtimeChain) {
            throw new Error('Invalid initializion order, runtimeChain is not available');
        }
        this._initRegistry(registry, runtimeChain, version, metadata);
        // add our new registry
        const result = {
            counter: 0,
            lastBlockHash: blockHash,
            metadata,
            registry,
            runtimeVersion: version
        };
        this.#registries.push(result);
        return result;
    }
    _cacheBlockRegistryProgress(key, creator) {
        // look for waiting resolves
        let waiting = this.#waitingRegistries[key];
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$undefined$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isUndefined"])(waiting)) {
            // nothing waiting, construct new
            waiting = this.#waitingRegistries[key] = new Promise((resolve, reject)=>{
                creator().then((registry)=>{
                    delete this.#waitingRegistries[key];
                    resolve(registry);
                }).catch((error)=>{
                    delete this.#waitingRegistries[key];
                    reject(error);
                });
            });
        }
        return waiting;
    }
    _getBlockRegistryViaVersion(blockHash, version) {
        if (version) {
            // check for pre-existing registries. We also check specName, e.g. it
            // could be changed like in Westmint with upgrade from shell -> westmint
            const existingViaVersion = this.#registries.find(({ runtimeVersion: { specName, specVersion } })=>specName.eq(version.specName) && specVersion.eq(version.specVersion));
            if (existingViaVersion) {
                existingViaVersion.counter++;
                existingViaVersion.lastBlockHash = blockHash;
                return existingViaVersion;
            }
        }
        return null;
    }
    async _getBlockRegistryViaHash(blockHash) {
        // ensure we have everything required
        if (!this._genesisHash || !this._runtimeVersion) {
            throw new Error('Cannot retrieve data on an uninitialized chain');
        }
        // We have to assume that on the RPC layer the calls used here does not call back into
        // the registry swap, so getHeader & getRuntimeVersion should not be historic
        const header = this.registry.createType('HeaderPartial', this._genesisHash.eq(blockHash) ? {
            number: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$bn$2f$consts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["BN_ZERO"],
            parentHash: this._genesisHash
        } : await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["firstValueFrom"])(this._rpcCore.chain.getHeader.raw(blockHash)));
        if (header.parentHash.isEmpty) {
            l.warn(`Unable to retrieve header ${blockHash.toString()} and parent ${header.parentHash.toString()} from supplied hash`);
            throw new Error('Unable to retrieve header and parent from supplied hash');
        }
        // get the runtime version, either on-chain or via an known upgrade history
        const [firstVersion, lastVersion] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2d$known$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getUpgradeVersion"])(this._genesisHash, header.number);
        const version = this.registry.createType('RuntimeVersionPartial', WITH_VERSION_SHORTCUT && firstVersion && (lastVersion || firstVersion.specVersion.eq(this._runtimeVersion.specVersion)) ? "TURBOPACK unreachable" : await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["firstValueFrom"])(this._rpcCore.state.getRuntimeVersion.raw(header.parentHash)));
        return(// try to find via version
        this._getBlockRegistryViaVersion(blockHash, version) || // return new or in-flight result
        await this._cacheBlockRegistryProgress(version.toHex(), ()=>this._createBlockRegistry(blockHash, header, version)));
    }
    /**
     * @description Sets up a registry based on the block hash defined
     */ async getBlockRegistry(blockHash, knownVersion) {
        return(// try to find via blockHash
        this.#registries.find(({ lastBlockHash })=>lastBlockHash && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$u8a$2f$eq$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u8aEq"])(lastBlockHash, blockHash)) || // try to find via version
        this._getBlockRegistryViaVersion(blockHash, knownVersion) || // return new or in-flight result
        await this._cacheBlockRegistryProgress((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$u8a$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u8aToHex"])(blockHash), ()=>this._getBlockRegistryViaHash(blockHash)));
    }
    async _loadMeta() {
        // on re-connection to the same chain, we don't want to re-do everything from chain again
        if (this._isReady) {
            // on re-connection only re-subscribe to chain updates if we are not a clone
            if (!this._options.source) {
                this._subscribeUpdates();
            }
            return true;
        }
        this._unsubscribeUpdates();
        // only load from on-chain if we are not a clone (default path), alternatively
        // just use the values from the source instance provided
        [this._genesisHash, this._runtimeMetadata] = this._options.source?._isReady ? await this._metaFromSource(this._options.source) : await this._metaFromChain(this._options.metadata);
        return this._initFromMeta(this._runtimeMetadata);
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async _metaFromSource(source) {
        this._extrinsicType = source.extrinsicVersion;
        this._runtimeChain = source.runtimeChain;
        this._runtimeVersion = source.runtimeVersion;
        // manually build a list of all available methods in this RPC, we are
        // going to filter on it to align the cloned RPC without making a call
        const sections = Object.keys(source.rpc);
        const rpcs = [];
        for(let s = 0, scount = sections.length; s < scount; s++){
            const section = sections[s];
            const methods = Object.keys(source.rpc[section]);
            for(let m = 0, mcount = methods.length; m < mcount; m++){
                rpcs.push(`${section}_${methods[m]}`);
            }
        }
        this._filterRpc(rpcs, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2d$known$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getSpecRpc"])(this.registry, source.runtimeChain, source.runtimeVersion.specName));
        return [
            source.genesisHash,
            source.runtimeMetadata
        ];
    }
    // subscribe to metadata updates, inject the types on changes
    _subscribeUpdates() {
        if (this.#updateSub || !this.hasSubscriptions) {
            return;
        }
        this.#updateSub = this._rpcCore.state.subscribeRuntimeVersion().pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["switchMap"])((version)=>// only retrieve the metadata when the on-chain version has been changed
            this._runtimeVersion?.specVersion.eq(version.specVersion) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["of"])(false) : this._rpcCore.state.getMetadata().pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["map"])((metadata)=>{
                l.log(`Runtime version updated to spec=${version.specVersion.toString()}, tx=${version.transactionVersion.toString()}`);
                this._runtimeMetadata = metadata;
                this._runtimeVersion = version;
                this._rx.runtimeVersion = version;
                // update the default registry version
                const thisRegistry = this._getDefaultRegistry();
                const runtimeChain = this._runtimeChain;
                if (!runtimeChain) {
                    throw new Error('Invalid initializion order, runtimeChain is not available');
                }
                // setup the data as per the current versions
                thisRegistry.metadata = metadata;
                thisRegistry.runtimeVersion = version;
                this._initRegistry(this.registry, runtimeChain, version, metadata);
                this._injectMetadata(thisRegistry, true);
                return true;
            })))).subscribe();
    }
    async _metaFromChain(optMetadata) {
        const [genesisHash, runtimeVersion, chain, chainProps, rpcMethods] = await Promise.all([
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["firstValueFrom"])(this._rpcCore.chain.getBlockHash(0)),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["firstValueFrom"])(this._rpcCore.state.getRuntimeVersion()),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["firstValueFrom"])(this._rpcCore.system.chain()),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["firstValueFrom"])(this._rpcCore.system.properties()),
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["firstValueFrom"])(this._rpcCore.rpc.methods())
        ]);
        // set our chain version & genesisHash as returned
        this._runtimeChain = chain;
        this._runtimeVersion = runtimeVersion;
        this._rx.runtimeVersion = runtimeVersion;
        // retrieve metadata, either from chain  or as pass-in via options
        const metadataKey = `${genesisHash.toHex() || '0x'}-${runtimeVersion.specVersion.toString()}`;
        const metadata = optMetadata?.[metadataKey] ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2f$metadata$2f$Metadata$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Metadata"](this.registry, optMetadata[metadataKey]) : await this._retrieveMetadata(runtimeVersion.apis);
        // initializes the registry & RPC
        this._initRegistry(this.registry, chain, runtimeVersion, metadata, chainProps);
        this._filterRpc(rpcMethods.methods.map(textToString), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2d$known$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getSpecRpc"])(this.registry, chain, runtimeVersion.specName));
        this._subscribeUpdates();
        // setup the initial registry, when we have none
        if (!this.#registries.length) {
            this.#registries.push({
                counter: 0,
                isDefault: true,
                metadata,
                registry: this.registry,
                runtimeVersion
            });
        }
        // get unique types & validate
        metadata.getUniqTypes(this._options.throwOnUnknown || false);
        return [
            genesisHash,
            metadata
        ];
    }
    _initFromMeta(metadata) {
        const runtimeVersion = this._runtimeVersion;
        if (!runtimeVersion) {
            throw new Error('Invalid initializion order, runtimeVersion is not available');
        }
        // ExtrinsicV5 is not fully supported yet, for that reason we default to version 4
        this._extrinsicType = metadata.asLatest.extrinsic.versions.at(0) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2f$extrinsic$2f$constants$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LATEST_EXTRINSIC_VERSION"];
        this._rx.extrinsicType = this._extrinsicType;
        this._rx.genesisHash = this._genesisHash;
        this._rx.runtimeVersion = runtimeVersion;
        // inject metadata and adjust the types as detected
        this._injectMetadata(this._getDefaultRegistry(), true);
        // derive is last, since it uses the decorated rx
        this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);
        this._derive = this._decorateDerive(this._decorateMethod);
        return true;
    }
    /**
     * @internal
     *
     * Tries to use runtime api calls to retrieve metadata. This ensures the api initializes with the latest metadata.
     * If the runtime call is not there it will use the rpc method.
     */ async _retrieveMetadata(apis, at, registry) {
        let metadataVersion = null;
        const metadataApi = apis.find(([a])=>a.eq((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2d$crypto$2f$blake2$2f$asU8a$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["blake2AsHex"])('Metadata', 64)));
        const typeRegistry = registry || this.registry;
        // This chain does not have support for the metadataApi, or does not have the required version.
        if (!metadataApi || metadataApi[1].toNumber() < 2) {
            l.warn('MetadataApi not available, rpc::state::get_metadata will be used.');
            return at ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2f$metadata$2f$Metadata$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Metadata"](typeRegistry, await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["firstValueFrom"])(this._rpcCore.state.getMetadata.raw(at))) : await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["firstValueFrom"])(this._rpcCore.state.getMetadata());
        }
        try {
            const metadataVersionsAsBytes = at ? await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["firstValueFrom"])(this._rpcCore.state.call.raw('Metadata_metadata_versions', '0x', at)) : await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["firstValueFrom"])(this._rpcCore.state.call('Metadata_metadata_versions', '0x'));
            const versions = typeRegistry.createType('Vec<u32>', metadataVersionsAsBytes);
            // For unstable versions of the metadata the last value is set to u32 MAX in the runtime. This ensures only supported stable versions are used.
            metadataVersion = versions.filter((ver)=>SUPPORTED_METADATA_VERSIONS.includes(ver.toNumber())).reduce((largest, current)=>current.gt(largest) ? current : largest);
        } catch (e) {
            l.debug(e.message);
            l.warn('error with state_call::Metadata_metadata_versions, rpc::state::get_metadata will be used');
        }
        // When the metadata version does not align with the latest supported versions we ensure not to call the metadata runtime call.
        // I noticed on some previous runtimes that have support for `Metadata_metadata_at_version` that very irregular versions were being returned.
        // This was evident with runtime 1000000 - it return a very large number. This ensures we always stick within what is supported.
        if (metadataVersion && !SUPPORTED_METADATA_VERSIONS.includes(metadataVersion.toNumber())) {
            metadataVersion = null;
        }
        if (metadataVersion) {
            try {
                const metadataBytes = at ? await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["firstValueFrom"])(this._rpcCore.state.call.raw('Metadata_metadata_at_version', (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$u8a$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u8aToHex"])(metadataVersion.toU8a()), at)) : await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["firstValueFrom"])(this._rpcCore.state.call('Metadata_metadata_at_version', (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$u8a$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u8aToHex"])(metadataVersion.toU8a())));
                // When the metadata is called with `at` it is required to use `.raw`. Therefore since the length prefix is not present the
                // need to create a `Raw` type is necessary before creating the `OpaqueMetadata` type or else there will be a magic number
                // mismatch
                const rawMeta = at ? typeRegistry.createType('Raw', metadataBytes).toU8a() : metadataBytes;
                const opaqueMetadata = typeRegistry.createType('Option<OpaqueMetadata>', rawMeta).unwrapOr(null);
                if (opaqueMetadata) {
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2f$metadata$2f$Metadata$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Metadata"](typeRegistry, opaqueMetadata.toHex());
                }
            } catch (e) {
                l.debug(e.message);
                l.warn('error with state_call::Metadata_metadata_at_version, rpc::state::get_metadata will be used');
            }
        }
        return at ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$types$2f$metadata$2f$Metadata$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Metadata"](typeRegistry, await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["firstValueFrom"])(this._rpcCore.state.getMetadata.raw(at))) : await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["firstValueFrom"])(this._rpcCore.state.getMetadata());
    }
    _subscribeHealth() {
        this._unsubscribeHealth();
        // Only enable the health keepalive on WS, not needed on HTTP
        this.#healthTimer = this.hasSubscriptions ? setInterval(()=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["firstValueFrom"])(this._rpcCore.system.health.raw()).catch(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$noop$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["noop"]);
        }, KEEPALIVE_INTERVAL) : null;
    }
    _unsubscribeHealth() {
        if (this.#healthTimer) {
            clearInterval(this.#healthTimer);
            this.#healthTimer = null;
        }
    }
    _unsubscribeUpdates() {
        if (this.#updateSub) {
            this.#updateSub.unsubscribe();
            this.#updateSub = null;
        }
    }
    _unsubscribe() {
        this._unsubscribeHealth();
        this._unsubscribeUpdates();
    }
    async #onProviderConnect() {
        this._isConnected.next(true);
        this.emit('connected');
        try {
            const cryptoReady = this._options.initWasm === false ? true : await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2d$crypto$2f$crypto$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cryptoWaitReady"])();
            const hasMeta = await this._loadMeta();
            this._subscribeHealth();
            if (hasMeta && !this._isReady && cryptoReady) {
                this._isReady = true;
                this.emit('ready', this);
            }
        } catch (_error) {
            const error = new Error(`FATAL: Unable to initialize the API: ${_error.message}`);
            l.error(error);
            this.emit('error', error);
        }
    }
    #onProviderDisconnect() {
        this._isConnected.next(false);
        this._unsubscribe();
        this.emit('disconnected');
    }
    #onProviderError(error) {
        this.emit('error', error);
    }
}
}),
"[project]/node_modules/@polkadot/api/base/Getters.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Getters",
    ()=>Getters
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$packageInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/packageInfo.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$base$2f$find$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/base/find.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$base$2f$Init$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/base/Init.js [app-ssr] (ecmascript)");
;
;
;
function assertResult(value) {
    if (value === undefined) {
        throw new Error("Api interfaces needs to be initialized before using, wait for 'isReady'");
    }
    return value;
}
class Getters extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$base$2f$Init$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Init"] {
    /**
     * @description Runtime call interfaces (currently untyped, only decorated via API options)
     */ get call() {
        return assertResult(this._call);
    }
    /**
     * @description Contains the parameter types (constants) of all modules.
     *
     * The values are instances of the appropriate type and are accessible using `section`.`constantName`,
     *
     * @example
     * <BR>
     *
     * ```javascript
     * console.log(api.consts.democracy.enactmentPeriod.toString())
     * ```
     */ get consts() {
        return assertResult(this._consts);
    }
    /**
     * @description Derived results that are injected into the API, allowing for combinations of various query results.
     *
     * @example
     * <BR>
     *
     * ```javascript
     * api.derive.chain.bestNumber((number) => {
     *   console.log('best number', number);
     * });
     * ```
     */ get derive() {
        return assertResult(this._derive);
    }
    /**
     * @description Errors from metadata
     */ get errors() {
        return assertResult(this._errors);
    }
    /**
     * @description Events from metadata
     */ get events() {
        return assertResult(this._events);
    }
    /**
     * @description  Returns the version of extrinsics in-use on this chain
     */ get extrinsicVersion() {
        return this._extrinsicType;
    }
    /**
     * @description Contains the genesis Hash of the attached chain. Apart from being useful to determine the actual chain, it can also be used to sign immortal transactions.
     */ get genesisHash() {
        return assertResult(this._genesisHash);
    }
    /**
     * @description true is the underlying provider is connected
     */ get isConnected() {
        return this._isConnected.getValue();
    }
    /**
     * @description The library information name & version (from package.json)
     */ get libraryInfo() {
        return `${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$packageInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["packageInfo"].name} v${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$packageInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["packageInfo"].version}`;
    }
    /**
     * @description Contains all the chain state modules and their subsequent methods in the API. These are attached dynamically from the runtime metadata.
     *
     * All calls inside the namespace, is denoted by `section`.`method` and may take an optional query parameter. As an example, `api.query.timestamp.now()` (current block timestamp) does not take parameters, while `api.query.system.account(<accountId>)` (retrieving the associated nonce & balances for an account), takes the `AccountId` as a parameter.
     *
     * @example
     * <BR>
     *
     * ```javascript
     * api.query.system.account(<accountId>, ([nonce, balance]) => {
     *   console.log('new free balance', balance.free, 'new nonce', nonce);
     * });
     * ```
     */ get query() {
        return assertResult(this._query);
    }
    /**
     * @description Allows for the querying of multiple storage entries and the combination thereof into a single result. This is a very optimal way to make multiple queries since it only makes a single connection to the node and retrieves the data over one subscription.
     *
     * @example
     * <BR>
     *
     * ```javascript
     * const unsub = await api.queryMulti(
     *   [
     *     // you can include the storage without any parameters
     *     api.query.balances.totalIssuance,
     *     // or you can pass parameters to the storage query
     *     [api.query.system.account, '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY']
     *   ],
     *   ([existential, [, { free }]]) => {
     *     console.log(`You have ${free.sub(existential)} more than the existential deposit`);
     *
     *     unsub();
     *   }
     * );
     * ```
     */ get queryMulti() {
        return assertResult(this._queryMulti);
    }
    /**
     * @description Contains all the raw rpc sections and their subsequent methods in the API as defined by the jsonrpc interface definitions. Unlike the dynamic `api.query` and `api.tx` sections, these methods are fixed (although extensible with node upgrades) and not determined by the runtime.
     *
     * RPC endpoints available here allow for the query of chain, node and system information, in addition to providing interfaces for the raw queries of state (using known keys) and the submission of transactions.
     *
     * @example
     * <BR>
     *
     * ```javascript
     * api.rpc.chain.subscribeNewHeads((header) => {
     *   console.log('new header', header);
     * });
     * ```
     */ get rpc() {
        return assertResult(this._rpc);
    }
    /**
     * @description Contains the chain information for the current node.
     */ get runtimeChain() {
        return assertResult(this._runtimeChain);
    }
    /**
     * @description Yields the current attached runtime metadata. Generally this is only used to construct extrinsics & storage, but is useful for current runtime inspection.
     */ get runtimeMetadata() {
        return assertResult(this._runtimeMetadata);
    }
    /**
     * @description Contains the version information for the current runtime.
     */ get runtimeVersion() {
        return assertResult(this._runtimeVersion);
    }
    /**
     * @description The underlying Rx API interface
     */ get rx() {
        return assertResult(this._rx);
    }
    /**
     * @description Returns the underlying provider stats
     */ get stats() {
        return this._rpcCore.stats;
    }
    /**
     * @description The type of this API instance, either 'rxjs' or 'promise'
     */ get type() {
        return this._type;
    }
    /**
     * @description Contains all the extrinsic modules and their subsequent methods in the API. It allows for the construction of transactions and the submission thereof. These are attached dynamically from the runtime metadata.
     *
     * @example
     * <BR>
     *
     * ```javascript
     * api.tx.balances
     *   .transferAllowDeath(<recipientId>, <balance>)
     *   .signAndSend(<keyPair>, ({status}) => {
     *     console.log('tx status', status.asFinalized.toHex());
     *   });
     * ```
     */ get tx() {
        return assertResult(this._extrinsics);
    }
    /**
     * @description Finds the definition for a specific [[CallFunction]] based on the index supplied
     */ findCall(callIndex) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$base$2f$find$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["findCall"])(this.registry, callIndex);
    }
    /**
     * @description Finds the definition for a specific [[RegistryError]] based on the index supplied
     */ findError(errorIndex) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$base$2f$find$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["findError"])(this.registry, errorIndex);
    }
}
}),
"[project]/node_modules/@polkadot/api/base/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ApiBase",
    ()=>ApiBase
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/is/string.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$object$2f$spread$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/object/spread.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$u8a$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/u8a/toHex.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$u8a$2f$toU8a$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/u8a/toU8a.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$base$2f$Getters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/base/Getters.js [app-ssr] (ecmascript)");
;
;
class ApiBase extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$base$2f$Getters$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Getters"] {
    /**
     * @description Create an instance of the class
     *
     * @param options Options object to create API instance or a Provider instance
     *
     * @example
     * <BR>
     *
     * ```javascript
     * import Api from '@polkadot/api/promise';
     *
     * const api = new Api().isReady();
     *
     * api.rpc.subscribeNewHeads((header) => {
     *   console.log(`new block #${header.number.toNumber()}`);
     * });
     * ```
     */ constructor(options = {}, type, decorateMethod){
        super(options, type, decorateMethod);
    }
    /**
     * @description Connect from the underlying provider, halting all network traffic
     */ connect() {
        return this._rpcCore.connect();
    }
    /**
     * @description Disconnect from the underlying provider, halting all network traffic
     */ disconnect() {
        this._unsubscribe();
        return this._rpcCore.disconnect();
    }
    /**
     * @description Set an external signer which will be used to sign extrinsic when account passed in is not KeyringPair
     */ setSigner(signer) {
        this._rx.signer = signer;
    }
    /**
     * @description Signs a raw signer payload, string or Uint8Array
     */ async sign(address, data, { signer } = {}) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$string$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isString"])(address)) {
            const _signer = signer || this._rx.signer;
            if (!_signer?.signRaw) {
                throw new Error('No signer exists with a signRaw interface. You possibly need to pass through an explicit keypair for the origin so it can be used for signing.');
            }
            return (await _signer.signRaw((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$object$2f$spread$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectSpread"])({
                type: 'bytes'
            }, data, {
                address
            }))).signature;
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$u8a$2f$toHex$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u8aToHex"])(address.sign((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$u8a$2f$toU8a$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["u8aToU8a"])(data.data)));
    }
}
}),
"[project]/node_modules/@polkadot/api/promise/Combinator.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Combinator",
    ()=>Combinator
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$function$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/is/function.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$noop$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/noop.js [app-ssr] (ecmascript)");
;
class Combinator {
    #allHasFired = false;
    #callback;
    #fired = [];
    #fns = [];
    #isActive = true;
    #results = [];
    #subscriptions = [];
    constructor(fns, callback){
        this.#callback = callback;
        // eslint-disable-next-line @typescript-eslint/no-floating-promises, @typescript-eslint/require-await
        this.#subscriptions = fns.map(async (input, index)=>{
            const [fn, ...args] = Array.isArray(input) ? input : [
                input
            ];
            this.#fired.push(false);
            this.#fns.push(fn);
            // Not quite 100% how to have a variable number at the front here
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/ban-types
            return fn(...args, this._createCallback(index));
        });
    }
    _allHasFired() {
        this.#allHasFired ||= this.#fired.filter((hasFired)=>!hasFired).length === 0;
        return this.#allHasFired;
    }
    _createCallback(index) {
        return (value)=>{
            this.#fired[index] = true;
            this.#results[index] = value;
            this._triggerUpdate();
        };
    }
    _triggerUpdate() {
        if (!this.#isActive || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$function$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isFunction"])(this.#callback) || !this._allHasFired()) {
            return;
        }
        try {
            Promise.resolve(this.#callback(this.#results)).catch(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$noop$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["noop"]);
        } catch  {
        // swallow, we don't want the handler to trip us up
        }
    }
    unsubscribe() {
        if (!this.#isActive) {
            return;
        }
        this.#isActive = false;
        Promise.all(this.#subscriptions.map(async (subscription)=>{
            try {
                const unsubscribe = await subscription;
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$function$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isFunction"])(unsubscribe)) {
                    unsubscribe();
                }
            } catch  {
            // ignore
            }
        })).catch(()=>{
        // ignore, already ignored above, should never throw
        });
    }
}
}),
"[project]/node_modules/@polkadot/api/promise/decorateMethod.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "promiseTracker",
    ()=>promiseTracker,
    "toPromiseMethod",
    ()=>toPromiseMethod
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/cjs/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$function$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/is/function.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$nextTick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/nextTick.js [app-ssr] (ecmascript)");
;
;
function promiseTracker(resolve, reject) {
    let isCompleted = false;
    return {
        reject: (error)=>{
            if (!isCompleted) {
                isCompleted = true;
                reject(error);
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EMPTY"];
        },
        resolve: (value)=>{
            if (!isCompleted) {
                isCompleted = true;
                resolve(value);
            }
        }
    };
}
function extractArgs(args, needsCallback) {
    const actualArgs = args.slice();
    // If the last arg is a function, we pop it, put it into callback.
    // actualArgs will then hold the actual arguments to be passed to `method`
    const callback = args.length && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$function$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isFunction"])(args[args.length - 1]) ? actualArgs.pop() : undefined;
    // When we need a subscription, ensure that a valid callback is actually passed
    if (needsCallback && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$is$2f$function$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isFunction"])(callback)) {
        throw new Error('Expected a callback to be passed with subscriptions');
    }
    return [
        actualArgs,
        callback
    ];
}
function decorateCall(method, args) {
    return new Promise((resolve, reject)=>{
        // single result tracker - either reject with Error or resolve with Codec result
        const tracker = promiseTracker(resolve, reject);
        // encoding errors reject immediately, any result unsubscribes and resolves
        const subscription = method(...args).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["catchError"])((error)=>tracker.reject(error))).subscribe((result)=>{
            tracker.resolve(result);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$nextTick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nextTick"])(()=>subscription.unsubscribe());
        });
    });
}
function decorateSubscribe(method, args, resultCb) {
    return new Promise((resolve, reject)=>{
        // either reject with error or resolve with unsubscribe callback
        const tracker = promiseTracker(resolve, reject);
        // errors reject immediately, the first result resolves with an unsubscribe promise, all results via callback
        const subscription = method(...args).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["catchError"])((error)=>tracker.reject(error)), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tap"])(()=>tracker.resolve(()=>subscription.unsubscribe()))).subscribe((result)=>{
            // queue result (back of queue to clear current)
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$nextTick$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["nextTick"])(()=>resultCb(result));
        });
    });
}
function toPromiseMethod(method, options) {
    const needsCallback = !!(options?.methodName && options.methodName.includes('subscribe'));
    return function(...args) {
        const [actualArgs, resultCb] = extractArgs(args, needsCallback);
        return resultCb ? decorateSubscribe(method, actualArgs, resultCb) : decorateCall(options?.overrideNoSub || method, actualArgs);
    };
}
}),
"[project]/node_modules/@polkadot/api/promise/Api.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ApiPromise",
    ()=>ApiPromise
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$noop$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/noop.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$object$2f$spread$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/object/spread.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$base$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/base/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$promise$2f$Combinator$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/promise/Combinator.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$promise$2f$decorateMethod$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/promise/decorateMethod.js [app-ssr] (ecmascript)");
;
;
;
;
class ApiPromise extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$base$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ApiBase"] {
    #isReadyPromise;
    #isReadyOrErrorPromise;
    /**
     * @description Creates an instance of the ApiPromise class
     * @param options Options to create an instance. This can be either [[ApiOptions]] or
     * an [[WsProvider]].
     * @example
     * <BR>
     *
     * ```javascript
     * import Api from '@polkadot/api/promise';
     *
     * new Api().isReady.then((api) => {
     *   api.rpc.subscribeNewHeads((header) => {
     *     console.log(`new block #${header.number.toNumber()}`);
     *   });
     * });
     * ```
     */ constructor(options){
        super(options, 'promise', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$promise$2f$decorateMethod$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toPromiseMethod"]);
        this.#isReadyPromise = new Promise((resolve)=>{
            super.once('ready', ()=>resolve(this));
        });
        this.#isReadyOrErrorPromise = new Promise((resolve, reject)=>{
            const tracker = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$promise$2f$decorateMethod$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["promiseTracker"])(resolve, reject);
            super.once('ready', ()=>tracker.resolve(this));
            super.once('error', (error)=>tracker.reject(error));
        });
    }
    /**
     * @description Creates an ApiPromise instance using the supplied provider. Returns an Promise containing the actual Api instance.
     * @param options options that is passed to the class contructor. Can be either [[ApiOptions]] or a
     * provider (see the constructor arguments)
     * @example
     * <BR>
     *
     * ```javascript
     * import Api from '@polkadot/api/promise';
     *
     * Api.create().then(async (api) => {
     *   const timestamp = await api.query.timestamp.now();
     *
     *   console.log(`lastest block timestamp ${timestamp}`);
     * });
     * ```
     */ static create(options) {
        const instance = new ApiPromise(options);
        if (options && options.throwOnConnect) {
            return instance.isReadyOrError;
        }
        // Swallow any rejections on isReadyOrError
        // (in Node 15.x this creates issues, when not being looked at)
        instance.isReadyOrError.catch(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$noop$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["noop"]);
        return instance.isReady;
    }
    /**
     * @description Promise that resolves the first time we are connected and loaded
     */ get isReady() {
        return this.#isReadyPromise;
    }
    /**
     * @description Promise that resolves if we can connect, or reject if there is an error
     */ get isReadyOrError() {
        return this.#isReadyOrErrorPromise;
    }
    /**
     * @description Returns a clone of this ApiPromise instance (new underlying provider connection)
     */ clone() {
        return new ApiPromise((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$object$2f$spread$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectSpread"])({}, this._options, {
            source: this
        }));
    }
    /**
     * @description Creates a combinator that can be used to combine the latest results from multiple subscriptions
     * @param fns An array of function to combine, each in the form of `(cb: (value: void)) => void`
     * @param callback A callback that will return an Array of all the values this combinator has been applied to
     * @example
     * <BR>
     *
     * ```javascript
     * const address = '5DTestUPts3kjeXSTMyerHihn1uwMfLj8vU8sqF7qYrFacT7';
     *
     * // combines values from balance & nonce as it updates
     * api.combineLatest([
     *   api.rpc.chain.subscribeNewHeads,
     *   (cb) => api.query.system.account(address, cb)
     * ], ([head, [balance, nonce]]) => {
     *   console.log(`#${head.number}: You have ${balance.free} units, with ${nonce} transactions sent`);
     * });
     * ```
     */ // eslint-disable-next-line @typescript-eslint/require-await
    async combineLatest(fns, callback) {
        const combinator = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$promise$2f$Combinator$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Combinator"](fns, callback);
        return ()=>{
            combinator.unsubscribe();
        };
    }
}
}),
"[project]/node_modules/@polkadot/api/promise/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ApiPromise",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$promise$2f$Api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ApiPromise"],
    "toPromiseMethod",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$promise$2f$decorateMethod$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toPromiseMethod"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$promise$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/promise/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$promise$2f$Api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/promise/Api.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$promise$2f$decorateMethod$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/promise/decorateMethod.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@polkadot/api/rx/index.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
;
}),
"[project]/node_modules/@polkadot/api/rx/decorateMethod.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "toRxMethod",
    ()=>toRxMethod
]);
function toRxMethod(method) {
    return method;
}
}),
"[project]/node_modules/@polkadot/api/rx/Api.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ApiRx",
    ()=>ApiRx
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rxjs/dist/cjs/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$object$2f$spread$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/util/object/spread.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$base$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/base/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$rx$2f$decorateMethod$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/rx/decorateMethod.js [app-ssr] (ecmascript)");
;
;
;
;
class ApiRx extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$base$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ApiBase"] {
    #isReadyRx;
    /**
     * @description Create an instance of the ApiRx class
     * @param options Options to create an instance. Can be either [[ApiOptions]] or [[WsProvider]]
     * @example
     * <BR>
     *
     * ```javascript
     * import { switchMap } from 'rxjs';
     * import Api from '@polkadot/api/rx';
     *
     * new Api().isReady
     *   .pipe(
     *     switchMap((api) =>
     *       api.rpc.chain.subscribeNewHeads()
     *   ))
     *   .subscribe((header) => {
     *     console.log(`new block #${header.number.toNumber()}`);
     *   });
     * ```
     */ constructor(options){
        super(options, 'rxjs', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$rx$2f$decorateMethod$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRxMethod"]);
        this.#isReadyRx = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rxjs$2f$dist$2f$cjs$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["from"])(// You can create an observable from an event, however my mind groks this form better
        new Promise((resolve)=>{
            super.on('ready', ()=>resolve(this));
        }));
    }
    /**
     * @description Creates an ApiRx instance using the supplied provider. Returns an Observable containing the actual Api instance.
     * @param options options that is passed to the class constructor. Can be either [[ApiOptions]] or [[WsProvider]]
     * @example
     * <BR>
     *
     * ```javascript
     * import { switchMap } from 'rxjs';
     * import Api from '@polkadot/api/rx';
     *
     * Api.create()
     *   .pipe(
     *     switchMap((api) =>
     *       api.rpc.chain.subscribeNewHeads()
     *   ))
     *   .subscribe((header) => {
     *     console.log(`new block #${header.number.toNumber()}`);
     *   });
     * ```
     */ static create(options) {
        return new ApiRx(options).isReady;
    }
    /**
     * @description Observable that returns the first time we are connected and loaded
     */ get isReady() {
        return this.#isReadyRx;
    }
    /**
     * @description Returns a clone of this ApiRx instance (new underlying provider connection)
     */ clone() {
        return new ApiRx((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$util$2f$object$2f$spread$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["objectSpread"])({}, this._options, {
            source: this
        }));
    }
}
}),
"[project]/node_modules/@polkadot/api/rx/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ApiRx",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$rx$2f$Api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ApiRx"],
    "toRxMethod",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$rx$2f$decorateMethod$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRxMethod"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$rx$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/rx/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$rx$2f$Api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/rx/Api.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$rx$2f$decorateMethod$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/rx/decorateMethod.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@polkadot/api/bundle.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ApiPromise",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$promise$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ApiPromise"],
    "ApiRx",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$rx$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ApiRx"],
    "HttpProvider",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$rpc$2d$provider$2f$http$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HttpProvider"],
    "Keyring",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$keyring$2f$keyring$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Keyring"],
    "ScProvider",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$rpc$2d$provider$2f$substrate$2d$connect$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ScProvider"],
    "SubmittableResult",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$submittable$2f$Result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SubmittableResult"],
    "WsProvider",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$rpc$2d$provider$2f$ws$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WsProvider"],
    "packageInfo",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$packageInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["packageInfo"],
    "toPromiseMethod",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$promise$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toPromiseMethod"],
    "toRxMethod",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$rx$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRxMethod"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$bundle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/bundle.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$keyring$2f$keyring$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/keyring/keyring.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$rpc$2d$provider$2f$http$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/rpc-provider/http/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$rpc$2d$provider$2f$substrate$2d$connect$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/rpc-provider/substrate-connect/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$rpc$2d$provider$2f$ws$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/rpc-provider/ws/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$packageInfo$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/packageInfo.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$submittable$2f$Result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/submittable/Result.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$promise$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/promise/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$rx$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/rx/index.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@polkadot/api/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ApiPromise",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$bundle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ApiPromise"],
    "ApiRx",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$bundle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ApiRx"],
    "HttpProvider",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$bundle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HttpProvider"],
    "Keyring",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$bundle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Keyring"],
    "ScProvider",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$bundle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ScProvider"],
    "SubmittableResult",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$bundle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["SubmittableResult"],
    "WsProvider",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$bundle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["WsProvider"],
    "packageInfo",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$bundle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["packageInfo"],
    "toPromiseMethod",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$bundle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toPromiseMethod"],
    "toRxMethod",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$bundle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toRxMethod"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$polkadot$2f$api$2f$bundle$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@polkadot/api/bundle.js [app-ssr] (ecmascript)");
}),
];

//# sourceMappingURL=node_modules_%40polkadot_api_5f223156._.js.map