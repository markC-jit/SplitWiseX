{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/api/packageInfo.js"],"sourcesContent":["export const packageInfo = { name: '@polkadot/api', path: (import.meta && import.meta.url) ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf('/') + 1) : 'auto', type: 'esm', version: '16.4.8' };\n"],"names":[],"mappings":";;;;;;;;;AAAO,MAAM,cAAc;IAAE,MAAM;IAAiB,MAAM,AAAC,iCAAe,8BAAY,GAAG,GAAI,IAAI,IAAI,8BAAY,GAAG,EAAE,QAAQ,CAAC,SAAS,CAAC,GAAG,IAAI,IAAI,8BAAY,GAAG,EAAE,QAAQ,CAAC,WAAW,CAAC,OAAO,KAAK;IAAQ,MAAM;IAAO,SAAS;AAAS","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/api/packageDetect.js"],"sourcesContent":["import { packageInfo as deriveInfo } from '@polkadot/api-derive/packageInfo';\nimport { packageInfo as coreInfo } from '@polkadot/rpc-core/packageInfo';\nimport { packageInfo as providerInfo } from '@polkadot/rpc-provider/packageInfo';\nimport { packageInfo as typesInfo } from '@polkadot/types/packageInfo';\nimport { packageInfo as knownInfo } from '@polkadot/types-known/packageInfo';\nimport { detectPackage } from '@polkadot/util';\nimport { packageInfo } from './packageInfo.js';\ndetectPackage(packageInfo, null, [coreInfo, deriveInfo, knownInfo, providerInfo, typesInfo]);\n"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AACA,IAAA,oKAAa,EAAC,+JAAW,EAAE,MAAM;IAAC,uKAAQ;IAAE,yKAAU;IAAE,0KAAS;IAAE,2KAAY;IAAE,iKAAS;CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 49, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/api/index.js"],"sourcesContent":["import './packageDetect.js';\nexport * from './bundle.js';\n"],"names":[],"mappings":";AAAA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 57, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 69, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/api/submittable/Result.js"],"sourcesContent":["const recordIdentity = (record) => record;\nfunction filterAndApply(events, section, methods, onFound) {\n    return events\n        .filter(({ event }) => section === event.section &&\n        methods.includes(event.method))\n        .map((record) => onFound(record));\n}\nfunction getDispatchError({ event: { data: [dispatchError] } }) {\n    return dispatchError;\n}\nfunction getDispatchInfo({ event: { data, method } }) {\n    return method === 'ExtrinsicSuccess'\n        ? data[0]\n        : data[1];\n}\nfunction extractError(events = []) {\n    return filterAndApply(events, 'system', ['ExtrinsicFailed'], getDispatchError)[0];\n}\nfunction extractInfo(events = []) {\n    return filterAndApply(events, 'system', ['ExtrinsicFailed', 'ExtrinsicSuccess'], getDispatchInfo)[0];\n}\nexport class SubmittableResult {\n    dispatchError;\n    dispatchInfo;\n    internalError;\n    events;\n    status;\n    txHash;\n    txIndex;\n    blockNumber;\n    constructor({ blockNumber, dispatchError, dispatchInfo, events, internalError, status, txHash, txIndex }) {\n        this.dispatchError = dispatchError || extractError(events);\n        this.dispatchInfo = dispatchInfo || extractInfo(events);\n        this.events = events || [];\n        this.internalError = internalError;\n        this.status = status;\n        this.txHash = txHash;\n        this.txIndex = txIndex;\n        this.blockNumber = blockNumber;\n    }\n    get isCompleted() {\n        return this.isError || this.status.isInBlock || this.status.isFinalized;\n    }\n    get isError() {\n        return this.status.isDropped || this.status.isFinalityTimeout || this.status.isInvalid || this.status.isUsurped;\n    }\n    get isFinalized() {\n        return this.status.isFinalized;\n    }\n    get isInBlock() {\n        return this.status.isInBlock;\n    }\n    get isWarning() {\n        return this.status.isRetracted;\n    }\n    /**\n     * @description Filters EventRecords for the specified method & section (there could be multiple)\n     */\n    filterRecords(section, method) {\n        return filterAndApply(this.events, section, Array.isArray(method) ? method : [method], recordIdentity);\n    }\n    /**\n     * @description Finds an EventRecord for the specified method & section\n     */\n    findRecord(section, method) {\n        return this.filterRecords(section, method)[0];\n    }\n    /**\n     * @description Creates a human representation of the output\n     */\n    toHuman(isExtended) {\n        return {\n            dispatchError: this.dispatchError?.toHuman(),\n            dispatchInfo: this.dispatchInfo?.toHuman(),\n            events: this.events.map((e) => e.toHuman(isExtended)),\n            internalError: this.internalError?.message.toString(),\n            status: this.status.toHuman(isExtended)\n        };\n    }\n}\n"],"names":[],"mappings":";;;;AAAA,MAAM,iBAAiB,CAAC,SAAW;AACnC,SAAS,eAAe,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO;IACrD,OAAO,OACF,MAAM,CAAC,CAAC,EAAE,KAAK,EAAE,GAAK,YAAY,MAAM,OAAO,IAChD,QAAQ,QAAQ,CAAC,MAAM,MAAM,GAC5B,GAAG,CAAC,CAAC,SAAW,QAAQ;AACjC;AACA,SAAS,iBAAiB,EAAE,OAAO,EAAE,MAAM,CAAC,cAAc,EAAE,EAAE;IAC1D,OAAO;AACX;AACA,SAAS,gBAAgB,EAAE,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,EAAE;IAChD,OAAO,WAAW,qBACZ,IAAI,CAAC,EAAE,GACP,IAAI,CAAC,EAAE;AACjB;AACA,SAAS,aAAa,SAAS,EAAE;IAC7B,OAAO,eAAe,QAAQ,UAAU;QAAC;KAAkB,EAAE,iBAAiB,CAAC,EAAE;AACrF;AACA,SAAS,YAAY,SAAS,EAAE;IAC5B,OAAO,eAAe,QAAQ,UAAU;QAAC;QAAmB;KAAmB,EAAE,gBAAgB,CAAC,EAAE;AACxG;AACO,MAAM;IACT,cAAc;IACd,aAAa;IACb,cAAc;IACd,OAAO;IACP,OAAO;IACP,OAAO;IACP,QAAQ;IACR,YAAY;IACZ,YAAY,EAAE,WAAW,EAAE,aAAa,EAAE,YAAY,EAAE,MAAM,EAAE,aAAa,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,CAAE;QACtG,IAAI,CAAC,aAAa,GAAG,iBAAiB,aAAa;QACnD,IAAI,CAAC,YAAY,GAAG,gBAAgB,YAAY;QAChD,IAAI,CAAC,MAAM,GAAG,UAAU,EAAE;QAC1B,IAAI,CAAC,aAAa,GAAG;QACrB,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,WAAW,GAAG;IACvB;IACA,IAAI,cAAc;QACd,OAAO,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,MAAM,CAAC,SAAS,IAAI,IAAI,CAAC,MAAM,CAAC,WAAW;IAC3E;IACA,IAAI,UAAU;QACV,OAAO,IAAI,CAAC,MAAM,CAAC,SAAS,IAAI,IAAI,CAAC,MAAM,CAAC,iBAAiB,IAAI,IAAI,CAAC,MAAM,CAAC,SAAS,IAAI,IAAI,CAAC,MAAM,CAAC,SAAS;IACnH;IACA,IAAI,cAAc;QACd,OAAO,IAAI,CAAC,MAAM,CAAC,WAAW;IAClC;IACA,IAAI,YAAY;QACZ,OAAO,IAAI,CAAC,MAAM,CAAC,SAAS;IAChC;IACA,IAAI,YAAY;QACZ,OAAO,IAAI,CAAC,MAAM,CAAC,WAAW;IAClC;IACA;;KAEC,GACD,cAAc,OAAO,EAAE,MAAM,EAAE;QAC3B,OAAO,eAAe,IAAI,CAAC,MAAM,EAAE,SAAS,MAAM,OAAO,CAAC,UAAU,SAAS;YAAC;SAAO,EAAE;IAC3F;IACA;;KAEC,GACD,WAAW,OAAO,EAAE,MAAM,EAAE;QACxB,OAAO,IAAI,CAAC,aAAa,CAAC,SAAS,OAAO,CAAC,EAAE;IACjD;IACA;;KAEC,GACD,QAAQ,UAAU,EAAE;QAChB,OAAO;YACH,eAAe,IAAI,CAAC,aAAa,EAAE;YACnC,cAAc,IAAI,CAAC,YAAY,EAAE;YACjC,QAAQ,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAM,EAAE,OAAO,CAAC;YACzC,eAAe,IAAI,CAAC,aAAa,EAAE,QAAQ;YAC3C,QAAQ,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC;QAChC;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 156, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 163, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/api/base/find.js"],"sourcesContent":["import { u8aToU8a } from '@polkadot/util';\nexport function findCall(registry, callIndex) {\n    return registry.findMetaCall(u8aToU8a(callIndex));\n}\nexport function findError(registry, errorIndex) {\n    return registry.findMetaError(u8aToU8a(errorIndex));\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AACO,SAAS,SAAS,QAAQ,EAAE,SAAS;IACxC,OAAO,SAAS,YAAY,CAAC,IAAA,8JAAQ,EAAC;AAC1C;AACO,SAAS,UAAU,QAAQ,EAAE,UAAU;IAC1C,OAAO,SAAS,aAAa,CAAC,IAAA,8JAAQ,EAAC;AAC3C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 181, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/api/util/logging.js"],"sourcesContent":["import { logger } from '@polkadot/util';\nexport const l = /*#__PURE__*/ logger('api/util');\n"],"names":[],"mappings":";;;;AAAA;;AACO,MAAM,IAAI,WAAW,GAAG,IAAA,sJAAM,EAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 192, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/api/util/filterEvents.js"],"sourcesContent":["import { isCompact } from '@polkadot/util';\nimport { l } from './logging.js';\nexport function filterEvents(txHash, { block: { extrinsics, header } }, allEvents, status) {\n    // extrinsics to hashes\n    for (const [txIndex, x] of extrinsics.entries()) {\n        if (x.hash.eq(txHash)) {\n            return {\n                blockNumber: isCompact(header.number) ? header.number.unwrap() : header.number,\n                events: allEvents.filter(({ phase }) => phase.isApplyExtrinsic &&\n                    phase.asApplyExtrinsic.eqn(txIndex)),\n                txIndex\n            };\n        }\n    }\n    // if we do get the block after finalized, it _should_ be there\n    // only warn on filtering with isInBlock (finalization finalizes after)\n    if (status.isInBlock) {\n        const allHashes = extrinsics.map((x) => x.hash.toHex());\n        l.warn(`block ${header.hash.toHex()}: Unable to find extrinsic ${txHash.toHex()} inside ${allHashes.join(', ')}`);\n    }\n    return {};\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AACO,SAAS,aAAa,MAAM,EAAE,EAAE,OAAO,EAAE,UAAU,EAAE,MAAM,EAAE,EAAE,EAAE,SAAS,EAAE,MAAM;IACrF,uBAAuB;IACvB,KAAK,MAAM,CAAC,SAAS,EAAE,IAAI,WAAW,OAAO,GAAI;QAC7C,IAAI,EAAE,IAAI,CAAC,EAAE,CAAC,SAAS;YACnB,OAAO;gBACH,aAAa,IAAA,gKAAS,EAAC,OAAO,MAAM,IAAI,OAAO,MAAM,CAAC,MAAM,KAAK,OAAO,MAAM;gBAC9E,QAAQ,UAAU,MAAM,CAAC,CAAC,EAAE,KAAK,EAAE,GAAK,MAAM,gBAAgB,IAC1D,MAAM,gBAAgB,CAAC,GAAG,CAAC;gBAC/B;YACJ;QACJ;IACJ;IACA,+DAA+D;IAC/D,uEAAuE;IACvE,IAAI,OAAO,SAAS,EAAE;QAClB,MAAM,YAAY,WAAW,GAAG,CAAC,CAAC,IAAM,EAAE,IAAI,CAAC,KAAK;QACpD,yJAAC,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,OAAO,IAAI,CAAC,KAAK,GAAG,2BAA2B,EAAE,OAAO,KAAK,GAAG,QAAQ,EAAE,UAAU,IAAI,CAAC,OAAO;IACpH;IACA,OAAO,CAAC;AACZ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 223, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/api/util/isKeyringPair.js"],"sourcesContent":["import { isFunction } from '@polkadot/util';\nexport function isKeyringPair(account) {\n    return isFunction(account.sign);\n}\n"],"names":[],"mappings":";;;;AAAA;;AACO,SAAS,cAAc,OAAO;IACjC,OAAO,IAAA,kKAAU,EAAC,QAAQ,IAAI;AAClC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 236, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/api/submittable/createClass.js"],"sourcesContent":["import { catchError, first, map, mergeMap, of, switchMap, tap } from 'rxjs';\nimport { identity, isBn, isFunction, isNumber, isString, isU8a, objectSpread } from '@polkadot/util';\nimport { filterEvents, isKeyringPair } from '../util/index.js';\nimport { SubmittableResult } from './Result.js';\nfunction makeEraOptions(api, registry, partialOptions, { header, mortalLength, nonce }) {\n    if (!header) {\n        if (partialOptions.era && !partialOptions.blockHash) {\n            throw new Error('Expected blockHash to be passed alongside non-immortal era options');\n        }\n        if (isNumber(partialOptions.era)) {\n            // since we have no header, it is immortal, remove any option overrides\n            // so we only supply the genesisHash and no era to the construction\n            delete partialOptions.era;\n            delete partialOptions.blockHash;\n        }\n        return makeSignOptions(api, partialOptions, { nonce });\n    }\n    return makeSignOptions(api, partialOptions, {\n        blockHash: header.hash,\n        era: registry.createTypeUnsafe('ExtrinsicEra', [{\n                current: header.number,\n                period: partialOptions.era || mortalLength\n            }]),\n        nonce\n    });\n}\nfunction makeSignAndSendOptions(partialOptions, statusCb) {\n    let options = {};\n    if (isFunction(partialOptions)) {\n        statusCb = partialOptions;\n    }\n    else {\n        options = objectSpread({}, partialOptions);\n    }\n    return [options, statusCb];\n}\nfunction makeSignOptions(api, partialOptions, extras) {\n    return objectSpread({ blockHash: api.genesisHash, genesisHash: api.genesisHash }, partialOptions, extras, { runtimeVersion: api.runtimeVersion, signedExtensions: api.registry.signedExtensions, version: api.extrinsicType });\n}\nfunction optionsOrNonce(partialOptions = {}) {\n    return isBn(partialOptions) || isNumber(partialOptions)\n        ? { nonce: partialOptions }\n        : partialOptions;\n}\nexport function createClass({ api, apiType, blockHash, decorateMethod }) {\n    // an instance of the base extrinsic for us to extend\n    const ExtrinsicBase = api.registry.createClass('Extrinsic');\n    const extrinsicInfoMap = new WeakMap();\n    class Submittable extends ExtrinsicBase {\n        #ignoreStatusCb;\n        #transformResult = (identity);\n        constructor(registry, extrinsic) {\n            super(registry, extrinsic, { version: api.extrinsicType });\n            this.#ignoreStatusCb = apiType === 'rxjs';\n        }\n        get hasDryRun() {\n            return isFunction(api.rpc.system?.dryRun);\n        }\n        get hasPaymentInfo() {\n            return isFunction(api.call.transactionPaymentApi?.queryInfo);\n        }\n        // dry run an extrinsic\n        dryRun(account, optionsOrHash) {\n            if (!this.hasDryRun) {\n                throw new Error('The system.dryRun RPC call is not available in your environment');\n            }\n            if (blockHash || isString(optionsOrHash) || isU8a(optionsOrHash)) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return decorateMethod(() => api.rpc.system.dryRun(this.toHex(), blockHash || optionsOrHash));\n            }\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call\n            return decorateMethod(() => this.#observeSign(account, optionsOrHash).pipe(switchMap(() => api.rpc.system.dryRun(this.toHex()))))();\n        }\n        // calculate the payment info for this transaction (if signed and submitted)\n        paymentInfo(account, optionsOrHash) {\n            if (!this.hasPaymentInfo) {\n                throw new Error('The transactionPaymentApi.queryInfo runtime call is not available in your environment');\n            }\n            if (blockHash || isString(optionsOrHash) || isU8a(optionsOrHash)) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return decorateMethod(() => api.callAt(blockHash || optionsOrHash).pipe(switchMap((callAt) => {\n                    const u8a = this.toU8a();\n                    return callAt.transactionPaymentApi.queryInfo(u8a, u8a.length);\n                })));\n            }\n            const [allOptions] = makeSignAndSendOptions(optionsOrHash);\n            const address = isKeyringPair(account) ? account.address : account.toString();\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call\n            return decorateMethod(() => api.derive.tx.signingInfo(address, allOptions.nonce, allOptions.era).pipe(first(), switchMap((signingInfo) => {\n                // setup our options (same way as in signAndSend)\n                const eraOptions = makeEraOptions(api, this.registry, allOptions, signingInfo);\n                const signOptions = makeSignOptions(api, eraOptions, {});\n                // 1. Don't use the internal objects inside the new tx (hence toU8a)\n                // 2. Don't override the data from existing signed extrinsics\n                // 3. Ensure that this object stays intact, with no new sign after operation\n                const u8a = api.tx(this.toU8a()).signFake(address, signOptions).toU8a();\n                return api.call.transactionPaymentApi.queryInfo(u8a, u8a.length);\n            })))();\n        }\n        // send implementation for both immediate Hash and statusCb variants\n        send(statusCb) {\n            const isSubscription = api.hasSubscriptions && (this.#ignoreStatusCb || !!statusCb);\n            const updatedInfo = extrinsicInfoMap.get(this);\n            extrinsicInfoMap.delete(this);\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call\n            return decorateMethod(isSubscription\n                ? () => this.#observeSubscribe(updatedInfo)\n                : () => this.#observeSend(updatedInfo))(statusCb);\n        }\n        /**\n         * @description Signs a transaction, returning `this` to allow chaining. E.g.: `signAsync(...).send()`. Like `.signAndSend` this will retrieve the nonce and blockHash to send the tx with.\n        */\n        signAsync(account, partialOptions) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call\n            return decorateMethod(() => this.#observeSign(account, partialOptions).pipe(map((info) => {\n                // If we got a full signed transaction from the signer, attach it\n                if (info.signedTransaction) {\n                    const extrinsic = new Submittable(api.registry, info.signedTransaction);\n                    extrinsicInfoMap.set(this, info);\n                    return extrinsic;\n                }\n                // Fallback if signer didn’t return signedTransaction\n                return this;\n            })))();\n        }\n        // signAndSend implementation for all 3 cases above\n        signAndSend(account, partialOptions, optionalStatusCb) {\n            const [options, statusCb] = makeSignAndSendOptions(partialOptions, optionalStatusCb);\n            const isSubscription = api.hasSubscriptions && (this.#ignoreStatusCb || !!statusCb);\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-call\n            return decorateMethod(() => this.#observeSign(account, options).pipe(switchMap((info) => isSubscription\n                ? this.#observeSubscribe(info)\n                : this.#observeSend(info))) // FIXME This is wrong, SubmittableResult is _not_ a codec\n            )(statusCb);\n        }\n        // adds a transform to the result, applied before result is returned\n        withResultTransform(transform) {\n            this.#transformResult = transform;\n            return this;\n        }\n        #observeSign = (account, partialOptions) => {\n            const address = isKeyringPair(account) ? account.address : account.toString();\n            const options = optionsOrNonce(partialOptions);\n            return api.derive.tx.signingInfo(address, options.nonce, options.era).pipe(first(), mergeMap(async (signingInfo) => {\n                const eraOptions = makeEraOptions(api, this.registry, options, signingInfo);\n                let updateId = -1;\n                let signedTx = null;\n                if (isKeyringPair(account)) {\n                    this.sign(account, eraOptions);\n                }\n                else {\n                    const result = await this.#signViaSigner(address, eraOptions, signingInfo.header);\n                    updateId = result.id;\n                    if (result.signedTransaction) {\n                        signedTx = result.signedTransaction;\n                    }\n                }\n                return { options: eraOptions, signedTransaction: signedTx, updateId };\n            }));\n        };\n        #observeStatus = (txHash, status) => {\n            if (!status.isFinalized && !status.isInBlock) {\n                return of(this.#transformResult(new SubmittableResult({\n                    status,\n                    txHash\n                })));\n            }\n            const blockHash = status.isInBlock\n                ? status.asInBlock\n                : status.asFinalized;\n            return api.derive.tx.events(blockHash).pipe(map(({ block, events }) => this.#transformResult(new SubmittableResult({\n                ...filterEvents(txHash, block, events, status),\n                status,\n                txHash\n            }))), catchError((internalError) => of(this.#transformResult(new SubmittableResult({\n                internalError,\n                status,\n                txHash\n            })))));\n        };\n        #observeSend = (info) => {\n            return api.rpc.author.submitExtrinsic(info?.signedTransaction || this).pipe(tap((hash) => {\n                this.#updateSigner(hash, info);\n            }));\n        };\n        #observeSubscribe = (info) => {\n            const txHash = this.hash;\n            return api.rpc.author.submitAndWatchExtrinsic(info?.signedTransaction || this).pipe(switchMap((status) => this.#observeStatus(txHash, status)), tap((status) => {\n                this.#updateSigner(status, info);\n            }));\n        };\n        #signViaSigner = async (address, options, header) => {\n            const signer = options.signer || api.signer;\n            const allowCallDataAlteration = options.allowCallDataAlteration ?? true;\n            if (!signer) {\n                throw new Error('No signer specified, either via api.setSigner or via sign options. You possibly need to pass through an explicit keypair for the origin so it can be used for signing.');\n            }\n            const payload = this.registry.createTypeUnsafe('SignerPayload', [objectSpread({}, options, {\n                    address,\n                    blockNumber: header ? header.number : 0,\n                    method: this.method\n                })]);\n            let result;\n            if (isFunction(signer.signPayload)) {\n                result = await signer.signPayload(payload.toPayload());\n                if (result.signedTransaction && !options.withSignedTransaction) {\n                    throw new Error('The `signedTransaction` field may not be submitted when `withSignedTransaction` is disabled');\n                }\n                if (result.signedTransaction && options.withSignedTransaction) {\n                    const ext = this.registry.createTypeUnsafe('Extrinsic', [result.signedTransaction]);\n                    const newSignerPayload = this.registry.createTypeUnsafe('SignerPayload', [objectSpread({}, {\n                            address,\n                            assetId: ext.assetId && ext.assetId.isSome ? ext.assetId.toHex() : null,\n                            blockHash: payload.blockHash,\n                            blockNumber: header ? header.number : 0,\n                            era: ext.era.toHex(),\n                            genesisHash: payload.genesisHash,\n                            metadataHash: ext.metadataHash ? ext.metadataHash.toHex() : null,\n                            method: ext.method.toHex(),\n                            mode: ext.mode ? ext.mode.toHex() : null,\n                            nonce: ext.nonce.toHex(),\n                            runtimeVersion: payload.runtimeVersion,\n                            signedExtensions: payload.signedExtensions,\n                            tip: ext.tip ? ext.tip.toHex() : null,\n                            version: payload.version\n                        })]);\n                    if (!ext.isSigned) {\n                        throw new Error(`When using the signedTransaction field, the transaction must be signed. Recieved isSigned: ${ext.isSigned}`);\n                    }\n                    if (!allowCallDataAlteration) {\n                        this.#validateSignedTransaction(payload, ext);\n                    }\n                    // This is only used for signAsync - signAndSend does not need to adjust the super payload or\n                    // add the signature.\n                    super.addSignature(address, result.signature, newSignerPayload.toPayload());\n                    return { id: result.id, signedTransaction: result.signedTransaction };\n                }\n            }\n            else if (isFunction(signer.signRaw)) {\n                result = await signer.signRaw(payload.toRaw());\n            }\n            else {\n                throw new Error('Invalid signer interface, it should implement either signPayload or signRaw (or both)');\n            }\n            // Here we explicitly call `toPayload()` again instead of working with an object\n            // (reference) as passed to the signer. This means that we are sure that the\n            // payload data is not modified from our inputs, but the signer\n            super.addSignature(address, result.signature, payload.toPayload());\n            return { id: result.id };\n        };\n        #updateSigner = (status, info) => {\n            if (info && (info.updateId !== -1)) {\n                const { options, updateId } = info;\n                const signer = options.signer || api.signer;\n                if (signer && isFunction(signer.update)) {\n                    signer.update(updateId, status);\n                }\n            }\n        };\n        /**\n         * When a signer includes `signedTransaction` within the SignerResult this will validate\n         * specific fields within the signed extrinsic against the original payload that was passed\n         * to the signer.\n         */\n        #validateSignedTransaction = (signerPayload, signedExt) => {\n            const payload = signerPayload.toPayload();\n            const errMsg = (field) => `signAndSend: ${field} does not match the original payload`;\n            if (payload.method !== signedExt.method.toHex()) {\n                throw new Error(errMsg('call data'));\n            }\n        };\n    }\n    return Submittable;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 548, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/api/submittable/createSubmittable.js"],"sourcesContent":["import { createClass } from './createClass.js';\nexport function createSubmittable(apiType, api, decorateMethod, registry, blockHash) {\n    const Submittable = createClass({ api, apiType, blockHash, decorateMethod });\n    return (extrinsic) => new Submittable(registry || api.registry, extrinsic);\n}\n"],"names":[],"mappings":";;;;AAAA;;AACO,SAAS,kBAAkB,OAAO,EAAE,GAAG,EAAE,cAAc,EAAE,QAAQ,EAAE,SAAS;IAC/E,MAAM,cAAc,IAAA,8KAAW,EAAC;QAAE;QAAK;QAAS;QAAW;IAAe;IAC1E,OAAO,CAAC,YAAc,IAAI,YAAY,YAAY,IAAI,QAAQ,EAAE;AACpE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 567, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/api/util/augmentObject.js"],"sourcesContent":["import { lazyMethods, logger, objectClear } from '@polkadot/util';\nconst l = logger('api/augment');\nfunction logLength(type, values, and = []) {\n    return values.length\n        ? ` ${values.length} ${type}${and.length ? ' and' : ''}`\n        : '';\n}\nfunction logValues(type, values) {\n    return values.length\n        ? `\\n\\t${type.padStart(7)}: ${values.sort().join(', ')}`\n        : '';\n}\nfunction warn(prefix, type, [added, removed]) {\n    if (added.length || removed.length) {\n        l.warn(`api.${prefix}: Found${logLength('added', added, removed)}${logLength('removed', removed)} ${type}:${logValues('added', added)}${logValues('removed', removed)}`);\n    }\n}\nfunction findSectionExcludes(a, b) {\n    return a.filter((s) => !b.includes(s));\n}\nfunction findSectionIncludes(a, b) {\n    return a.filter((s) => b.includes(s));\n}\nfunction extractSections(src, dst) {\n    const srcSections = Object.keys(src);\n    const dstSections = Object.keys(dst);\n    return [\n        findSectionExcludes(srcSections, dstSections),\n        findSectionExcludes(dstSections, srcSections)\n    ];\n}\nfunction findMethodExcludes(src, dst) {\n    const srcSections = Object.keys(src);\n    const dstSections = findSectionIncludes(Object.keys(dst), srcSections);\n    const excludes = [];\n    for (let s = 0, scount = dstSections.length; s < scount; s++) {\n        const section = dstSections[s];\n        const srcMethods = Object.keys(src[section]);\n        const dstMethods = Object.keys(dst[section]);\n        for (let d = 0, mcount = dstMethods.length; d < mcount; d++) {\n            const method = dstMethods[d];\n            if (!srcMethods.includes(method)) {\n                excludes.push(`${section}.${method}`);\n            }\n        }\n    }\n    return excludes;\n}\nfunction extractMethods(src, dst) {\n    return [\n        findMethodExcludes(dst, src),\n        findMethodExcludes(src, dst)\n    ];\n}\n/**\n * @description Takes a decorated api section (e.g. api.tx) and augment it with the details. It does not override what is\n * already available, but rather just adds new missing items into the result object.\n * @internal\n */\nexport function augmentObject(prefix, src, dst, fromEmpty = false) {\n    fromEmpty && objectClear(dst);\n    // NOTE: This part is slightly problematic since it will get the\n    // values for at least all the sections and the names of the methods\n    // (Since methods won't be decorated before lazy, this _may_ be ok)\n    if (prefix && Object.keys(dst).length) {\n        warn(prefix, 'modules', extractSections(src, dst));\n        warn(prefix, 'calls', extractMethods(src, dst));\n    }\n    const sections = Object.keys(src);\n    for (let i = 0, count = sections.length; i < count; i++) {\n        const section = sections[i];\n        const methods = src[section];\n        // We don't set here with a lazy interface, we decorate based\n        // on the top-level structure (this bypasses adding lazy onto lazy)\n        if (!dst[section]) {\n            dst[section] = {};\n        }\n        lazyMethods(dst[section], Object.keys(methods), (m) => methods[m]);\n    }\n    return dst;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 650, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/api/util/decorate.js"],"sourcesContent":["import { lazyDeriveSection } from '@polkadot/api-derive';\n/**\n * This is a section decorator which keeps all type information.\n */\nexport function decorateDeriveSections(decorateMethod, derives) {\n    const getKeys = (s) => Object.keys(derives[s]);\n    const creator = (s, m) => decorateMethod(derives[s][m]);\n    const result = {};\n    const names = Object.keys(derives);\n    for (let i = 0, count = names.length; i < count; i++) {\n        lazyDeriveSection(result, names[i], getKeys, creator);\n    }\n    return result;\n}\n"],"names":[],"mappings":";;;;AAAA;;AAIO,SAAS,uBAAuB,cAAc,EAAE,OAAO;IAC1D,MAAM,UAAU,CAAC,IAAM,OAAO,IAAI,CAAC,OAAO,CAAC,EAAE;IAC7C,MAAM,UAAU,CAAC,GAAG,IAAM,eAAe,OAAO,CAAC,EAAE,CAAC,EAAE;IACtD,MAAM,SAAS,CAAC;IAChB,MAAM,QAAQ,OAAO,IAAI,CAAC;IAC1B,IAAK,IAAI,IAAI,GAAG,QAAQ,MAAM,MAAM,EAAE,IAAI,OAAO,IAAK;QAClD,IAAA,gLAAiB,EAAC,QAAQ,KAAK,CAAC,EAAE,EAAE,SAAS;IACjD;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 670, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/api/util/validate.js"],"sourcesContent":["import { isUndefined } from '@polkadot/util';\nfunction sig({ lookup }, { method, section }, args) {\n    return `${section}.${method}(${args.map((a) => lookup.getTypeDef(a).type).join(', ')})`;\n}\nexport function extractStorageArgs(registry, creator, _args) {\n    const args = _args.filter((a) => !isUndefined(a));\n    if (creator.meta.type.isPlain) {\n        if (args.length !== 0) {\n            throw new Error(`${sig(registry, creator, [])} does not take any arguments, ${args.length} found`);\n        }\n    }\n    else {\n        const { hashers, key } = creator.meta.type.asMap;\n        const keys = hashers.length === 1\n            ? [key]\n            : registry.lookup.getSiType(key).def.asTuple.map((t) => t);\n        if (args.length !== keys.length) {\n            throw new Error(`${sig(registry, creator, keys)} is a map, requiring ${keys.length} arguments, ${args.length} found`);\n        }\n    }\n    // pass as tuple\n    return [creator, args];\n}\n"],"names":[],"mappings":";;;;AAAA;;AACA,SAAS,IAAI,EAAE,MAAM,EAAE,EAAE,EAAE,MAAM,EAAE,OAAO,EAAE,EAAE,IAAI;IAC9C,OAAO,GAAG,QAAQ,CAAC,EAAE,OAAO,CAAC,EAAE,KAAK,GAAG,CAAC,CAAC,IAAM,OAAO,UAAU,CAAC,GAAG,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;AAC3F;AACO,SAAS,mBAAmB,QAAQ,EAAE,OAAO,EAAE,KAAK;IACvD,MAAM,OAAO,MAAM,MAAM,CAAC,CAAC,IAAM,CAAC,IAAA,oKAAW,EAAC;IAC9C,IAAI,QAAQ,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;QAC3B,IAAI,KAAK,MAAM,KAAK,GAAG;YACnB,MAAM,IAAI,MAAM,GAAG,IAAI,UAAU,SAAS,EAAE,EAAE,8BAA8B,EAAE,KAAK,MAAM,CAAC,MAAM,CAAC;QACrG;IACJ,OACK;QACD,MAAM,EAAE,OAAO,EAAE,GAAG,EAAE,GAAG,QAAQ,IAAI,CAAC,IAAI,CAAC,KAAK;QAChD,MAAM,OAAO,QAAQ,MAAM,KAAK,IAC1B;YAAC;SAAI,GACL,SAAS,MAAM,CAAC,SAAS,CAAC,KAAK,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,IAAM;QAC5D,IAAI,KAAK,MAAM,KAAK,KAAK,MAAM,EAAE;YAC7B,MAAM,IAAI,MAAM,GAAG,IAAI,UAAU,SAAS,MAAM,qBAAqB,EAAE,KAAK,MAAM,CAAC,YAAY,EAAE,KAAK,MAAM,CAAC,MAAM,CAAC;QACxH;IACJ;IACA,gBAAgB;IAChB,OAAO;QAAC;QAAS;KAAK;AAC1B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 704, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/api/base/Events.js"],"sourcesContent":["import { EventEmitter } from 'eventemitter3';\nexport class Events {\n    #eventemitter = new EventEmitter();\n    emit(type, ...args) {\n        return this.#eventemitter.emit(type, ...args);\n    }\n    /**\n     * @description Attach an eventemitter handler to listen to a specific event\n     *\n     * @param type The type of event to listen to. Available events are `connected`, `disconnected`, `ready` and `error`\n     * @param handler The callback to be called when the event fires. Depending on the event type, it could fire with additional arguments.\n     *\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * api.on('connected', (): void => {\n     *   console.log('API has been connected to the endpoint');\n     * });\n     *\n     * api.on('disconnected', (): void => {\n     *   console.log('API has been disconnected from the endpoint');\n     * });\n     * ```\n     */\n    on(type, handler) {\n        this.#eventemitter.on(type, handler);\n        return this;\n    }\n    /**\n     * @description Remove the given eventemitter handler\n     *\n     * @param type The type of event the callback was attached to. Available events are `connected`, `disconnected`, `ready` and `error`\n     * @param handler The callback to unregister.\n     *\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * const handler = (): void => {\n     *  console.log('Connected !);\n     * };\n     *\n     * // Start listening\n     * api.on('connected', handler);\n     *\n     * // Stop listening\n     * api.off('connected', handler);\n     * ```\n     */\n    off(type, handler) {\n        this.#eventemitter.removeListener(type, handler);\n        return this;\n    }\n    /**\n     * @description Attach an one-time eventemitter handler to listen to a specific event\n     *\n     * @param type The type of event to listen to. Available events are `connected`, `disconnected`, `ready` and `error`\n     * @param handler The callback to be called when the event fires. Depending on the event type, it could fire with additional arguments.\n     *\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * api.once('connected', (): void => {\n     *   console.log('API has been connected to the endpoint');\n     * });\n     *\n     * api.once('disconnected', (): void => {\n     *   console.log('API has been disconnected from the endpoint');\n     * });\n     * ```\n     */\n    once(type, handler) {\n        this.#eventemitter.once(type, handler);\n        return this;\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;;AACO,MAAM;IACT,CAAA,YAAa,GAAG,IAAI,iMAAY,GAAG;IACnC,KAAK,IAAI,EAAE,GAAG,IAAI,EAAE;QAChB,OAAO,IAAI,CAAC,CAAA,YAAa,CAAC,IAAI,CAAC,SAAS;IAC5C;IACA;;;;;;;;;;;;;;;;;;KAkBC,GACD,GAAG,IAAI,EAAE,OAAO,EAAE;QACd,IAAI,CAAC,CAAA,YAAa,CAAC,EAAE,CAAC,MAAM;QAC5B,OAAO,IAAI;IACf;IACA;;;;;;;;;;;;;;;;;;;;KAoBC,GACD,IAAI,IAAI,EAAE,OAAO,EAAE;QACf,IAAI,CAAC,CAAA,YAAa,CAAC,cAAc,CAAC,MAAM;QACxC,OAAO,IAAI;IACf;IACA;;;;;;;;;;;;;;;;;;KAkBC,GACD,KAAK,IAAI,EAAE,OAAO,EAAE;QAChB,IAAI,CAAC,CAAA,YAAa,CAAC,IAAI,CAAC,MAAM;QAC9B,OAAO,IAAI;IACf;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 789, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/api/base/Decorate.js"],"sourcesContent":["import { BehaviorSubject, combineLatest, from, map, of, switchMap, tap, toArray } from 'rxjs';\nimport { getAvailableDerives } from '@polkadot/api-derive';\nimport { memo, RpcCore } from '@polkadot/rpc-core';\nimport { WsProvider } from '@polkadot/rpc-provider';\nimport { expandMetadata, GenericExtrinsic, typeDefinitions, TypeRegistry } from '@polkadot/types';\nimport { getSpecRuntime } from '@polkadot/types-known';\nimport { arrayChunk, arrayFlatten, assertReturn, BN, compactStripLength, lazyMethod, lazyMethods, logger, nextTick, objectSpread, stringCamelCase, stringUpperFirst, u8aConcatStrict, u8aToHex } from '@polkadot/util';\nimport { blake2AsHex } from '@polkadot/util-crypto';\nimport { createSubmittable } from '../submittable/index.js';\nimport { augmentObject } from '../util/augmentObject.js';\nimport { decorateDeriveSections } from '../util/decorate.js';\nimport { extractStorageArgs } from '../util/validate.js';\nimport { Events } from './Events.js';\nimport { findCall, findError } from './find.js';\nconst PAGE_SIZE_K = 1000; // limit aligned with the 1k on the node (trie lookups are heavy)\nconst PAGE_SIZE_V = 250; // limited since the data may be > 16MB (e.g. misfiring elections)\nconst PAGE_SIZE_Q = 50; // queue of pending storage queries (mapped together, next tick)\nconst l = logger('api/init');\nlet instanceCounter = 0;\nfunction getAtQueryFn(api, { method, section }) {\n    return assertReturn(api.rx.query[section] && api.rx.query[section][method], () => `query.${section}.${method} is not available in this version of the metadata`);\n}\nexport class Decorate extends Events {\n    #instanceId;\n    #runtimeLog = {};\n    #registry;\n    #storageGetQ = [];\n    #storageSubQ = [];\n    // HACK Use BN import so decorateDerive works... yes, wtf.\n    __phantom = new BN(0);\n    _type;\n    _call = {};\n    _consts = {};\n    _derive;\n    _errors = {};\n    _events = {};\n    _extrinsics;\n    _extrinsicType = GenericExtrinsic.LATEST_EXTRINSIC_VERSION;\n    _genesisHash;\n    _isConnected;\n    _isReady = false;\n    _query = {};\n    _queryMulti;\n    _rpc;\n    _rpcCore;\n    _runtimeMap = {};\n    _runtimeChain;\n    _runtimeMetadata;\n    _runtimeVersion;\n    _rx = { call: {}, consts: {}, query: {}, tx: {} };\n    _options;\n    /**\n     * This is the one and only method concrete children classes need to implement.\n     * It's a higher-order function, which takes one argument\n     * `method: Method extends (...args: any[]) => Observable<any>`\n     * (and one optional `options`), and should return the user facing method.\n     * For example:\n     * - For ApiRx, `decorateMethod` should just be identity, because the input\n     * function is already an Observable\n     * - For ApiPromise, `decorateMethod` should return a function that takes all\n     * the parameters from `method`, adds an optional `callback` argument, and\n     * returns a Promise.\n     *\n     * We could easily imagine other user-facing interfaces, which are simply\n     * implemented by transforming the Observable to Stream/Iterator/Kefir/Bacon\n     * via `decorateMethod`.\n     */\n    _decorateMethod;\n    /**\n     * @description Create an instance of the class\n     *\n     * @param options Options object to create API instance or a Provider instance\n     *\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * import Api from '@polkadot/api/promise';\n     *\n     * const api = new Api().isReady();\n     *\n     * api.rpc.subscribeNewHeads((header) => {\n     *   console.log(`new block #${header.number.toNumber()}`);\n     * });\n     * ```\n     */\n    constructor(options, type, decorateMethod) {\n        super();\n        this.#instanceId = `${++instanceCounter}`;\n        this.#registry = options.source?.registry || options.registry || new TypeRegistry();\n        this._rx.callAt = (blockHash, knownVersion) => from(this.at(blockHash, knownVersion)).pipe(map((a) => a.rx.call));\n        this._rx.queryAt = (blockHash, knownVersion) => from(this.at(blockHash, knownVersion)).pipe(map((a) => a.rx.query));\n        this._rx.registry = this.#registry;\n        this._decorateMethod = decorateMethod;\n        this._options = options;\n        this._type = type;\n        const provider = options.source\n            ? options.source._rpcCore.provider.isClonable\n                ? options.source._rpcCore.provider.clone()\n                : options.source._rpcCore.provider\n            : (options.provider || new WsProvider());\n        // The RPC interface decorates the known interfaces on init\n        this._rpcCore = new RpcCore(this.#instanceId, this.#registry, {\n            isPedantic: this._options.isPedantic,\n            provider,\n            rpcCacheCapacity: this._options.rpcCacheCapacity,\n            ttl: this._options.provider?.ttl,\n            userRpc: this._options.rpc\n        });\n        this._isConnected = new BehaviorSubject(this._rpcCore.provider.isConnected);\n        this._rx.hasSubscriptions = this._rpcCore.provider.hasSubscriptions;\n    }\n    /**\n     * @description Return the current used registry\n     */\n    get registry() {\n        return this.#registry;\n    }\n    /**\n     * @description Creates an instance of a type as registered\n     */\n    createType(type, ...params) {\n        return this.#registry.createType(type, ...params);\n    }\n    /**\n     * @description Register additional user-defined of chain-specific types in the type registry\n     */\n    registerTypes(types) {\n        types && this.#registry.register(types);\n    }\n    /**\n     * @returns `true` if the API operates with subscriptions\n     */\n    get hasSubscriptions() {\n        return this._rpcCore.provider.hasSubscriptions;\n    }\n    /**\n     * @returns `true` if the API decorate multi-key queries\n     */\n    get supportMulti() {\n        return this._rpcCore.provider.hasSubscriptions || !!this._rpcCore.state.queryStorageAt;\n    }\n    _emptyDecorated(registry, blockHash) {\n        return {\n            call: {},\n            consts: {},\n            errors: {},\n            events: {},\n            query: {},\n            registry,\n            rx: {\n                call: {},\n                query: {}\n            },\n            tx: createSubmittable(this._type, this._rx, this._decorateMethod, registry, blockHash)\n        };\n    }\n    _createDecorated(registry, fromEmpty, decoratedApi, blockHash) {\n        if (!decoratedApi) {\n            decoratedApi = this._emptyDecorated(registry.registry, blockHash);\n        }\n        if (fromEmpty || !registry.decoratedMeta) {\n            registry.decoratedMeta = expandMetadata(registry.registry, registry.metadata);\n        }\n        const runtime = this._decorateCalls(registry, this._decorateMethod, blockHash);\n        const runtimeRx = this._decorateCalls(registry, this._rxDecorateMethod, blockHash);\n        const storage = this._decorateStorage(registry.decoratedMeta, this._decorateMethod, blockHash);\n        const storageRx = this._decorateStorage(registry.decoratedMeta, this._rxDecorateMethod, blockHash);\n        augmentObject('consts', registry.decoratedMeta.consts, decoratedApi.consts, fromEmpty);\n        augmentObject('errors', registry.decoratedMeta.errors, decoratedApi.errors, fromEmpty);\n        augmentObject('events', registry.decoratedMeta.events, decoratedApi.events, fromEmpty);\n        augmentObject('query', storage, decoratedApi.query, fromEmpty);\n        augmentObject('query', storageRx, decoratedApi.rx.query, fromEmpty);\n        augmentObject('call', runtime, decoratedApi.call, fromEmpty);\n        augmentObject('call', runtimeRx, decoratedApi.rx.call, fromEmpty);\n        decoratedApi.findCall = (callIndex) => findCall(registry.registry, callIndex);\n        decoratedApi.findError = (errorIndex) => findError(registry.registry, errorIndex);\n        decoratedApi.queryMulti = blockHash\n            ? this._decorateMultiAt(decoratedApi, this._decorateMethod, blockHash)\n            : this._decorateMulti(this._decorateMethod);\n        decoratedApi.runtimeVersion = registry.runtimeVersion;\n        return {\n            createdAt: blockHash,\n            decoratedApi,\n            decoratedMeta: registry.decoratedMeta\n        };\n    }\n    _injectMetadata(registry, fromEmpty = false) {\n        // clear the decoration, we are redoing it here\n        if (fromEmpty || !registry.decoratedApi) {\n            registry.decoratedApi = this._emptyDecorated(registry.registry);\n        }\n        const { decoratedApi, decoratedMeta } = this._createDecorated(registry, fromEmpty, registry.decoratedApi);\n        this._call = decoratedApi.call;\n        this._consts = decoratedApi.consts;\n        this._errors = decoratedApi.errors;\n        this._events = decoratedApi.events;\n        this._query = decoratedApi.query;\n        this._rx.call = decoratedApi.rx.call;\n        this._rx.query = decoratedApi.rx.query;\n        const tx = this._decorateExtrinsics(decoratedMeta, this._decorateMethod);\n        const rxtx = this._decorateExtrinsics(decoratedMeta, this._rxDecorateMethod);\n        if (fromEmpty || !this._extrinsics) {\n            this._extrinsics = tx;\n            this._rx.tx = rxtx;\n        }\n        else {\n            augmentObject('tx', tx, this._extrinsics, false);\n            augmentObject(null, rxtx, this._rx.tx, false);\n        }\n        augmentObject(null, decoratedMeta.consts, this._rx.consts, fromEmpty);\n        this.emit('decorated');\n    }\n    /**\n     * @deprecated\n     * backwards compatible endpoint for metadata injection, may be removed in the future (However, it is still useful for testing injection)\n     */\n    injectMetadata(metadata, fromEmpty, registry) {\n        this._injectMetadata({ counter: 0, metadata, registry: registry || this.#registry, runtimeVersion: this.#registry.createType('RuntimeVersionPartial') }, fromEmpty);\n    }\n    _decorateFunctionMeta(input, output) {\n        output.meta = input.meta;\n        output.method = input.method;\n        output.section = input.section;\n        output.toJSON = input.toJSON;\n        if (input.callIndex) {\n            output.callIndex = input.callIndex;\n        }\n        return output;\n    }\n    // Filter all RPC methods based on the results of the rpc_methods call. We do this in the following\n    // manner to cater for both old and new:\n    //   - when the number of entries are 0, only remove the ones with isOptional (account & contracts)\n    //   - when non-zero, remove anything that is not in the array (we don't do this)\n    _filterRpc(methods, additional) {\n        // add any specific user-base RPCs\n        if (Object.keys(additional).length !== 0) {\n            this._rpcCore.addUserInterfaces(additional);\n            // re-decorate, only adding any new additional interfaces\n            this._decorateRpc(this._rpcCore, this._decorateMethod, this._rpc);\n            this._decorateRpc(this._rpcCore, this._rxDecorateMethod, this._rx.rpc);\n        }\n        // extract the actual sections from the methods (this is useful when\n        // we try and create mappings to runtime names via a hash mapping)\n        const sectionMap = {};\n        for (let i = 0, count = methods.length; i < count; i++) {\n            const [section] = methods[i].split('_');\n            sectionMap[section] = true;\n        }\n        // convert the actual section names into an easy name lookup\n        const sections = Object.keys(sectionMap);\n        for (let i = 0, count = sections.length; i < count; i++) {\n            const nameA = stringUpperFirst(sections[i]);\n            const nameB = `${nameA}Api`;\n            this._runtimeMap[blake2AsHex(nameA, 64)] = nameA;\n            this._runtimeMap[blake2AsHex(nameB, 64)] = nameB;\n        }\n        // finally we filter the actual methods to expose\n        this._filterRpcMethods(methods);\n    }\n    _filterRpcMethods(exposed) {\n        const hasResults = exposed.length !== 0;\n        const allKnown = [...this._rpcCore.mapping.entries()];\n        const allKeys = [];\n        const count = allKnown.length;\n        for (let i = 0; i < count; i++) {\n            const [, { alias, endpoint, method, pubsub, section }] = allKnown[i];\n            allKeys.push(`${section}_${method}`);\n            if (pubsub) {\n                allKeys.push(`${section}_${pubsub[1]}`);\n                allKeys.push(`${section}_${pubsub[2]}`);\n            }\n            if (alias) {\n                allKeys.push(...alias);\n            }\n            if (endpoint) {\n                allKeys.push(endpoint);\n            }\n        }\n        const unknown = exposed.filter((k) => !allKeys.includes(k) &&\n            !k.includes('_unstable_'));\n        if (unknown.length && !this._options.noInitWarn) {\n            l.warn(`RPC methods not decorated: ${unknown.join(', ')}`);\n        }\n        // loop through all entries we have (populated in decorate) and filter as required\n        // only remove when we have results and method missing, or with no results if optional\n        for (let i = 0; i < count; i++) {\n            const [k, { method, section }] = allKnown[i];\n            if (hasResults && !exposed.includes(k) && k !== 'rpc_methods') {\n                if (this._rpc[section]) {\n                    delete this._rpc[section][method];\n                    delete this._rx.rpc[section][method];\n                }\n            }\n        }\n    }\n    _rpcSubmitter(decorateMethod) {\n        const method = (method, ...params) => {\n            return from(this._rpcCore.provider.send(method, params));\n        };\n        return decorateMethod(method);\n    }\n    _decorateRpc(rpc, decorateMethod, input = this._rpcSubmitter(decorateMethod)) {\n        const out = input;\n        const decorateFn = (section, method) => {\n            const source = rpc[section][method];\n            const fn = decorateMethod(source, { methodName: method });\n            fn.meta = source.meta;\n            fn.raw = decorateMethod(source.raw, { methodName: method });\n            return fn;\n        };\n        for (let s = 0, scount = rpc.sections.length; s < scount; s++) {\n            const section = rpc.sections[s];\n            if (!Object.prototype.hasOwnProperty.call(out, section)) {\n                const methods = Object.keys(rpc[section]);\n                const decorateInternal = (method) => decorateFn(section, method);\n                for (let m = 0, mcount = methods.length; m < mcount; m++) {\n                    const method = methods[m];\n                    //  skip subscriptions where we have a non-subscribe interface\n                    if (this.hasSubscriptions || !(method.startsWith('subscribe') || method.startsWith('unsubscribe'))) {\n                        if (!Object.prototype.hasOwnProperty.call(out, section)) {\n                            out[section] = {};\n                        }\n                        lazyMethod(out[section], method, decorateInternal);\n                    }\n                }\n            }\n        }\n        return out;\n    }\n    // add all definition entries\n    _addRuntimeDef(result, additional) {\n        if (!additional) {\n            return;\n        }\n        const entries = Object.entries(additional);\n        for (let j = 0, ecount = entries.length; j < ecount; j++) {\n            const [key, defs] = entries[j];\n            if (result[key]) {\n                // we have this one already, step through for new versions or\n                // new methods and add those as applicable\n                for (let k = 0, dcount = defs.length; k < dcount; k++) {\n                    const def = defs[k];\n                    const prev = result[key].find(({ version }) => def.version === version);\n                    if (prev) {\n                        // interleave the new methods with the old - last definition wins\n                        objectSpread(prev.methods, def.methods);\n                    }\n                    else {\n                        // we don't have this specific version, add it\n                        result[key].push(def);\n                    }\n                }\n            }\n            else {\n                // we don't have this runtime definition, add it as-is\n                result[key] = defs;\n            }\n        }\n    }\n    // extract all runtime definitions\n    _getRuntimeDefs(registry, specName, chain = '') {\n        const result = {};\n        const defValues = Object.values(typeDefinitions);\n        // options > chain/spec > built-in, apply in reverse order with\n        // methods overriding previous definitions (or interleave missing)\n        for (let i = 0, count = defValues.length; i < count; i++) {\n            this._addRuntimeDef(result, defValues[i].runtime);\n        }\n        this._addRuntimeDef(result, getSpecRuntime(registry, chain, specName));\n        this._addRuntimeDef(result, this._options.runtime);\n        return Object.entries(result);\n    }\n    // Helper for _getRuntimeDefsViaMetadata\n    _getMethods(registry, methods) {\n        const result = {};\n        methods.forEach((m) => {\n            const { docs, inputs, name, output } = m;\n            result[name.toString()] = {\n                description: docs.map((d) => d.toString()).join(),\n                params: inputs.map(({ name, type }) => {\n                    return { name: name.toString(), type: registry.lookup.getName(type) || registry.lookup.getTypeDef(type).type };\n                }),\n                type: registry.lookup.getName(output) || registry.lookup.getTypeDef(output).type\n            };\n        });\n        return result;\n    }\n    // Maintains the same structure as `_getRuntimeDefs` in order to make conversion easier.\n    _getRuntimeDefsViaMetadata(registry) {\n        const result = {};\n        const { apis } = registry.metadata;\n        for (let i = 0, count = apis.length; i < count; i++) {\n            const { methods, name } = apis[i];\n            result[name.toString()] = [{\n                    methods: this._getMethods(registry, methods),\n                    // We set the version to 0 here since it will not be relevant when we are grabbing the runtime apis\n                    // from the Metadata.\n                    version: 0\n                }];\n        }\n        return Object.entries(result);\n    }\n    // When the calls are available in the metadata, it will generate them based off of the metadata.\n    // When they are not available it will use the hardcoded calls generated in the static types.\n    _decorateCalls({ registry, runtimeVersion: { apis, specName, specVersion } }, decorateMethod, blockHash) {\n        const result = {};\n        const named = {};\n        const hashes = {};\n        const isApiInMetadata = registry.metadata.apis.length > 0;\n        const sections = isApiInMetadata ? this._getRuntimeDefsViaMetadata(registry) : this._getRuntimeDefs(registry, specName, this._runtimeChain);\n        const older = [];\n        const implName = `${specName.toString()}/${specVersion.toString()}`;\n        const hasLogged = this.#runtimeLog[implName] || false;\n        this.#runtimeLog[implName] = true;\n        if (isApiInMetadata) {\n            for (let i = 0, scount = sections.length; i < scount; i++) {\n                const [_section, secs] = sections[i];\n                const sec = secs[0];\n                const sectionHash = blake2AsHex(_section, 64);\n                const section = stringCamelCase(_section);\n                const methods = Object.entries(sec.methods);\n                if (!named[section]) {\n                    named[section] = {};\n                }\n                for (let m = 0, mcount = methods.length; m < mcount; m++) {\n                    const [_method, def] = methods[m];\n                    const method = stringCamelCase(_method);\n                    named[section][method] = objectSpread({ method, name: `${_section}_${_method}`, section, sectionHash }, def);\n                }\n            }\n        }\n        else {\n            for (let i = 0, scount = sections.length; i < scount; i++) {\n                const [_section, secs] = sections[i];\n                const sectionHash = blake2AsHex(_section, 64);\n                const rtApi = apis.find(([a]) => a.eq(sectionHash));\n                hashes[sectionHash] = true;\n                if (rtApi) {\n                    const all = secs.map(({ version }) => version).sort();\n                    const sec = secs.find(({ version }) => rtApi[1].eq(version));\n                    if (sec) {\n                        const section = stringCamelCase(_section);\n                        const methods = Object.entries(sec.methods);\n                        if (methods.length) {\n                            if (!named[section]) {\n                                named[section] = {};\n                            }\n                            for (let m = 0, mcount = methods.length; m < mcount; m++) {\n                                const [_method, def] = methods[m];\n                                const method = stringCamelCase(_method);\n                                named[section][method] = objectSpread({ method, name: `${_section}_${_method}`, section, sectionHash }, def);\n                            }\n                        }\n                    }\n                    else {\n                        older.push(`${_section}/${rtApi[1].toString()} (${all.join('/')} known)`);\n                    }\n                }\n            }\n            // find the runtimes that we don't have hashes for\n            const notFound = apis\n                .map(([a, v]) => [a.toHex(), v.toString()])\n                .filter(([a]) => !hashes[a])\n                .map(([a, v]) => `${this._runtimeMap[a] || a}/${v}`);\n            if (!this._options.noInitWarn && !hasLogged) {\n                if (older.length) {\n                    l.warn(`${implName}: Not decorating runtime apis without matching versions: ${older.join(', ')}`);\n                }\n                if (notFound.length) {\n                    l.warn(`${implName}: Not decorating unknown runtime apis: ${notFound.join(', ')}`);\n                }\n            }\n        }\n        const stateCall = blockHash\n            ? (name, bytes) => this._rpcCore.state.call(name, bytes, blockHash)\n            : (name, bytes) => this._rpcCore.state.call(name, bytes);\n        const lazySection = (section) => lazyMethods({}, Object.keys(named[section]), (method) => this._decorateCall(registry, named[section][method], stateCall, decorateMethod));\n        const modules = Object.keys(named);\n        for (let i = 0, count = modules.length; i < count; i++) {\n            lazyMethod(result, modules[i], lazySection);\n        }\n        return result;\n    }\n    _decorateCall(registry, def, stateCall, decorateMethod) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        const decorated = decorateMethod((...args) => {\n            if (args.length !== def.params.length) {\n                throw new Error(`${def.name}:: Expected ${def.params.length} arguments, found ${args.length}`);\n            }\n            const bytes = registry.createType('Raw', u8aConcatStrict(args.map((a, i) => registry.createTypeUnsafe(def.params[i].type, [a]).toU8a())));\n            return stateCall(def.name, bytes).pipe(map((r) => registry.createTypeUnsafe(def.type, [r])));\n        });\n        decorated.meta = def;\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return decorated;\n    }\n    // only be called if supportMulti is true\n    _decorateMulti(decorateMethod) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return decorateMethod((keys) => keys.length\n            ? (this.hasSubscriptions\n                ? this._rpcCore.state.subscribeStorage\n                : this._rpcCore.state.queryStorageAt)(keys.map((args) => Array.isArray(args)\n                ? args[0].creator.meta.type.isPlain\n                    ? [args[0].creator]\n                    : args[0].creator.meta.type.asMap.hashers.length === 1\n                        ? [args[0].creator, args.slice(1)]\n                        : [args[0].creator, ...args.slice(1)]\n                : [args.creator]))\n            : of([]));\n    }\n    _decorateMultiAt(atApi, decorateMethod, blockHash) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return decorateMethod((calls) => calls.length\n            ? this._rpcCore.state.queryStorageAt(calls.map((args) => {\n                if (Array.isArray(args)) {\n                    const { creator } = getAtQueryFn(atApi, args[0].creator);\n                    return creator.meta.type.isPlain\n                        ? [creator]\n                        : creator.meta.type.asMap.hashers.length === 1\n                            ? [creator, args.slice(1)]\n                            : [creator, ...args.slice(1)];\n                }\n                return [getAtQueryFn(atApi, args.creator).creator];\n            }), blockHash)\n            : of([]));\n    }\n    _decorateExtrinsics({ tx }, decorateMethod) {\n        const result = createSubmittable(this._type, this._rx, decorateMethod);\n        const lazySection = (section) => lazyMethods({}, Object.keys(tx[section]), (method) => method.startsWith('$')\n            ? tx[section][method]\n            : this._decorateExtrinsicEntry(tx[section][method], result));\n        const sections = Object.keys(tx);\n        for (let i = 0, count = sections.length; i < count; i++) {\n            lazyMethod(result, sections[i], lazySection);\n        }\n        return result;\n    }\n    _decorateExtrinsicEntry(method, creator) {\n        const decorated = (...params) => creator(method(...params));\n        // pass through the `.is`\n        decorated.is = (other) => method.is(other);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return this._decorateFunctionMeta(method, decorated);\n    }\n    _decorateStorage({ query, registry }, decorateMethod, blockHash) {\n        const result = {};\n        const lazySection = (section) => lazyMethods({}, Object.keys(query[section]), (method) => blockHash\n            ? this._decorateStorageEntryAt(registry, query[section][method], decorateMethod, blockHash)\n            : this._decorateStorageEntry(query[section][method], decorateMethod));\n        const sections = Object.keys(query);\n        for (let i = 0, count = sections.length; i < count; i++) {\n            lazyMethod(result, sections[i], lazySection);\n        }\n        return result;\n    }\n    _decorateStorageEntry(creator, decorateMethod) {\n        const getArgs = (args, registry) => extractStorageArgs(registry || this.#registry, creator, args);\n        const getQueryAt = (blockHash) => from(this.at(blockHash)).pipe(map((api) => getAtQueryFn(api, creator)));\n        // Disable this where it occurs for each field we are decorating\n        /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n        const decorated = this._decorateStorageCall(creator, decorateMethod);\n        decorated.creator = creator;\n        // eslint-disable-next-line deprecation/deprecation\n        decorated.at = decorateMethod((blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap((q) => q(...args))));\n        decorated.hash = decorateMethod((...args) => this._rpcCore.state.getStorageHash(getArgs(args)));\n        decorated.is = (key) => key.section === creator.section &&\n            key.method === creator.method;\n        decorated.key = (...args) => u8aToHex(compactStripLength(creator(...args))[1]);\n        decorated.keyPrefix = (...args) => u8aToHex(creator.keyPrefix(...args));\n        decorated.size = decorateMethod((...args) => this._rpcCore.state.getStorageSize(getArgs(args)));\n        // eslint-disable-next-line deprecation/deprecation\n        decorated.sizeAt = decorateMethod((blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap((q) => this._rpcCore.state.getStorageSize(getArgs(args, q.creator.meta.registry), blockHash))));\n        // .keys() & .entries() only available on map types\n        if (creator.iterKey && creator.meta.type.isMap) {\n            decorated.entries = decorateMethod(memo(this.#instanceId, (...args) => this._retrieveMapEntries(creator, null, args)));\n            // eslint-disable-next-line deprecation/deprecation\n            decorated.entriesAt = decorateMethod(memo(this.#instanceId, (blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap((q) => this._retrieveMapEntries(q.creator, blockHash, args)))));\n            decorated.entriesPaged = decorateMethod(memo(this.#instanceId, (opts) => this._retrieveMapEntriesPaged(creator, undefined, opts)));\n            decorated.keys = decorateMethod(memo(this.#instanceId, (...args) => this._retrieveMapKeys(creator, null, args)));\n            // eslint-disable-next-line deprecation/deprecation\n            decorated.keysAt = decorateMethod(memo(this.#instanceId, (blockHash, ...args) => getQueryAt(blockHash).pipe(switchMap((q) => this._retrieveMapKeys(q.creator, blockHash, args)))));\n            decorated.keysPaged = decorateMethod(memo(this.#instanceId, (opts) => this._retrieveMapKeysPaged(creator, undefined, opts)));\n        }\n        if (this.supportMulti && creator.meta.type.isMap) {\n            // When using double map storage function, user need to pass double map key as an array\n            decorated.multi = decorateMethod((args) => creator.meta.type.asMap.hashers.length === 1\n                ? this._retrieveMulti(args.map((a) => [creator, [a]]))\n                : this._retrieveMulti(args.map((a) => [creator, a])));\n        }\n        /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n        return this._decorateFunctionMeta(creator, decorated);\n    }\n    _decorateStorageEntryAt(registry, creator, decorateMethod, blockHash) {\n        const getArgs = (args) => extractStorageArgs(registry, creator, args);\n        // Disable this where it occurs for each field we are decorating\n        /* eslint-disable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n        const decorated = decorateMethod((...args) => this._rpcCore.state.getStorage(getArgs(args), blockHash));\n        decorated.creator = creator;\n        decorated.hash = decorateMethod((...args) => this._rpcCore.state.getStorageHash(getArgs(args), blockHash));\n        decorated.is = (key) => key.section === creator.section &&\n            key.method === creator.method;\n        decorated.key = (...args) => u8aToHex(compactStripLength(creator(...args))[1]);\n        decorated.keyPrefix = (...keys) => u8aToHex(creator.keyPrefix(...keys));\n        decorated.size = decorateMethod((...args) => this._rpcCore.state.getStorageSize(getArgs(args), blockHash));\n        // .keys() & .entries() only available on map types\n        if (creator.iterKey && creator.meta.type.isMap) {\n            decorated.entries = decorateMethod(memo(this.#instanceId, (...args) => this._retrieveMapEntries(creator, blockHash, args)));\n            decorated.entriesPaged = decorateMethod(memo(this.#instanceId, (opts) => this._retrieveMapEntriesPaged(creator, blockHash, opts)));\n            decorated.keys = decorateMethod(memo(this.#instanceId, (...args) => this._retrieveMapKeys(creator, blockHash, args)));\n            decorated.keysPaged = decorateMethod(memo(this.#instanceId, (opts) => this._retrieveMapKeysPaged(creator, blockHash, opts)));\n        }\n        if (this.supportMulti && creator.meta.type.isMap) {\n            // When using double map storage function, user need to pass double map key as an array\n            decorated.multi = decorateMethod((args) => creator.meta.type.asMap.hashers.length === 1\n                ? this._retrieveMulti(args.map((a) => [creator, [a]]), blockHash)\n                : this._retrieveMulti(args.map((a) => [creator, a]), blockHash));\n        }\n        /* eslint-enable @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment */\n        return this._decorateFunctionMeta(creator, decorated);\n    }\n    _queueStorage(call, queue) {\n        const query = queue === this.#storageSubQ\n            ? this._rpcCore.state.subscribeStorage\n            : this._rpcCore.state.queryStorageAt;\n        let queueIdx = queue.length - 1;\n        let valueIdx = 0;\n        let valueObs;\n        // if we don't have queue entries yet,\n        // or the current queue has fired (see from below),\n        // or the current queue has the max entries,\n        // then we create a new queue\n        if (queueIdx === -1 || !queue[queueIdx] || queue[queueIdx][1].length === PAGE_SIZE_Q) {\n            queueIdx++;\n            valueObs = from(\n            // we delay the execution until the next tick, this allows\n            // any queries made in this timeframe to be added to the same\n            // queue for a single query\n            new Promise((resolve) => {\n                nextTick(() => {\n                    // get all the calls in this instance, resolve with it\n                    // and then clear the queue so we don't add more\n                    // (anything after this will be added to a new queue)\n                    const calls = queue[queueIdx][1];\n                    delete queue[queueIdx];\n                    resolve(calls);\n                });\n            })).pipe(switchMap((calls) => query(calls)));\n            queue.push([valueObs, [call]]);\n        }\n        else {\n            valueObs = queue[queueIdx][0];\n            valueIdx = queue[queueIdx][1].length;\n            queue[queueIdx][1].push(call);\n        }\n        return valueObs.pipe(\n        // return the single value at this index\n        map((values) => values[valueIdx]));\n    }\n    // Decorate the base storage call. In the case or rxjs or promise-without-callback (await)\n    // we make a subscription, alternatively we push this through a single-shot query\n    _decorateStorageCall(creator, decorateMethod) {\n        const memoed = memo(this.#instanceId, (...args) => {\n            const call = extractStorageArgs(this.#registry, creator, args);\n            if (!this.hasSubscriptions) {\n                return this._rpcCore.state.getStorage(call);\n            }\n            return this._queueStorage(call, this.#storageSubQ);\n        });\n        return decorateMethod(memoed, {\n            methodName: creator.method,\n            overrideNoSub: (...args) => this._queueStorage(extractStorageArgs(this.#registry, creator, args), this.#storageGetQ)\n        });\n    }\n    // retrieve a set of values for a specific set of keys - here we chunk the keys into PAGE_SIZE sizes\n    _retrieveMulti(keys, blockHash) {\n        if (!keys.length) {\n            return of([]);\n        }\n        const query = this.hasSubscriptions && !blockHash\n            ? this._rpcCore.state.subscribeStorage\n            : this._rpcCore.state.queryStorageAt;\n        if (keys.length <= PAGE_SIZE_V) {\n            return blockHash\n                ? query(keys, blockHash)\n                : query(keys);\n        }\n        return combineLatest(arrayChunk(keys, PAGE_SIZE_V).map((k) => blockHash\n            ? query(k, blockHash)\n            : query(k))).pipe(map(arrayFlatten));\n    }\n    _retrieveMapKeys({ iterKey, meta, method, section }, at, args) {\n        if (!iterKey || !meta.type.isMap) {\n            throw new Error('keys can only be retrieved on maps');\n        }\n        const headKey = iterKey(...args).toHex();\n        const startSubject = new BehaviorSubject(headKey);\n        const query = at\n            ? (startKey) => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K, startKey, at)\n            : (startKey) => this._rpcCore.state.getKeysPaged(headKey, PAGE_SIZE_K, startKey);\n        const setMeta = (key) => key.setMeta(meta, section, method);\n        return startSubject.pipe(switchMap(query), map((keys) => keys.map(setMeta)), tap((keys) => nextTick(() => {\n            keys.length === PAGE_SIZE_K\n                ? startSubject.next(keys[PAGE_SIZE_K - 1].toHex())\n                : startSubject.complete();\n        })), toArray(), // toArray since we want to startSubject to be completed\n        map(arrayFlatten));\n    }\n    _retrieveMapKeysPaged({ iterKey, meta, method, section }, at, opts) {\n        if (!iterKey || !meta.type.isMap) {\n            throw new Error('keys can only be retrieved on maps');\n        }\n        const setMeta = (key) => key.setMeta(meta, section, method);\n        const query = at\n            ? (headKey) => this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey, at)\n            : (headKey) => this._rpcCore.state.getKeysPaged(headKey, opts.pageSize, opts.startKey || headKey);\n        return query(iterKey(...opts.args).toHex()).pipe(map((keys) => keys.map(setMeta)));\n    }\n    _retrieveMapEntries(entry, at, args) {\n        const query = at\n            ? (keys) => this._rpcCore.state.queryStorageAt(keys, at)\n            : (keys) => this._rpcCore.state.queryStorageAt(keys);\n        return this._retrieveMapKeys(entry, at, args).pipe(switchMap((keys) => keys.length\n            ? combineLatest(arrayChunk(keys, PAGE_SIZE_V).map(query)).pipe(map((valsArr) => arrayFlatten(valsArr).map((value, index) => [keys[index], value])))\n            : of([])));\n    }\n    _retrieveMapEntriesPaged(entry, at, opts) {\n        const query = at\n            ? (keys) => this._rpcCore.state.queryStorageAt(keys, at)\n            : (keys) => this._rpcCore.state.queryStorageAt(keys);\n        return this._retrieveMapKeysPaged(entry, at, opts).pipe(switchMap((keys) => keys.length\n            ? query(keys).pipe(map((valsArr) => valsArr.map((value, index) => [keys[index], value])))\n            : of([])));\n    }\n    _decorateDeriveRx(decorateMethod) {\n        const specName = this._runtimeVersion?.specName.toString();\n        // Pull in derive from api-derive\n        const available = getAvailableDerives(this.#instanceId, this._rx, objectSpread({}, this._options.derives, this._options.typesBundle?.spec?.[specName || '']?.derives));\n        return decorateDeriveSections(decorateMethod, available);\n    }\n    _decorateDerive(decorateMethod) {\n        return decorateDeriveSections(decorateMethod, this._rx.derive);\n    }\n    /**\n     * Put the `this.onCall` function of ApiRx here, because it is needed by\n     * `api._rx`.\n     */\n    _rxDecorateMethod = (method) => {\n        return method;\n    };\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1582, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/api/base/Init.js"],"sourcesContent":["import { firstValueFrom, map, of, switchMap } from 'rxjs';\nimport { Metadata, TypeRegistry } from '@polkadot/types';\nimport { LATEST_EXTRINSIC_VERSION } from '@polkadot/types/extrinsic/constants';\nimport { getSpecAlias, getSpecExtensions, getSpecHasher, getSpecRpc, getSpecTypes, getUpgradeVersion } from '@polkadot/types-known';\nimport { assertReturn, BN_ZERO, isUndefined, logger, noop, objectSpread, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { blake2AsHex, cryptoWaitReady } from '@polkadot/util-crypto';\nimport { Decorate } from './Decorate.js';\nconst KEEPALIVE_INTERVAL = 10000;\nconst WITH_VERSION_SHORTCUT = false;\nconst SUPPORTED_METADATA_VERSIONS = [16, 15, 14];\nconst l = logger('api/init');\nfunction textToString(t) {\n    return t.toString();\n}\nexport class Init extends Decorate {\n    #atLast = null;\n    #healthTimer = null;\n    #registries = [];\n    #updateSub = null;\n    #waitingRegistries = {};\n    constructor(options, type, decorateMethod) {\n        super(options, type, decorateMethod);\n        // all injected types added to the registry for overrides\n        this.registry.setKnownTypes(options);\n        // We only register the types (global) if this is not a cloned instance.\n        // Do right up-front, so we get in the user types before we are actually\n        // doing anything on-chain, this ensures we have the overrides in-place\n        if (!options.source) {\n            this.registerTypes(options.types);\n        }\n        else {\n            this.#registries = options.source.#registries;\n        }\n        this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);\n        this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);\n        if (this.supportMulti) {\n            this._queryMulti = this._decorateMulti(this._decorateMethod);\n            this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);\n        }\n        this._rx.signer = options.signer;\n        this._rpcCore.setRegistrySwap((blockHash) => this.getBlockRegistry(blockHash));\n        this._rpcCore.setResolveBlockHash((blockNumber) => firstValueFrom(this._rpcCore.chain.getBlockHash(blockNumber)));\n        if (this.hasSubscriptions) {\n            this._rpcCore.provider.on('disconnected', () => this.#onProviderDisconnect());\n            this._rpcCore.provider.on('error', (e) => this.#onProviderError(e));\n            this._rpcCore.provider.on('connected', () => this.#onProviderConnect());\n        }\n        else if (!this._options.noInitWarn) {\n            l.warn('Api will be available in a limited mode since the provider does not support subscriptions');\n        }\n        // If the provider was instantiated earlier, and has already emitted a\n        // 'connected' event, then the `on('connected')` won't fire anymore. To\n        // cater for this case, we call manually `this._onProviderConnect`.\n        if (this._rpcCore.provider.isConnected) {\n            this.#onProviderConnect().catch(noop);\n        }\n    }\n    /**\n     * @description Decorates a registry based on the runtime version\n     */\n    _initRegistry(registry, chain, version, metadata, chainProps) {\n        registry.clearCache();\n        registry.setChainProperties(chainProps || this.registry.getChainProperties());\n        registry.setKnownTypes(this._options);\n        registry.register(getSpecTypes(registry, chain, version.specName, version.specVersion));\n        registry.setHasher(getSpecHasher(registry, chain, version.specName));\n        // for bundled types, pull through the aliases defined\n        if (registry.knownTypes.typesBundle) {\n            registry.knownTypes.typesAlias = getSpecAlias(registry, chain, version.specName);\n        }\n        registry.setMetadata(metadata, undefined, objectSpread({}, getSpecExtensions(registry, chain, version.specName), this._options.signedExtensions), this._options.noInitWarn);\n    }\n    /**\n     * @description Returns the default versioned registry\n     */\n    _getDefaultRegistry() {\n        return assertReturn(this.#registries.find(({ isDefault }) => isDefault), 'Initialization error, cannot find the default registry');\n    }\n    /**\n     * @description Returns a decorated API instance at a specific point in time\n     */\n    async at(blockHash, knownVersion) {\n        const u8aHash = u8aToU8a(blockHash);\n        const u8aHex = u8aToHex(u8aHash);\n        const registry = await this.getBlockRegistry(u8aHash, knownVersion);\n        if (!this.#atLast || this.#atLast[0] !== u8aHex) {\n            // always create a new decoration - since we are pointing to a specific hash, this\n            // means that all queries needs to use that hash (not a previous one already existing)\n            this.#atLast = [u8aHex, this._createDecorated(registry, true, null, u8aHash).decoratedApi];\n        }\n        return this.#atLast[1];\n    }\n    async _createBlockRegistry(blockHash, header, version) {\n        const registry = new TypeRegistry(blockHash);\n        const metadata = await this._retrieveMetadata(version.apis, header.parentHash, registry);\n        const runtimeChain = this._runtimeChain;\n        if (!runtimeChain) {\n            throw new Error('Invalid initializion order, runtimeChain is not available');\n        }\n        this._initRegistry(registry, runtimeChain, version, metadata);\n        // add our new registry\n        const result = { counter: 0, lastBlockHash: blockHash, metadata, registry, runtimeVersion: version };\n        this.#registries.push(result);\n        return result;\n    }\n    _cacheBlockRegistryProgress(key, creator) {\n        // look for waiting resolves\n        let waiting = this.#waitingRegistries[key];\n        if (isUndefined(waiting)) {\n            // nothing waiting, construct new\n            waiting = this.#waitingRegistries[key] = new Promise((resolve, reject) => {\n                creator()\n                    .then((registry) => {\n                    delete this.#waitingRegistries[key];\n                    resolve(registry);\n                })\n                    .catch((error) => {\n                    delete this.#waitingRegistries[key];\n                    reject(error);\n                });\n            });\n        }\n        return waiting;\n    }\n    _getBlockRegistryViaVersion(blockHash, version) {\n        if (version) {\n            // check for pre-existing registries. We also check specName, e.g. it\n            // could be changed like in Westmint with upgrade from shell -> westmint\n            const existingViaVersion = this.#registries.find(({ runtimeVersion: { specName, specVersion } }) => specName.eq(version.specName) &&\n                specVersion.eq(version.specVersion));\n            if (existingViaVersion) {\n                existingViaVersion.counter++;\n                existingViaVersion.lastBlockHash = blockHash;\n                return existingViaVersion;\n            }\n        }\n        return null;\n    }\n    async _getBlockRegistryViaHash(blockHash) {\n        // ensure we have everything required\n        if (!this._genesisHash || !this._runtimeVersion) {\n            throw new Error('Cannot retrieve data on an uninitialized chain');\n        }\n        // We have to assume that on the RPC layer the calls used here does not call back into\n        // the registry swap, so getHeader & getRuntimeVersion should not be historic\n        const header = this.registry.createType('HeaderPartial', this._genesisHash.eq(blockHash)\n            ? { number: BN_ZERO, parentHash: this._genesisHash }\n            : await firstValueFrom(this._rpcCore.chain.getHeader.raw(blockHash)));\n        if (header.parentHash.isEmpty) {\n            l.warn(`Unable to retrieve header ${blockHash.toString()} and parent ${header.parentHash.toString()} from supplied hash`);\n            throw new Error('Unable to retrieve header and parent from supplied hash');\n        }\n        // get the runtime version, either on-chain or via an known upgrade history\n        const [firstVersion, lastVersion] = getUpgradeVersion(this._genesisHash, header.number);\n        const version = this.registry.createType('RuntimeVersionPartial', WITH_VERSION_SHORTCUT && (firstVersion && (lastVersion ||\n            firstVersion.specVersion.eq(this._runtimeVersion.specVersion)))\n            ? { apis: firstVersion.apis, specName: this._runtimeVersion.specName, specVersion: firstVersion.specVersion }\n            : await firstValueFrom(this._rpcCore.state.getRuntimeVersion.raw(header.parentHash)));\n        return (\n        // try to find via version\n        this._getBlockRegistryViaVersion(blockHash, version) ||\n            // return new or in-flight result\n            await this._cacheBlockRegistryProgress(version.toHex(), () => this._createBlockRegistry(blockHash, header, version)));\n    }\n    /**\n     * @description Sets up a registry based on the block hash defined\n     */\n    async getBlockRegistry(blockHash, knownVersion) {\n        return (\n        // try to find via blockHash\n        this.#registries.find(({ lastBlockHash }) => lastBlockHash && u8aEq(lastBlockHash, blockHash)) ||\n            // try to find via version\n            this._getBlockRegistryViaVersion(blockHash, knownVersion) ||\n            // return new or in-flight result\n            await this._cacheBlockRegistryProgress(u8aToHex(blockHash), () => this._getBlockRegistryViaHash(blockHash)));\n    }\n    async _loadMeta() {\n        // on re-connection to the same chain, we don't want to re-do everything from chain again\n        if (this._isReady) {\n            // on re-connection only re-subscribe to chain updates if we are not a clone\n            if (!this._options.source) {\n                this._subscribeUpdates();\n            }\n            return true;\n        }\n        this._unsubscribeUpdates();\n        // only load from on-chain if we are not a clone (default path), alternatively\n        // just use the values from the source instance provided\n        [this._genesisHash, this._runtimeMetadata] = this._options.source?._isReady\n            ? await this._metaFromSource(this._options.source)\n            : await this._metaFromChain(this._options.metadata);\n        return this._initFromMeta(this._runtimeMetadata);\n    }\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async _metaFromSource(source) {\n        this._extrinsicType = source.extrinsicVersion;\n        this._runtimeChain = source.runtimeChain;\n        this._runtimeVersion = source.runtimeVersion;\n        // manually build a list of all available methods in this RPC, we are\n        // going to filter on it to align the cloned RPC without making a call\n        const sections = Object.keys(source.rpc);\n        const rpcs = [];\n        for (let s = 0, scount = sections.length; s < scount; s++) {\n            const section = sections[s];\n            const methods = Object.keys(source.rpc[section]);\n            for (let m = 0, mcount = methods.length; m < mcount; m++) {\n                rpcs.push(`${section}_${methods[m]}`);\n            }\n        }\n        this._filterRpc(rpcs, getSpecRpc(this.registry, source.runtimeChain, source.runtimeVersion.specName));\n        return [source.genesisHash, source.runtimeMetadata];\n    }\n    // subscribe to metadata updates, inject the types on changes\n    _subscribeUpdates() {\n        if (this.#updateSub || !this.hasSubscriptions) {\n            return;\n        }\n        this.#updateSub = this._rpcCore.state.subscribeRuntimeVersion().pipe(switchMap((version) => \n        // only retrieve the metadata when the on-chain version has been changed\n        this._runtimeVersion?.specVersion.eq(version.specVersion)\n            ? of(false)\n            : this._rpcCore.state.getMetadata().pipe(map((metadata) => {\n                l.log(`Runtime version updated to spec=${version.specVersion.toString()}, tx=${version.transactionVersion.toString()}`);\n                this._runtimeMetadata = metadata;\n                this._runtimeVersion = version;\n                this._rx.runtimeVersion = version;\n                // update the default registry version\n                const thisRegistry = this._getDefaultRegistry();\n                const runtimeChain = this._runtimeChain;\n                if (!runtimeChain) {\n                    throw new Error('Invalid initializion order, runtimeChain is not available');\n                }\n                // setup the data as per the current versions\n                thisRegistry.metadata = metadata;\n                thisRegistry.runtimeVersion = version;\n                this._initRegistry(this.registry, runtimeChain, version, metadata);\n                this._injectMetadata(thisRegistry, true);\n                return true;\n            })))).subscribe();\n    }\n    async _metaFromChain(optMetadata) {\n        const [genesisHash, runtimeVersion, chain, chainProps, rpcMethods] = await Promise.all([\n            firstValueFrom(this._rpcCore.chain.getBlockHash(0)),\n            firstValueFrom(this._rpcCore.state.getRuntimeVersion()),\n            firstValueFrom(this._rpcCore.system.chain()),\n            firstValueFrom(this._rpcCore.system.properties()),\n            firstValueFrom(this._rpcCore.rpc.methods())\n        ]);\n        // set our chain version & genesisHash as returned\n        this._runtimeChain = chain;\n        this._runtimeVersion = runtimeVersion;\n        this._rx.runtimeVersion = runtimeVersion;\n        // retrieve metadata, either from chain  or as pass-in via options\n        const metadataKey = `${genesisHash.toHex() || '0x'}-${runtimeVersion.specVersion.toString()}`;\n        const metadata = optMetadata?.[metadataKey]\n            ? new Metadata(this.registry, optMetadata[metadataKey])\n            : await this._retrieveMetadata(runtimeVersion.apis);\n        // initializes the registry & RPC\n        this._initRegistry(this.registry, chain, runtimeVersion, metadata, chainProps);\n        this._filterRpc(rpcMethods.methods.map(textToString), getSpecRpc(this.registry, chain, runtimeVersion.specName));\n        this._subscribeUpdates();\n        // setup the initial registry, when we have none\n        if (!this.#registries.length) {\n            this.#registries.push({ counter: 0, isDefault: true, metadata, registry: this.registry, runtimeVersion });\n        }\n        // get unique types & validate\n        metadata.getUniqTypes(this._options.throwOnUnknown || false);\n        return [genesisHash, metadata];\n    }\n    _initFromMeta(metadata) {\n        const runtimeVersion = this._runtimeVersion;\n        if (!runtimeVersion) {\n            throw new Error('Invalid initializion order, runtimeVersion is not available');\n        }\n        // ExtrinsicV5 is not fully supported yet, for that reason we default to version 4\n        this._extrinsicType = metadata.asLatest.extrinsic.versions.at(0) || LATEST_EXTRINSIC_VERSION;\n        this._rx.extrinsicType = this._extrinsicType;\n        this._rx.genesisHash = this._genesisHash;\n        this._rx.runtimeVersion = runtimeVersion;\n        // inject metadata and adjust the types as detected\n        this._injectMetadata(this._getDefaultRegistry(), true);\n        // derive is last, since it uses the decorated rx\n        this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);\n        this._derive = this._decorateDerive(this._decorateMethod);\n        return true;\n    }\n    /**\n     * @internal\n     *\n     * Tries to use runtime api calls to retrieve metadata. This ensures the api initializes with the latest metadata.\n     * If the runtime call is not there it will use the rpc method.\n     */\n    async _retrieveMetadata(apis, at, registry) {\n        let metadataVersion = null;\n        const metadataApi = apis.find(([a]) => a.eq(blake2AsHex('Metadata', 64)));\n        const typeRegistry = registry || this.registry;\n        // This chain does not have support for the metadataApi, or does not have the required version.\n        if (!metadataApi || metadataApi[1].toNumber() < 2) {\n            l.warn('MetadataApi not available, rpc::state::get_metadata will be used.');\n            return at\n                ? new Metadata(typeRegistry, await firstValueFrom(this._rpcCore.state.getMetadata.raw(at)))\n                : await firstValueFrom(this._rpcCore.state.getMetadata());\n        }\n        try {\n            const metadataVersionsAsBytes = at\n                ? await firstValueFrom(this._rpcCore.state.call.raw('Metadata_metadata_versions', '0x', at))\n                : await firstValueFrom(this._rpcCore.state.call('Metadata_metadata_versions', '0x'));\n            const versions = typeRegistry.createType('Vec<u32>', metadataVersionsAsBytes);\n            // For unstable versions of the metadata the last value is set to u32 MAX in the runtime. This ensures only supported stable versions are used.\n            metadataVersion = versions.filter((ver) => SUPPORTED_METADATA_VERSIONS.includes(ver.toNumber())).reduce((largest, current) => current.gt(largest) ? current : largest);\n        }\n        catch (e) {\n            l.debug(e.message);\n            l.warn('error with state_call::Metadata_metadata_versions, rpc::state::get_metadata will be used');\n        }\n        // When the metadata version does not align with the latest supported versions we ensure not to call the metadata runtime call.\n        // I noticed on some previous runtimes that have support for `Metadata_metadata_at_version` that very irregular versions were being returned.\n        // This was evident with runtime 1000000 - it return a very large number. This ensures we always stick within what is supported.\n        if (metadataVersion && !SUPPORTED_METADATA_VERSIONS.includes(metadataVersion.toNumber())) {\n            metadataVersion = null;\n        }\n        if (metadataVersion) {\n            try {\n                const metadataBytes = at\n                    ? await firstValueFrom(this._rpcCore.state.call.raw('Metadata_metadata_at_version', u8aToHex(metadataVersion.toU8a()), at))\n                    : await firstValueFrom(this._rpcCore.state.call('Metadata_metadata_at_version', u8aToHex(metadataVersion.toU8a())));\n                // When the metadata is called with `at` it is required to use `.raw`. Therefore since the length prefix is not present the\n                // need to create a `Raw` type is necessary before creating the `OpaqueMetadata` type or else there will be a magic number\n                // mismatch\n                const rawMeta = at\n                    ? typeRegistry.createType('Raw', metadataBytes).toU8a()\n                    : metadataBytes;\n                const opaqueMetadata = typeRegistry.createType('Option<OpaqueMetadata>', rawMeta).unwrapOr(null);\n                if (opaqueMetadata) {\n                    return new Metadata(typeRegistry, opaqueMetadata.toHex());\n                }\n            }\n            catch (e) {\n                l.debug(e.message);\n                l.warn('error with state_call::Metadata_metadata_at_version, rpc::state::get_metadata will be used');\n            }\n        }\n        return at\n            ? new Metadata(typeRegistry, await firstValueFrom(this._rpcCore.state.getMetadata.raw(at)))\n            : await firstValueFrom(this._rpcCore.state.getMetadata());\n    }\n    _subscribeHealth() {\n        this._unsubscribeHealth();\n        // Only enable the health keepalive on WS, not needed on HTTP\n        this.#healthTimer = this.hasSubscriptions\n            ? setInterval(() => {\n                firstValueFrom(this._rpcCore.system.health.raw()).catch(noop);\n            }, KEEPALIVE_INTERVAL)\n            : null;\n    }\n    _unsubscribeHealth() {\n        if (this.#healthTimer) {\n            clearInterval(this.#healthTimer);\n            this.#healthTimer = null;\n        }\n    }\n    _unsubscribeUpdates() {\n        if (this.#updateSub) {\n            this.#updateSub.unsubscribe();\n            this.#updateSub = null;\n        }\n    }\n    _unsubscribe() {\n        this._unsubscribeHealth();\n        this._unsubscribeUpdates();\n    }\n    async #onProviderConnect() {\n        this._isConnected.next(true);\n        this.emit('connected');\n        try {\n            const cryptoReady = this._options.initWasm === false\n                ? true\n                : await cryptoWaitReady();\n            const hasMeta = await this._loadMeta();\n            this._subscribeHealth();\n            if (hasMeta && !this._isReady && cryptoReady) {\n                this._isReady = true;\n                this.emit('ready', this);\n            }\n        }\n        catch (_error) {\n            const error = new Error(`FATAL: Unable to initialize the API: ${_error.message}`);\n            l.error(error);\n            this.emit('error', error);\n        }\n    }\n    #onProviderDisconnect() {\n        this._isConnected.next(false);\n        this._unsubscribe();\n        this.emit('disconnected');\n    }\n    #onProviderError(error) {\n        this.emit('error', error);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1991, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/api/base/Getters.js"],"sourcesContent":["import { packageInfo } from '../packageInfo.js';\nimport { findCall, findError } from './find.js';\nimport { Init } from './Init.js';\nfunction assertResult(value) {\n    if (value === undefined) {\n        throw new Error(\"Api interfaces needs to be initialized before using, wait for 'isReady'\");\n    }\n    return value;\n}\nexport class Getters extends Init {\n    /**\n     * @description Runtime call interfaces (currently untyped, only decorated via API options)\n     */\n    get call() {\n        return assertResult(this._call);\n    }\n    /**\n     * @description Contains the parameter types (constants) of all modules.\n     *\n     * The values are instances of the appropriate type and are accessible using `section`.`constantName`,\n     *\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * console.log(api.consts.democracy.enactmentPeriod.toString())\n     * ```\n     */\n    get consts() {\n        return assertResult(this._consts);\n    }\n    /**\n     * @description Derived results that are injected into the API, allowing for combinations of various query results.\n     *\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * api.derive.chain.bestNumber((number) => {\n     *   console.log('best number', number);\n     * });\n     * ```\n     */\n    get derive() {\n        return assertResult(this._derive);\n    }\n    /**\n     * @description Errors from metadata\n     */\n    get errors() {\n        return assertResult(this._errors);\n    }\n    /**\n     * @description Events from metadata\n     */\n    get events() {\n        return assertResult(this._events);\n    }\n    /**\n     * @description  Returns the version of extrinsics in-use on this chain\n     */\n    get extrinsicVersion() {\n        return this._extrinsicType;\n    }\n    /**\n     * @description Contains the genesis Hash of the attached chain. Apart from being useful to determine the actual chain, it can also be used to sign immortal transactions.\n     */\n    get genesisHash() {\n        return assertResult(this._genesisHash);\n    }\n    /**\n     * @description true is the underlying provider is connected\n     */\n    get isConnected() {\n        return this._isConnected.getValue();\n    }\n    /**\n     * @description The library information name & version (from package.json)\n     */\n    get libraryInfo() {\n        return `${packageInfo.name} v${packageInfo.version}`;\n    }\n    /**\n     * @description Contains all the chain state modules and their subsequent methods in the API. These are attached dynamically from the runtime metadata.\n     *\n     * All calls inside the namespace, is denoted by `section`.`method` and may take an optional query parameter. As an example, `api.query.timestamp.now()` (current block timestamp) does not take parameters, while `api.query.system.account(<accountId>)` (retrieving the associated nonce & balances for an account), takes the `AccountId` as a parameter.\n     *\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * api.query.system.account(<accountId>, ([nonce, balance]) => {\n     *   console.log('new free balance', balance.free, 'new nonce', nonce);\n     * });\n     * ```\n     */\n    get query() {\n        return assertResult(this._query);\n    }\n    /**\n     * @description Allows for the querying of multiple storage entries and the combination thereof into a single result. This is a very optimal way to make multiple queries since it only makes a single connection to the node and retrieves the data over one subscription.\n     *\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * const unsub = await api.queryMulti(\n     *   [\n     *     // you can include the storage without any parameters\n     *     api.query.balances.totalIssuance,\n     *     // or you can pass parameters to the storage query\n     *     [api.query.system.account, '5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY']\n     *   ],\n     *   ([existential, [, { free }]]) => {\n     *     console.log(`You have ${free.sub(existential)} more than the existential deposit`);\n     *\n     *     unsub();\n     *   }\n     * );\n     * ```\n     */\n    get queryMulti() {\n        return assertResult(this._queryMulti);\n    }\n    /**\n     * @description Contains all the raw rpc sections and their subsequent methods in the API as defined by the jsonrpc interface definitions. Unlike the dynamic `api.query` and `api.tx` sections, these methods are fixed (although extensible with node upgrades) and not determined by the runtime.\n     *\n     * RPC endpoints available here allow for the query of chain, node and system information, in addition to providing interfaces for the raw queries of state (using known keys) and the submission of transactions.\n     *\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * api.rpc.chain.subscribeNewHeads((header) => {\n     *   console.log('new header', header);\n     * });\n     * ```\n     */\n    get rpc() {\n        return assertResult(this._rpc);\n    }\n    /**\n     * @description Contains the chain information for the current node.\n     */\n    get runtimeChain() {\n        return assertResult(this._runtimeChain);\n    }\n    /**\n     * @description Yields the current attached runtime metadata. Generally this is only used to construct extrinsics & storage, but is useful for current runtime inspection.\n     */\n    get runtimeMetadata() {\n        return assertResult(this._runtimeMetadata);\n    }\n    /**\n     * @description Contains the version information for the current runtime.\n     */\n    get runtimeVersion() {\n        return assertResult(this._runtimeVersion);\n    }\n    /**\n     * @description The underlying Rx API interface\n     */\n    get rx() {\n        return assertResult(this._rx);\n    }\n    /**\n     * @description Returns the underlying provider stats\n     */\n    get stats() {\n        return this._rpcCore.stats;\n    }\n    /**\n     * @description The type of this API instance, either 'rxjs' or 'promise'\n     */\n    get type() {\n        return this._type;\n    }\n    /**\n     * @description Contains all the extrinsic modules and their subsequent methods in the API. It allows for the construction of transactions and the submission thereof. These are attached dynamically from the runtime metadata.\n     *\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * api.tx.balances\n     *   .transferAllowDeath(<recipientId>, <balance>)\n     *   .signAndSend(<keyPair>, ({status}) => {\n     *     console.log('tx status', status.asFinalized.toHex());\n     *   });\n     * ```\n     */\n    get tx() {\n        return assertResult(this._extrinsics);\n    }\n    /**\n     * @description Finds the definition for a specific [[CallFunction]] based on the index supplied\n     */\n    findCall(callIndex) {\n        return findCall(this.registry, callIndex);\n    }\n    /**\n     * @description Finds the definition for a specific [[RegistryError]] based on the index supplied\n     */\n    findError(errorIndex) {\n        return findError(this.registry, errorIndex);\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AACA,SAAS,aAAa,KAAK;IACvB,IAAI,UAAU,WAAW;QACrB,MAAM,IAAI,MAAM;IACpB;IACA,OAAO;AACX;AACO,MAAM,gBAAgB,yJAAI;IAC7B;;KAEC,GACD,IAAI,OAAO;QACP,OAAO,aAAa,IAAI,CAAC,KAAK;IAClC;IACA;;;;;;;;;;;KAWC,GACD,IAAI,SAAS;QACT,OAAO,aAAa,IAAI,CAAC,OAAO;IACpC;IACA;;;;;;;;;;;KAWC,GACD,IAAI,SAAS;QACT,OAAO,aAAa,IAAI,CAAC,OAAO;IACpC;IACA;;KAEC,GACD,IAAI,SAAS;QACT,OAAO,aAAa,IAAI,CAAC,OAAO;IACpC;IACA;;KAEC,GACD,IAAI,SAAS;QACT,OAAO,aAAa,IAAI,CAAC,OAAO;IACpC;IACA;;KAEC,GACD,IAAI,mBAAmB;QACnB,OAAO,IAAI,CAAC,cAAc;IAC9B;IACA;;KAEC,GACD,IAAI,cAAc;QACd,OAAO,aAAa,IAAI,CAAC,YAAY;IACzC;IACA;;KAEC,GACD,IAAI,cAAc;QACd,OAAO,IAAI,CAAC,YAAY,CAAC,QAAQ;IACrC;IACA;;KAEC,GACD,IAAI,cAAc;QACd,OAAO,GAAG,+JAAW,CAAC,IAAI,CAAC,EAAE,EAAE,+JAAW,CAAC,OAAO,EAAE;IACxD;IACA;;;;;;;;;;;;;KAaC,GACD,IAAI,QAAQ;QACR,OAAO,aAAa,IAAI,CAAC,MAAM;IACnC;IACA;;;;;;;;;;;;;;;;;;;;;KAqBC,GACD,IAAI,aAAa;QACb,OAAO,aAAa,IAAI,CAAC,WAAW;IACxC;IACA;;;;;;;;;;;;;KAaC,GACD,IAAI,MAAM;QACN,OAAO,aAAa,IAAI,CAAC,IAAI;IACjC;IACA;;KAEC,GACD,IAAI,eAAe;QACf,OAAO,aAAa,IAAI,CAAC,aAAa;IAC1C;IACA;;KAEC,GACD,IAAI,kBAAkB;QAClB,OAAO,aAAa,IAAI,CAAC,gBAAgB;IAC7C;IACA;;KAEC,GACD,IAAI,iBAAiB;QACjB,OAAO,aAAa,IAAI,CAAC,eAAe;IAC5C;IACA;;KAEC,GACD,IAAI,KAAK;QACL,OAAO,aAAa,IAAI,CAAC,GAAG;IAChC;IACA;;KAEC,GACD,IAAI,QAAQ;QACR,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK;IAC9B;IACA;;KAEC,GACD,IAAI,OAAO;QACP,OAAO,IAAI,CAAC,KAAK;IACrB;IACA;;;;;;;;;;;;;KAaC,GACD,IAAI,KAAK;QACL,OAAO,aAAa,IAAI,CAAC,WAAW;IACxC;IACA;;KAEC,GACD,SAAS,SAAS,EAAE;QAChB,OAAO,IAAA,6JAAQ,EAAC,IAAI,CAAC,QAAQ,EAAE;IACnC;IACA;;KAEC,GACD,UAAU,UAAU,EAAE;QAClB,OAAO,IAAA,8JAAS,EAAC,IAAI,CAAC,QAAQ,EAAE;IACpC;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2188, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/api/base/index.js"],"sourcesContent":["import { isString, objectSpread, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { Getters } from './Getters.js';\nexport class ApiBase extends Getters {\n    /**\n     * @description Create an instance of the class\n     *\n     * @param options Options object to create API instance or a Provider instance\n     *\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * import Api from '@polkadot/api/promise';\n     *\n     * const api = new Api().isReady();\n     *\n     * api.rpc.subscribeNewHeads((header) => {\n     *   console.log(`new block #${header.number.toNumber()}`);\n     * });\n     * ```\n     */\n    constructor(options = {}, type, decorateMethod) {\n        super(options, type, decorateMethod);\n    }\n    /**\n     * @description Connect from the underlying provider, halting all network traffic\n     */\n    connect() {\n        return this._rpcCore.connect();\n    }\n    /**\n     * @description Disconnect from the underlying provider, halting all network traffic\n     */\n    disconnect() {\n        this._unsubscribe();\n        return this._rpcCore.disconnect();\n    }\n    /**\n     * @description Set an external signer which will be used to sign extrinsic when account passed in is not KeyringPair\n     */\n    setSigner(signer) {\n        this._rx.signer = signer;\n    }\n    /**\n     * @description Signs a raw signer payload, string or Uint8Array\n     */\n    async sign(address, data, { signer } = {}) {\n        if (isString(address)) {\n            const _signer = signer || this._rx.signer;\n            if (!_signer?.signRaw) {\n                throw new Error('No signer exists with a signRaw interface. You possibly need to pass through an explicit keypair for the origin so it can be used for signing.');\n            }\n            return (await _signer.signRaw(objectSpread({ type: 'bytes' }, data, { address }))).signature;\n        }\n        return u8aToHex(address.sign(u8aToU8a(data.data)));\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AAAA;AAAA;AACA;;;AACO,MAAM,gBAAgB,+JAAO;IAChC;;;;;;;;;;;;;;;;;KAiBC,GACD,YAAY,UAAU,CAAC,CAAC,EAAE,IAAI,EAAE,cAAc,CAAE;QAC5C,KAAK,CAAC,SAAS,MAAM;IACzB;IACA;;KAEC,GACD,UAAU;QACN,OAAO,IAAI,CAAC,QAAQ,CAAC,OAAO;IAChC;IACA;;KAEC,GACD,aAAa;QACT,IAAI,CAAC,YAAY;QACjB,OAAO,IAAI,CAAC,QAAQ,CAAC,UAAU;IACnC;IACA;;KAEC,GACD,UAAU,MAAM,EAAE;QACd,IAAI,CAAC,GAAG,CAAC,MAAM,GAAG;IACtB;IACA;;KAEC,GACD,MAAM,KAAK,OAAO,EAAE,IAAI,EAAE,EAAE,MAAM,EAAE,GAAG,CAAC,CAAC,EAAE;QACvC,IAAI,IAAA,8JAAQ,EAAC,UAAU;YACnB,MAAM,UAAU,UAAU,IAAI,CAAC,GAAG,CAAC,MAAM;YACzC,IAAI,CAAC,SAAS,SAAS;gBACnB,MAAM,IAAI,MAAM;YACpB;YACA,OAAO,CAAC,MAAM,QAAQ,OAAO,CAAC,IAAA,sKAAY,EAAC;gBAAE,MAAM;YAAQ,GAAG,MAAM;gBAAE;YAAQ,GAAG,EAAE,SAAS;QAChG;QACA,OAAO,IAAA,8JAAQ,EAAC,QAAQ,IAAI,CAAC,IAAA,8JAAQ,EAAC,KAAK,IAAI;IACnD;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2257, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/api/promise/Combinator.js"],"sourcesContent":["import { isFunction, noop } from '@polkadot/util';\nexport class Combinator {\n    #allHasFired = false;\n    #callback;\n    #fired = [];\n    #fns = [];\n    #isActive = true;\n    #results = [];\n    #subscriptions = [];\n    constructor(fns, callback) {\n        this.#callback = callback;\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises, @typescript-eslint/require-await\n        this.#subscriptions = fns.map(async (input, index) => {\n            const [fn, ...args] = Array.isArray(input)\n                ? input\n                : [input];\n            this.#fired.push(false);\n            this.#fns.push(fn);\n            // Not quite 100% how to have a variable number at the front here\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return,@typescript-eslint/ban-types\n            return fn(...args, this._createCallback(index));\n        });\n    }\n    _allHasFired() {\n        this.#allHasFired ||= this.#fired.filter((hasFired) => !hasFired).length === 0;\n        return this.#allHasFired;\n    }\n    _createCallback(index) {\n        return (value) => {\n            this.#fired[index] = true;\n            this.#results[index] = value;\n            this._triggerUpdate();\n        };\n    }\n    _triggerUpdate() {\n        if (!this.#isActive || !isFunction(this.#callback) || !this._allHasFired()) {\n            return;\n        }\n        try {\n            Promise\n                .resolve(this.#callback(this.#results))\n                .catch(noop);\n        }\n        catch {\n            // swallow, we don't want the handler to trip us up\n        }\n    }\n    unsubscribe() {\n        if (!this.#isActive) {\n            return;\n        }\n        this.#isActive = false;\n        Promise\n            .all(this.#subscriptions.map(async (subscription) => {\n            try {\n                const unsubscribe = await subscription;\n                if (isFunction(unsubscribe)) {\n                    unsubscribe();\n                }\n            }\n            catch {\n                // ignore\n            }\n        })).catch(() => {\n            // ignore, already ignored above, should never throw\n        });\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;;AACO,MAAM;IACT,CAAA,WAAY,GAAG,MAAM;IACrB,CAAA,QAAS,CAAC;IACV,CAAA,KAAM,GAAG,EAAE,CAAC;IACZ,CAAA,GAAI,GAAG,EAAE,CAAC;IACV,CAAA,QAAS,GAAG,KAAK;IACjB,CAAA,OAAQ,GAAG,EAAE,CAAC;IACd,CAAA,aAAc,GAAG,EAAE,CAAC;IACpB,YAAY,GAAG,EAAE,QAAQ,CAAE;QACvB,IAAI,CAAC,CAAA,QAAS,GAAG;QACjB,qGAAqG;QACrG,IAAI,CAAC,CAAA,aAAc,GAAG,IAAI,GAAG,CAAC,OAAO,OAAO;YACxC,MAAM,CAAC,IAAI,GAAG,KAAK,GAAG,MAAM,OAAO,CAAC,SAC9B,QACA;gBAAC;aAAM;YACb,IAAI,CAAC,CAAA,KAAM,CAAC,IAAI,CAAC;YACjB,IAAI,CAAC,CAAA,GAAI,CAAC,IAAI,CAAC;YACf,iEAAiE;YACjE,4FAA4F;YAC5F,OAAO,MAAM,MAAM,IAAI,CAAC,eAAe,CAAC;QAC5C;IACJ;IACA,eAAe;QACX,IAAI,CAAC,CAAA,WAAY,KAAK,IAAI,CAAC,CAAA,KAAM,CAAC,MAAM,CAAC,CAAC,WAAa,CAAC,UAAU,MAAM,KAAK;QAC7E,OAAO,IAAI,CAAC,CAAA,WAAY;IAC5B;IACA,gBAAgB,KAAK,EAAE;QACnB,OAAO,CAAC;YACJ,IAAI,CAAC,CAAA,KAAM,CAAC,MAAM,GAAG;YACrB,IAAI,CAAC,CAAA,OAAQ,CAAC,MAAM,GAAG;YACvB,IAAI,CAAC,cAAc;QACvB;IACJ;IACA,iBAAiB;QACb,IAAI,CAAC,IAAI,CAAC,CAAA,QAAS,IAAI,CAAC,IAAA,kKAAU,EAAC,IAAI,CAAC,CAAA,QAAS,KAAK,CAAC,IAAI,CAAC,YAAY,IAAI;YACxE;QACJ;QACA,IAAI;YACA,QACK,OAAO,CAAC,IAAI,CAAC,CAAA,QAAS,CAAC,IAAI,CAAC,CAAA,OAAQ,GACpC,KAAK,CAAC,kJAAI;QACnB,EACA,OAAM;QACF,mDAAmD;QACvD;IACJ;IACA,cAAc;QACV,IAAI,CAAC,IAAI,CAAC,CAAA,QAAS,EAAE;YACjB;QACJ;QACA,IAAI,CAAC,CAAA,QAAS,GAAG;QACjB,QACK,GAAG,CAAC,IAAI,CAAC,CAAA,aAAc,CAAC,GAAG,CAAC,OAAO;YACpC,IAAI;gBACA,MAAM,cAAc,MAAM;gBAC1B,IAAI,IAAA,kKAAU,EAAC,cAAc;oBACzB;gBACJ;YACJ,EACA,OAAM;YACF,SAAS;YACb;QACJ,IAAI,KAAK,CAAC;QACN,oDAAoD;QACxD;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2330, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/api/promise/decorateMethod.js"],"sourcesContent":["import { catchError, EMPTY, tap } from 'rxjs';\nimport { isFunction, nextTick } from '@polkadot/util';\nexport function promiseTracker(resolve, reject) {\n    let isCompleted = false;\n    return {\n        reject: (error) => {\n            if (!isCompleted) {\n                isCompleted = true;\n                reject(error);\n            }\n            return EMPTY;\n        },\n        resolve: (value) => {\n            if (!isCompleted) {\n                isCompleted = true;\n                resolve(value);\n            }\n        }\n    };\n}\nfunction extractArgs(args, needsCallback) {\n    const actualArgs = args.slice();\n    // If the last arg is a function, we pop it, put it into callback.\n    // actualArgs will then hold the actual arguments to be passed to `method`\n    const callback = (args.length && isFunction(args[args.length - 1]))\n        ? actualArgs.pop()\n        : undefined;\n    // When we need a subscription, ensure that a valid callback is actually passed\n    if (needsCallback && !isFunction(callback)) {\n        throw new Error('Expected a callback to be passed with subscriptions');\n    }\n    return [actualArgs, callback];\n}\nfunction decorateCall(method, args) {\n    return new Promise((resolve, reject) => {\n        // single result tracker - either reject with Error or resolve with Codec result\n        const tracker = promiseTracker(resolve, reject);\n        // encoding errors reject immediately, any result unsubscribes and resolves\n        const subscription = method(...args)\n            .pipe(catchError((error) => tracker.reject(error)))\n            .subscribe((result) => {\n            tracker.resolve(result);\n            nextTick(() => subscription.unsubscribe());\n        });\n    });\n}\nfunction decorateSubscribe(method, args, resultCb) {\n    return new Promise((resolve, reject) => {\n        // either reject with error or resolve with unsubscribe callback\n        const tracker = promiseTracker(resolve, reject);\n        // errors reject immediately, the first result resolves with an unsubscribe promise, all results via callback\n        const subscription = method(...args)\n            .pipe(catchError((error) => tracker.reject(error)), tap(() => tracker.resolve(() => subscription.unsubscribe())))\n            .subscribe((result) => {\n            // queue result (back of queue to clear current)\n            nextTick(() => resultCb(result));\n        });\n    });\n}\n/**\n * @description Decorate method for ApiPromise, where the results are converted to the Promise equivalent\n */\nexport function toPromiseMethod(method, options) {\n    const needsCallback = !!(options?.methodName && options.methodName.includes('subscribe'));\n    return function (...args) {\n        const [actualArgs, resultCb] = extractArgs(args, needsCallback);\n        return resultCb\n            ? decorateSubscribe(method, actualArgs, resultCb)\n            : decorateCall(options?.overrideNoSub || method, actualArgs);\n    };\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AAAA;;;AACO,SAAS,eAAe,OAAO,EAAE,MAAM;IAC1C,IAAI,cAAc;IAClB,OAAO;QACH,QAAQ,CAAC;YACL,IAAI,CAAC,aAAa;gBACd,cAAc;gBACd,OAAO;YACX;YACA,OAAO,qJAAK;QAChB;QACA,SAAS,CAAC;YACN,IAAI,CAAC,aAAa;gBACd,cAAc;gBACd,QAAQ;YACZ;QACJ;IACJ;AACJ;AACA,SAAS,YAAY,IAAI,EAAE,aAAa;IACpC,MAAM,aAAa,KAAK,KAAK;IAC7B,kEAAkE;IAClE,0EAA0E;IAC1E,MAAM,WAAW,AAAC,KAAK,MAAM,IAAI,IAAA,kKAAU,EAAC,IAAI,CAAC,KAAK,MAAM,GAAG,EAAE,IAC3D,WAAW,GAAG,KACd;IACN,+EAA+E;IAC/E,IAAI,iBAAiB,CAAC,IAAA,kKAAU,EAAC,WAAW;QACxC,MAAM,IAAI,MAAM;IACpB;IACA,OAAO;QAAC;QAAY;KAAS;AACjC;AACA,SAAS,aAAa,MAAM,EAAE,IAAI;IAC9B,OAAO,IAAI,QAAQ,CAAC,SAAS;QACzB,gFAAgF;QAChF,MAAM,UAAU,eAAe,SAAS;QACxC,2EAA2E;QAC3E,MAAM,eAAe,UAAU,MAC1B,IAAI,CAAC,IAAA,0JAAU,EAAC,CAAC,QAAU,QAAQ,MAAM,CAAC,SAC1C,SAAS,CAAC,CAAC;YACZ,QAAQ,OAAO,CAAC;YAChB,IAAA,0JAAQ,EAAC,IAAM,aAAa,WAAW;QAC3C;IACJ;AACJ;AACA,SAAS,kBAAkB,MAAM,EAAE,IAAI,EAAE,QAAQ;IAC7C,OAAO,IAAI,QAAQ,CAAC,SAAS;QACzB,gEAAgE;QAChE,MAAM,UAAU,eAAe,SAAS;QACxC,6GAA6G;QAC7G,MAAM,eAAe,UAAU,MAC1B,IAAI,CAAC,IAAA,0JAAU,EAAC,CAAC,QAAU,QAAQ,MAAM,CAAC,SAAS,IAAA,mJAAG,EAAC,IAAM,QAAQ,OAAO,CAAC,IAAM,aAAa,WAAW,MAC3G,SAAS,CAAC,CAAC;YACZ,gDAAgD;YAChD,IAAA,0JAAQ,EAAC,IAAM,SAAS;QAC5B;IACJ;AACJ;AAIO,SAAS,gBAAgB,MAAM,EAAE,OAAO;IAC3C,MAAM,gBAAgB,CAAC,CAAC,CAAC,SAAS,cAAc,QAAQ,UAAU,CAAC,QAAQ,CAAC,YAAY;IACxF,OAAO,SAAU,GAAG,IAAI;QACpB,MAAM,CAAC,YAAY,SAAS,GAAG,YAAY,MAAM;QACjD,OAAO,WACD,kBAAkB,QAAQ,YAAY,YACtC,aAAa,SAAS,iBAAiB,QAAQ;IACzD;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2406, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/api/promise/Api.js"],"sourcesContent":["import { noop, objectSpread } from '@polkadot/util';\nimport { ApiBase } from '../base/index.js';\nimport { Combinator } from './Combinator.js';\nimport { promiseTracker, toPromiseMethod } from './decorateMethod.js';\n/**\n * # @polkadot/api/promise\n *\n * ## Overview\n *\n * @name ApiPromise\n * @description\n * ApiPromise is a standard JavaScript wrapper around the RPC and interfaces on the Polkadot network. As a full Promise-based, all interface calls return Promises, including the static `.create(...)`. Subscription calls utilise `(value) => {}` callbacks to pass through the latest values.\n *\n * The API is well suited to real-time applications where either the single-shot state is needed or use is to be made of the subscription-based features of Polkadot (and Substrate) clients.\n *\n * @see [[ApiRx]]\n *\n * ## Usage\n *\n * Making rpc calls -\n * <BR>\n *\n * ```javascript\n * import ApiPromise from '@polkadot/api/promise';\n *\n * // initialise via static create\n * const api = await ApiPromise.create();\n *\n * // make a subscription to the network head\n * api.rpc.chain.subscribeNewHeads((header) => {\n *   console.log(`Chain is at #${header.number}`);\n * });\n * ```\n * <BR>\n *\n * Subscribing to chain state -\n * <BR>\n *\n * ```javascript\n * import { ApiPromise, WsProvider } from '@polkadot/api';\n *\n * // initialise a provider with a specific endpoint\n * const provider = new WsProvider('wss://example.com:9944')\n *\n * // initialise via isReady & new with specific provider\n * const api = await new ApiPromise({ provider }).isReady;\n *\n * // retrieve the block target time\n * const blockPeriod = await api.query.timestamp.blockPeriod().toNumber();\n * let last = 0;\n *\n * // subscribe to the current block timestamp, updates automatically (callback provided)\n * api.query.timestamp.now((timestamp) => {\n *   const elapsed = last\n *     ? `, ${timestamp.toNumber() - last}s since last`\n *     : '';\n *\n *   last = timestamp.toNumber();\n *   console.log(`timestamp ${timestamp}${elapsed} (${blockPeriod}s target)`);\n * });\n * ```\n * <BR>\n *\n * Submitting a transaction -\n * <BR>\n *\n * ```javascript\n * import ApiPromise from '@polkadot/api/promise';\n *\n * ApiPromise.create().then((api) => {\n *   const [nonce] = await api.query.system.account(keyring.alice.address);\n *\n *   api.tx.balances\n *     // create transfer\n *     transfer(keyring.bob.address, 12345)\n *     // sign the transcation\n *     .sign(keyring.alice, { nonce })\n *     // send the transaction (optional status callback)\n *     .send((status) => {\n *       console.log(`current status ${status.type}`);\n *     })\n *     // retrieve the submitted extrinsic hash\n *     .then((hash) => {\n *       console.log(`submitted with hash ${hash}`);\n *     });\n * });\n * ```\n */\nexport class ApiPromise extends ApiBase {\n    #isReadyPromise;\n    #isReadyOrErrorPromise;\n    /**\n     * @description Creates an instance of the ApiPromise class\n     * @param options Options to create an instance. This can be either [[ApiOptions]] or\n     * an [[WsProvider]].\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * import Api from '@polkadot/api/promise';\n     *\n     * new Api().isReady.then((api) => {\n     *   api.rpc.subscribeNewHeads((header) => {\n     *     console.log(`new block #${header.number.toNumber()}`);\n     *   });\n     * });\n     * ```\n     */\n    constructor(options) {\n        super(options, 'promise', toPromiseMethod);\n        this.#isReadyPromise = new Promise((resolve) => {\n            super.once('ready', () => resolve(this));\n        });\n        this.#isReadyOrErrorPromise = new Promise((resolve, reject) => {\n            const tracker = promiseTracker(resolve, reject);\n            super.once('ready', () => tracker.resolve(this));\n            super.once('error', (error) => tracker.reject(error));\n        });\n    }\n    /**\n     * @description Creates an ApiPromise instance using the supplied provider. Returns an Promise containing the actual Api instance.\n     * @param options options that is passed to the class contructor. Can be either [[ApiOptions]] or a\n     * provider (see the constructor arguments)\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * import Api from '@polkadot/api/promise';\n     *\n     * Api.create().then(async (api) => {\n     *   const timestamp = await api.query.timestamp.now();\n     *\n     *   console.log(`lastest block timestamp ${timestamp}`);\n     * });\n     * ```\n     */\n    static create(options) {\n        const instance = new ApiPromise(options);\n        if (options && options.throwOnConnect) {\n            return instance.isReadyOrError;\n        }\n        // Swallow any rejections on isReadyOrError\n        // (in Node 15.x this creates issues, when not being looked at)\n        instance.isReadyOrError.catch(noop);\n        return instance.isReady;\n    }\n    /**\n     * @description Promise that resolves the first time we are connected and loaded\n     */\n    get isReady() {\n        return this.#isReadyPromise;\n    }\n    /**\n     * @description Promise that resolves if we can connect, or reject if there is an error\n     */\n    get isReadyOrError() {\n        return this.#isReadyOrErrorPromise;\n    }\n    /**\n     * @description Returns a clone of this ApiPromise instance (new underlying provider connection)\n     */\n    clone() {\n        return new ApiPromise(objectSpread({}, this._options, { source: this }));\n    }\n    /**\n     * @description Creates a combinator that can be used to combine the latest results from multiple subscriptions\n     * @param fns An array of function to combine, each in the form of `(cb: (value: void)) => void`\n     * @param callback A callback that will return an Array of all the values this combinator has been applied to\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * const address = '5DTestUPts3kjeXSTMyerHihn1uwMfLj8vU8sqF7qYrFacT7';\n     *\n     * // combines values from balance & nonce as it updates\n     * api.combineLatest([\n     *   api.rpc.chain.subscribeNewHeads,\n     *   (cb) => api.query.system.account(address, cb)\n     * ], ([head, [balance, nonce]]) => {\n     *   console.log(`#${head.number}: You have ${balance.free} units, with ${nonce} transactions sent`);\n     * });\n     * ```\n     */\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async combineLatest(fns, callback) {\n        const combinator = new Combinator(fns, callback);\n        return () => {\n            combinator.unsubscribe();\n        };\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AACA;AACA;;;;;AAqFO,MAAM,mBAAmB,6JAAO;IACnC,CAAA,cAAe,CAAC;IAChB,CAAA,qBAAsB,CAAC;IACvB;;;;;;;;;;;;;;;;KAgBC,GACD,YAAY,OAAO,CAAE;QACjB,KAAK,CAAC,SAAS,WAAW,iLAAe;QACzC,IAAI,CAAC,CAAA,cAAe,GAAG,IAAI,QAAQ,CAAC;YAChC,KAAK,CAAC,KAAK,SAAS,IAAM,QAAQ,IAAI;QAC1C;QACA,IAAI,CAAC,CAAA,qBAAsB,GAAG,IAAI,QAAQ,CAAC,SAAS;YAChD,MAAM,UAAU,IAAA,gLAAc,EAAC,SAAS;YACxC,KAAK,CAAC,KAAK,SAAS,IAAM,QAAQ,OAAO,CAAC,IAAI;YAC9C,KAAK,CAAC,KAAK,SAAS,CAAC,QAAU,QAAQ,MAAM,CAAC;QAClD;IACJ;IACA;;;;;;;;;;;;;;;;KAgBC,GACD,OAAO,OAAO,OAAO,EAAE;QACnB,MAAM,WAAW,IAAI,WAAW;QAChC,IAAI,WAAW,QAAQ,cAAc,EAAE;YACnC,OAAO,SAAS,cAAc;QAClC;QACA,2CAA2C;QAC3C,+DAA+D;QAC/D,SAAS,cAAc,CAAC,KAAK,CAAC,kJAAI;QAClC,OAAO,SAAS,OAAO;IAC3B;IACA;;KAEC,GACD,IAAI,UAAU;QACV,OAAO,IAAI,CAAC,CAAA,cAAe;IAC/B;IACA;;KAEC,GACD,IAAI,iBAAiB;QACjB,OAAO,IAAI,CAAC,CAAA,qBAAsB;IACtC;IACA;;KAEC,GACD,QAAQ;QACJ,OAAO,IAAI,WAAW,IAAA,sKAAY,EAAC,CAAC,GAAG,IAAI,CAAC,QAAQ,EAAE;YAAE,QAAQ,IAAI;QAAC;IACzE;IACA;;;;;;;;;;;;;;;;;;KAkBC,GACD,4DAA4D;IAC5D,MAAM,cAAc,GAAG,EAAE,QAAQ,EAAE;QAC/B,MAAM,aAAa,IAAI,wKAAU,CAAC,KAAK;QACvC,OAAO;YACH,WAAW,WAAW;QAC1B;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2535, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 2542, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/api/rx/decorateMethod.js"],"sourcesContent":["export function toRxMethod(method) {\n    return method;\n}\n"],"names":[],"mappings":";;;;AAAO,SAAS,WAAW,MAAM;IAC7B,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2553, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/api/rx/Api.js"],"sourcesContent":["import { from } from 'rxjs';\nimport { objectSpread } from '@polkadot/util';\nimport { ApiBase } from '../base/index.js';\nimport { toRxMethod } from './decorateMethod.js';\n/**\n * # @polkadot/api/rx\n *\n * ## Overview\n *\n * @name ApiRx\n *\n * @description\n * ApiRx is a powerful RxJS Observable wrapper around the RPC and interfaces on the Polkadot network. As a full Observable API, all interface calls return RxJS Observables, including the static `.create(...)`. In the same fashion and subscription-based methods return long-running Observables that update with the latest values.\n *\n * The API is well suited to real-time applications where the latest state is needed, unlocking the subscription-based features of Polkadot (and Substrate) clients. Some familiarity with RxJS is a requirement to use the API, however just understanding `.subscribe` and `.pipe` on Observables will unlock full-scale use thereof.\n *\n * @see [[ApiPromise]]\n *\n * ## Usage\n *\n * Making rpc calls -\n * <BR>\n *\n * ```javascript\n * import ApiRx from '@polkadot/api/rx';\n *\n * // initialize via Promise & static create\n * const api = await ApiRx.create().toPromise();\n *\n * // make a call to retrieve the current network head\n * api.rpc.chain.subscribeNewHeads().subscribe((header) => {\n *   console.log(`Chain is at #${header.number}`);\n * });\n * ```\n * <BR>\n *\n * Subscribing to chain state -\n * <BR>\n *\n * ```javascript\n * import { combineLatest, pairwise, switchMap } from 'rxjs';\n * import { ApiRx, WsProvider } from '@polkadot/api';\n *\n *\n * // initialize a provider with a specific endpoint\n * const provider = new WsProvider('wss://example.com:9944')\n *\n * // initialize via isReady & new with specific provider\n * new ApiRx({ provider })\n *   .isReady\n *   .pipe(\n *     switchMap((api) =>\n *       combineLatest([\n *         api.query.timestamp.blockPeriod(),\n *         api.query.timestamp.now().pipe(pairwise())\n *       ])\n *     )\n *   )\n *   .subscribe(([blockPeriod, timestamp]) => {\n *      const elapsed = timestamp[1].toNumber() - timestamp[0].toNumber();\n *      console.log(`timestamp ${timestamp[1]} \\nelapsed ${elapsed} \\n(${blockPeriod}s target)`);\n *   });\n * ```\n * <BR>\n *\n * Submitting a transaction -\n * <BR>\n *\n * ```javascript\n * import { first, switchMap } from 'rxjs';\n * import ApiRx from '@polkadot/api/rx';\n *\n * // import the test keyring (already has dev keys for Alice, Bob, Charlie, Eve & Ferdie)\n * import testingPairs from '@polkadot/keyring/testingPairs';\n * const keyring = testingPairs();\n *\n * // get api via Promise\n * const api = await ApiRx.create().toPromise();\n *\n * // retrieve nonce for the account\n * api.query.system\n *   .account(keyring.alice.address)\n *   .pipe(\n *      first(),\n *      // pipe nonce into transfer\n *      switchMap(([nonce]) =>\n *        api.tx.balances\n *          // create transfer\n *          .transferAllowDeath(keyring.bob.address, 12345)\n *          // sign the transaction\n *          .sign(keyring.alice, { nonce })\n *          // send the transaction\n *          .send()\n *      )\n *   )\n *   // subscribe to overall result\n *   .subscribe(({ status }) => {\n *     if (status.isInBlock) {\n *       console.log('Completed at block hash', status.asFinalized.toHex());\n *     }\n *   });\n * ```\n */\nexport class ApiRx extends ApiBase {\n    #isReadyRx;\n    /**\n     * @description Create an instance of the ApiRx class\n     * @param options Options to create an instance. Can be either [[ApiOptions]] or [[WsProvider]]\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * import { switchMap } from 'rxjs';\n     * import Api from '@polkadot/api/rx';\n     *\n     * new Api().isReady\n     *   .pipe(\n     *     switchMap((api) =>\n     *       api.rpc.chain.subscribeNewHeads()\n     *   ))\n     *   .subscribe((header) => {\n     *     console.log(`new block #${header.number.toNumber()}`);\n     *   });\n     * ```\n     */\n    constructor(options) {\n        super(options, 'rxjs', toRxMethod);\n        this.#isReadyRx = from(\n        // You can create an observable from an event, however my mind groks this form better\n        new Promise((resolve) => {\n            super.on('ready', () => resolve(this));\n        }));\n    }\n    /**\n     * @description Creates an ApiRx instance using the supplied provider. Returns an Observable containing the actual Api instance.\n     * @param options options that is passed to the class constructor. Can be either [[ApiOptions]] or [[WsProvider]]\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * import { switchMap } from 'rxjs';\n     * import Api from '@polkadot/api/rx';\n     *\n     * Api.create()\n     *   .pipe(\n     *     switchMap((api) =>\n     *       api.rpc.chain.subscribeNewHeads()\n     *   ))\n     *   .subscribe((header) => {\n     *     console.log(`new block #${header.number.toNumber()}`);\n     *   });\n     * ```\n     */\n    static create(options) {\n        return new ApiRx(options).isReady;\n    }\n    /**\n     * @description Observable that returns the first time we are connected and loaded\n     */\n    get isReady() {\n        return this.#isReadyRx;\n    }\n    /**\n     * @description Returns a clone of this ApiRx instance (new underlying provider connection)\n     */\n    clone() {\n        return new ApiRx(objectSpread({}, this._options, { source: this }));\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAoGO,MAAM,cAAc,6JAAO;IAC9B,CAAA,SAAU,CAAC;IACX;;;;;;;;;;;;;;;;;;;KAmBC,GACD,YAAY,OAAO,CAAE;QACjB,KAAK,CAAC,SAAS,QAAQ,uKAAU;QACjC,IAAI,CAAC,CAAA,SAAU,GAAG,IAAA,oJAAI,EACtB,qFAAqF;QACrF,IAAI,QAAQ,CAAC;YACT,KAAK,CAAC,GAAG,SAAS,IAAM,QAAQ,IAAI;QACxC;IACJ;IACA;;;;;;;;;;;;;;;;;;;KAmBC,GACD,OAAO,OAAO,OAAO,EAAE;QACnB,OAAO,IAAI,MAAM,SAAS,OAAO;IACrC;IACA;;KAEC,GACD,IAAI,UAAU;QACV,OAAO,IAAI,CAAC,CAAA,SAAU;IAC1B;IACA;;KAEC,GACD,QAAQ;QACJ,OAAO,IAAI,MAAM,IAAA,sKAAY,EAAC,CAAC,GAAG,IAAI,CAAC,QAAQ,EAAE;YAAE,QAAQ,IAAI;QAAC;IACpE;AACJ","ignoreList":[0],"debugId":null}}]
}