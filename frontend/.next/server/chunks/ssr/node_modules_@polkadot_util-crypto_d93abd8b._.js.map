{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/base32/helpers.js"],"sourcesContent":["import { u8aToU8a } from '@polkadot/util';\n/** @internal */\nexport function createDecode({ coder, ipfs }, validate) {\n    return (value, ipfsCompat) => {\n        validate(value, ipfsCompat);\n        return coder.decode(ipfs && ipfsCompat\n            ? value.substring(1)\n            : value);\n    };\n}\n/** @internal */\nexport function createEncode({ coder, ipfs }) {\n    return (value, ipfsCompat) => {\n        const out = coder.encode(u8aToU8a(value));\n        return ipfs && ipfsCompat\n            ? `${ipfs}${out}`\n            : out;\n    };\n}\n/** @internal */\nexport function createIs(validate) {\n    return (value, ipfsCompat) => {\n        try {\n            return validate(value, ipfsCompat);\n        }\n        catch {\n            return false;\n        }\n    };\n}\n/** @internal */\nexport function createValidate({ chars, ipfs, type, withPadding }) {\n    return (value, ipfsCompat) => {\n        if (typeof value !== 'string') {\n            throw new Error(`Expected ${type} string input`);\n        }\n        else if (ipfs && ipfsCompat && !value.startsWith(ipfs)) {\n            throw new Error(`Expected ipfs-compatible ${type} to start with '${ipfs}'`);\n        }\n        for (let i = (ipfsCompat ? 1 : 0), count = value.length; i < count; i++) {\n            if (chars.includes(value[i])) {\n                // all ok, character found\n            }\n            else if (withPadding && value[i] === '=') {\n                if (i === count - 1) {\n                    // last character, everything ok\n                }\n                else if (value[i + 1] === '=') {\n                    // next one is also padding, sequence ok\n                }\n                else {\n                    throw new Error(`Invalid ${type} padding sequence \"${value[i]}${value[i + 1]}\" at index ${i}`);\n                }\n            }\n            else {\n                throw new Error(`Invalid ${type} character \"${value[i]}\" (0x${value.charCodeAt(i).toString(16)}) at index ${i}`);\n            }\n        }\n        return true;\n    };\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;AAEO,SAAS,aAAa,EAAE,KAAK,EAAE,IAAI,EAAE,EAAE,QAAQ;IAClD,OAAO,CAAC,OAAO;QACX,SAAS,OAAO;QAChB,OAAO,MAAM,MAAM,CAAC,QAAQ,aACtB,MAAM,SAAS,CAAC,KAChB;IACV;AACJ;AAEO,SAAS,aAAa,EAAE,KAAK,EAAE,IAAI,EAAE;IACxC,OAAO,CAAC,OAAO;QACX,MAAM,MAAM,MAAM,MAAM,CAAC,IAAA,8JAAQ,EAAC;QAClC,OAAO,QAAQ,aACT,GAAG,OAAO,KAAK,GACf;IACV;AACJ;AAEO,SAAS,SAAS,QAAQ;IAC7B,OAAO,CAAC,OAAO;QACX,IAAI;YACA,OAAO,SAAS,OAAO;QAC3B,EACA,OAAM;YACF,OAAO;QACX;IACJ;AACJ;AAEO,SAAS,eAAe,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,WAAW,EAAE;IAC7D,OAAO,CAAC,OAAO;QACX,IAAI,OAAO,UAAU,UAAU;YAC3B,MAAM,IAAI,MAAM,CAAC,SAAS,EAAE,KAAK,aAAa,CAAC;QACnD,OACK,IAAI,QAAQ,cAAc,CAAC,MAAM,UAAU,CAAC,OAAO;YACpD,MAAM,IAAI,MAAM,CAAC,yBAAyB,EAAE,KAAK,gBAAgB,EAAE,KAAK,CAAC,CAAC;QAC9E;QACA,IAAK,IAAI,IAAK,aAAa,IAAI,GAAI,QAAQ,MAAM,MAAM,EAAE,IAAI,OAAO,IAAK;YACrE,IAAI,MAAM,QAAQ,CAAC,KAAK,CAAC,EAAE,GAAG;YAC1B,0BAA0B;YAC9B,OACK,IAAI,eAAe,KAAK,CAAC,EAAE,KAAK,KAAK;gBACtC,IAAI,MAAM,QAAQ,GAAG;gBACjB,gCAAgC;gBACpC,OACK,IAAI,KAAK,CAAC,IAAI,EAAE,KAAK,KAAK;gBAC3B,wCAAwC;gBAC5C,OACK;oBACD,MAAM,IAAI,MAAM,CAAC,QAAQ,EAAE,KAAK,mBAAmB,EAAE,KAAK,CAAC,EAAE,GAAG,KAAK,CAAC,IAAI,EAAE,CAAC,WAAW,EAAE,GAAG;gBACjG;YACJ,OACK;gBACD,MAAM,IAAI,MAAM,CAAC,QAAQ,EAAE,KAAK,YAAY,EAAE,KAAK,CAAC,EAAE,CAAC,KAAK,EAAE,MAAM,UAAU,CAAC,GAAG,QAAQ,CAAC,IAAI,WAAW,EAAE,GAAG;YACnH;QACJ;QACA,OAAO;IACX;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 66, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/base64/bs64.js"],"sourcesContent":["import { base64 } from '@scure/base';\nimport { createDecode, createEncode, createIs, createValidate } from '../base32/helpers.js';\nconst config = {\n    chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n    coder: base64,\n    type: 'base64',\n    withPadding: true\n};\n/**\n * @name base64Validate\n * @summary Validates a base64 value.\n * @description\n * Validates that the supplied value is valid base64\n */\nexport const base64Validate = /*#__PURE__*/ createValidate(config);\n/**\n * @name isBase64\n * @description Checks if the input is in base64, returning true/false\n */\nexport const isBase64 = /*#__PURE__*/ createIs(base64Validate);\n/**\n * @name base64Decode\n * @summary Decodes a base64 value.\n * @description\n * From the provided input, decode the base64 and return the result as an `Uint8Array`.\n */\nexport const base64Decode = /*#__PURE__*/ createDecode(config, base64Validate);\n/**\n * @name base64Encode\n * @summary Creates a base64 value.\n * @description\n * From the provided input, create the base64 and return the result as a string.\n */\nexport const base64Encode = /*#__PURE__*/ createEncode(config);\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;;;AACA,MAAM,SAAS;IACX,OAAO;IACP,OAAO,gKAAM;IACb,MAAM;IACN,aAAa;AACjB;AAOO,MAAM,iBAAiB,WAAW,GAAG,IAAA,mLAAc,EAAC;AAKpD,MAAM,WAAW,WAAW,GAAG,IAAA,6KAAQ,EAAC;AAOxC,MAAM,eAAe,WAAW,GAAG,IAAA,iLAAY,EAAC,QAAQ;AAOxD,MAAM,eAAe,WAAW,GAAG,IAAA,iLAAY,EAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/base58/bs58.js"],"sourcesContent":["import { base58 } from '@scure/base';\nimport { createDecode, createEncode, createIs, createValidate } from '../base32/helpers.js';\nconst config = {\n    chars: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',\n    coder: base58,\n    ipfs: 'z',\n    type: 'base58'\n};\n/**\n * @name base58Validate\n * @summary Validates a base58 value.\n * @description\n * Validates that the supplied value is valid base58, throwing exceptions if not\n */\nexport const base58Validate = /*#__PURE__*/ createValidate(config);\n/**\n * @name base58Decode\n * @summary Decodes a base58 value.\n * @description\n * From the provided input, decode the base58 and return the result as an `Uint8Array`.\n */\nexport const base58Decode = /*#__PURE__*/ createDecode(config, base58Validate);\n/**\n* @name base58Encode\n* @summary Creates a base58 value.\n* @description\n* From the provided input, create the base58 and return the result as a string.\n*/\nexport const base58Encode = /*#__PURE__*/ createEncode(config);\n/**\n* @name isBase58\n* @description Checks if the input is in base58, returning true/false\n*/\nexport const isBase58 = /*#__PURE__*/ createIs(base58Validate);\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;;;AACA,MAAM,SAAS;IACX,OAAO;IACP,OAAO,gKAAM;IACb,MAAM;IACN,MAAM;AACV;AAOO,MAAM,iBAAiB,WAAW,GAAG,IAAA,mLAAc,EAAC;AAOpD,MAAM,eAAe,WAAW,GAAG,IAAA,iLAAY,EAAC,QAAQ;AAOxD,MAAM,eAAe,WAAW,GAAG,IAAA,iLAAY,EAAC;AAKhD,MAAM,WAAW,WAAW,GAAG,IAAA,6KAAQ,EAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 122, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/helpers.js"],"sourcesContent":["import { hasBigInt, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { isReady } from '@polkadot/wasm-crypto';\n/** @internal */\nexport function createAsHex(fn) {\n    return (...args) => u8aToHex(fn(...args));\n}\n/** @internal */\nexport function createBitHasher(bitLength, fn) {\n    return (data, onlyJs) => fn(data, bitLength, onlyJs);\n}\n/** @internal */\nexport function createDualHasher(wa, js) {\n    return (value, bitLength = 256, onlyJs) => {\n        const u8a = u8aToU8a(value);\n        return !hasBigInt || (!onlyJs && isReady())\n            ? wa[bitLength](u8a)\n            : js[bitLength](u8a);\n    };\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AAAA;AACA;;;AAEO,SAAS,YAAY,EAAE;IAC1B,OAAO,CAAC,GAAG,OAAS,IAAA,8JAAQ,EAAC,MAAM;AACvC;AAEO,SAAS,gBAAgB,SAAS,EAAE,EAAE;IACzC,OAAO,CAAC,MAAM,SAAW,GAAG,MAAM,WAAW;AACjD;AAEO,SAAS,iBAAiB,EAAE,EAAE,EAAE;IACnC,OAAO,CAAC,OAAO,YAAY,GAAG,EAAE;QAC5B,MAAM,MAAM,IAAA,8JAAQ,EAAC;QACrB,OAAO,CAAC,sJAAS,IAAK,CAAC,UAAU,IAAA,iLAAO,MAClC,EAAE,CAAC,UAAU,CAAC,OACd,EAAE,CAAC,UAAU,CAAC;IACxB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 152, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/blake2/asU8a.js"],"sourcesContent":["import { blake2b as blake2bJs } from '@noble/hashes/blake2b';\nimport { hasBigInt, u8aToU8a } from '@polkadot/util';\nimport { blake2b, isReady } from '@polkadot/wasm-crypto';\nimport { createAsHex } from '../helpers.js';\n/**\n * @name blake2AsU8a\n * @summary Creates a blake2b u8a from the input.\n * @description\n * From a `Uint8Array` input, create the blake2b and return the result as a u8a with the specified `bitLength`.\n * @example\n * <BR>\n *\n * ```javascript\n * import { blake2AsU8a } from '@polkadot/util-crypto';\n *\n * blake2AsU8a('abc'); // => [0xba, 0x80, 0xa5, 0x3f, 0x98, 0x1c, 0x4d, 0x0d]\n * ```\n */\nexport function blake2AsU8a(data, bitLength = 256, key, onlyJs) {\n    const byteLength = Math.ceil(bitLength / 8);\n    const u8a = u8aToU8a(data);\n    return !hasBigInt || (!onlyJs && isReady())\n        ? blake2b(u8a, u8aToU8a(key), byteLength)\n        : key\n            ? blake2bJs(u8a, { dkLen: byteLength, key })\n            : blake2bJs(u8a, { dkLen: byteLength });\n}\n/**\n * @name blake2AsHex\n * @description Creates a blake2b hex from the input.\n */\nexport const blake2AsHex = /*#__PURE__*/ createAsHex(blake2AsU8a);\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AAAA;AACA;AACA;;;;;AAeO,SAAS,YAAY,IAAI,EAAE,YAAY,GAAG,EAAE,GAAG,EAAE,MAAM;IAC1D,MAAM,aAAa,KAAK,IAAI,CAAC,YAAY;IACzC,MAAM,MAAM,IAAA,8JAAQ,EAAC;IACrB,OAAO,CAAC,sJAAS,IAAK,CAAC,UAAU,IAAA,iLAAO,MAClC,IAAA,iLAAO,EAAC,KAAK,IAAA,8JAAQ,EAAC,MAAM,cAC5B,MACI,IAAA,8JAAS,EAAC,KAAK;QAAE,OAAO;QAAY;IAAI,KACxC,IAAA,8JAAS,EAAC,KAAK;QAAE,OAAO;IAAW;AACjD;AAKO,MAAM,cAAc,WAAW,GAAG,IAAA,sKAAW,EAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 182, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/address/sshash.js"],"sourcesContent":["import { stringToU8a, u8aConcat } from '@polkadot/util';\nimport { blake2AsU8a } from '../blake2/asU8a.js';\nconst SS58_PREFIX = stringToU8a('SS58PRE');\nexport function sshash(key) {\n    return blake2AsU8a(u8aConcat(SS58_PREFIX, key), 512);\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;;;AACA,MAAM,cAAc,IAAA,oKAAW,EAAC;AACzB,SAAS,OAAO,GAAG;IACtB,OAAO,IAAA,8KAAW,EAAC,IAAA,gKAAS,EAAC,aAAa,MAAM;AACpD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 199, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/address/checksum.js"],"sourcesContent":["import { sshash } from './sshash.js';\nexport function checkAddressChecksum(decoded) {\n    const ss58Length = (decoded[0] & 0b0100_0000) ? 2 : 1;\n    const ss58Decoded = ss58Length === 1\n        ? decoded[0]\n        : ((decoded[0] & 0b0011_1111) << 2) | (decoded[1] >> 6) | ((decoded[1] & 0b0011_1111) << 8);\n    // 32/33 bytes public + 2 bytes checksum + prefix\n    const isPublicKey = [34 + ss58Length, 35 + ss58Length].includes(decoded.length);\n    const length = decoded.length - (isPublicKey ? 2 : 1);\n    // calculate the hash and do the checksum byte checks\n    const hash = sshash(decoded.subarray(0, length));\n    const isValid = (decoded[0] & 0b1000_0000) === 0 && ![46, 47].includes(decoded[0]) && (isPublicKey\n        ? decoded[decoded.length - 2] === hash[0] && decoded[decoded.length - 1] === hash[1]\n        : decoded[decoded.length - 1] === hash[0]);\n    return [isValid, length, ss58Length, ss58Decoded];\n}\n"],"names":[],"mappings":";;;;AAAA;;AACO,SAAS,qBAAqB,OAAO;IACxC,MAAM,aAAa,AAAC,OAAO,CAAC,EAAE,GAAG,cAAe,IAAI;IACpD,MAAM,cAAc,eAAe,IAC7B,OAAO,CAAC,EAAE,GACV,AAAC,CAAC,OAAO,CAAC,EAAE,GAAG,WAAW,KAAK,IAAM,OAAO,CAAC,EAAE,IAAI,IAAM,CAAC,OAAO,CAAC,EAAE,GAAG,WAAW,KAAK;IAC7F,iDAAiD;IACjD,MAAM,cAAc;QAAC,KAAK;QAAY,KAAK;KAAW,CAAC,QAAQ,CAAC,QAAQ,MAAM;IAC9E,MAAM,SAAS,QAAQ,MAAM,GAAG,CAAC,cAAc,IAAI,CAAC;IACpD,qDAAqD;IACrD,MAAM,OAAO,IAAA,2KAAM,EAAC,QAAQ,QAAQ,CAAC,GAAG;IACxC,MAAM,UAAU,CAAC,OAAO,CAAC,EAAE,GAAG,WAAW,MAAM,KAAK,CAAC;QAAC;QAAI;KAAG,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE,KAAK,CAAC,cACjF,OAAO,CAAC,QAAQ,MAAM,GAAG,EAAE,KAAK,IAAI,CAAC,EAAE,IAAI,OAAO,CAAC,QAAQ,MAAM,GAAG,EAAE,KAAK,IAAI,CAAC,EAAE,GAClF,OAAO,CAAC,QAAQ,MAAM,GAAG,EAAE,KAAK,IAAI,CAAC,EAAE;IAC7C,OAAO;QAAC;QAAS;QAAQ;QAAY;KAAY;AACrD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 231, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/address/defaults.js"],"sourcesContent":["import { availableNetworks } from '../networks.js';\nexport const defaults = {\n    allowedDecodedLengths: [1, 2, 4, 8, 32, 33],\n    // publicKey has prefix + 2 checksum bytes, short only prefix + 1 checksum byte\n    allowedEncodedLengths: [3, 4, 6, 10, 35, 36, 37, 38],\n    allowedPrefix: availableNetworks.map(({ prefix }) => prefix),\n    prefix: 42\n};\n"],"names":[],"mappings":";;;;AAAA;;AACO,MAAM,WAAW;IACpB,uBAAuB;QAAC;QAAG;QAAG;QAAG;QAAG;QAAI;KAAG;IAC3C,+EAA+E;IAC/E,uBAAuB;QAAC;QAAG;QAAG;QAAG;QAAI;QAAI;QAAI;QAAI;KAAG;IACpD,eAAe,yKAAiB,CAAC,GAAG,CAAC,CAAC,EAAE,MAAM,EAAE,GAAK;IACrD,QAAQ;AACZ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 264, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/address/decode.js"],"sourcesContent":["import { isHex, isU8a, u8aToU8a } from '@polkadot/util';\nimport { base58Decode } from '../base58/index.js';\nimport { checkAddressChecksum } from './checksum.js';\nimport { defaults } from './defaults.js';\nexport function decodeAddress(encoded, ignoreChecksum, ss58Format = -1) {\n    if (!encoded) {\n        throw new Error('Invalid empty address passed');\n    }\n    if (isU8a(encoded) || isHex(encoded)) {\n        return u8aToU8a(encoded);\n    }\n    try {\n        const decoded = base58Decode(encoded);\n        if (!defaults.allowedEncodedLengths.includes(decoded.length)) {\n            throw new Error('Invalid decoded address length');\n        }\n        const [isValid, endPos, ss58Length, ss58Decoded] = checkAddressChecksum(decoded);\n        if (!isValid && !ignoreChecksum) {\n            throw new Error('Invalid decoded address checksum');\n        }\n        else if (ss58Format !== -1 && ss58Format !== ss58Decoded) {\n            throw new Error(`Expected ss58Format ${ss58Format}, received ${ss58Decoded}`);\n        }\n        return decoded.slice(ss58Length, endPos);\n    }\n    catch (error) {\n        throw new Error(`Decoding ${encoded}: ${error.message}`);\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;AACO,SAAS,cAAc,OAAO,EAAE,cAAc,EAAE,aAAa,CAAC,CAAC;IAClE,IAAI,CAAC,SAAS;QACV,MAAM,IAAI,MAAM;IACpB;IACA,IAAI,IAAA,wJAAK,EAAC,YAAY,IAAA,wJAAK,EAAC,UAAU;QAClC,OAAO,IAAA,8JAAQ,EAAC;IACpB;IACA,IAAI;QACA,MAAM,UAAU,IAAA,8KAAY,EAAC;QAC7B,IAAI,CAAC,+KAAQ,CAAC,qBAAqB,CAAC,QAAQ,CAAC,QAAQ,MAAM,GAAG;YAC1D,MAAM,IAAI,MAAM;QACpB;QACA,MAAM,CAAC,SAAS,QAAQ,YAAY,YAAY,GAAG,IAAA,2LAAoB,EAAC;QACxE,IAAI,CAAC,WAAW,CAAC,gBAAgB;YAC7B,MAAM,IAAI,MAAM;QACpB,OACK,IAAI,eAAe,CAAC,KAAK,eAAe,aAAa;YACtD,MAAM,IAAI,MAAM,CAAC,oBAAoB,EAAE,WAAW,WAAW,EAAE,aAAa;QAChF;QACA,OAAO,QAAQ,KAAK,CAAC,YAAY;IACrC,EACA,OAAO,OAAO;QACV,MAAM,IAAI,MAAM,CAAC,SAAS,EAAE,QAAQ,EAAE,EAAE,MAAM,OAAO,EAAE;IAC3D;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 305, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/ed25519/pair/fromSeed.js"],"sourcesContent":["import { ed25519 } from '@noble/curves/ed25519';\nimport { hasBigInt, u8aConcatStrict } from '@polkadot/util';\nimport { ed25519KeypairFromSeed, isReady } from '@polkadot/wasm-crypto';\n/**\n * @name ed25519PairFromSeed\n * @summary Creates a new public/secret keypair from a seed.\n * @description\n * Returns a object containing a `publicKey` & `secretKey` generated from the supplied seed.\n * @example\n * <BR>\n *\n * ```javascript\n * import { ed25519PairFromSeed } from '@polkadot/util-crypto';\n *\n * ed25519PairFromSeed(...); // => { secretKey: [...], publicKey: [...] }\n * ```\n */\nexport function ed25519PairFromSeed(seed, onlyJs) {\n    if (!hasBigInt || (!onlyJs && isReady())) {\n        const full = ed25519KeypairFromSeed(seed);\n        return {\n            publicKey: full.slice(32),\n            secretKey: full.slice(0, 64)\n        };\n    }\n    const publicKey = ed25519.getPublicKey(seed);\n    return {\n        publicKey,\n        secretKey: u8aConcatStrict([seed, publicKey])\n    };\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AAAA;AACA;;;;AAeO,SAAS,oBAAoB,IAAI,EAAE,MAAM;IAC5C,IAAI,CAAC,sJAAS,IAAK,CAAC,UAAU,IAAA,iLAAO,KAAK;QACtC,MAAM,OAAO,IAAA,gMAAsB,EAAC;QACpC,OAAO;YACH,WAAW,KAAK,KAAK,CAAC;YACtB,WAAW,KAAK,KAAK,CAAC,GAAG;QAC7B;IACJ;IACA,MAAM,YAAY,8JAAO,CAAC,YAAY,CAAC;IACvC,OAAO;QACH;QACA,WAAW,IAAA,sKAAe,EAAC;YAAC;YAAM;SAAU;IAChD;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 337, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/address/encode.js"],"sourcesContent":["import { u8aConcat } from '@polkadot/util';\nimport { base58Encode } from '../base58/index.js';\nimport { decodeAddress } from './decode.js';\nimport { defaults } from './defaults.js';\nimport { sshash } from './sshash.js';\nexport function encodeAddress(key, ss58Format = defaults.prefix) {\n    // decode it, this means we can re-encode an address\n    const u8a = decodeAddress(key);\n    if ((ss58Format < 0) || (ss58Format > 16383 && !ss58Exceptions.includes(ss58Format)) || [46, 47].includes(ss58Format)) {\n        throw new Error('Out of range ss58Format specified');\n    }\n    else if (!defaults.allowedDecodedLengths.includes(u8a.length)) {\n        throw new Error(`Expected a valid key to convert, with length ${defaults.allowedDecodedLengths.join(', ')}`);\n    }\n    const input = u8aConcat(ss58Format < 64\n        ? [ss58Format]\n        : [\n            ((ss58Format & 0b0000_0000_1111_1100) >> 2) | 0b0100_0000,\n            (ss58Format >> 8) | ((ss58Format & 0b0000_0000_0000_0011) << 6)\n        ], u8a);\n    return base58Encode(u8aConcat(input, sshash(input).subarray(0, [32, 33].includes(u8a.length) ? 2 : 1)));\n}\nconst ss58Exceptions = [29972];\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AACO,SAAS,cAAc,GAAG,EAAE,aAAa,+KAAQ,CAAC,MAAM;IAC3D,oDAAoD;IACpD,MAAM,MAAM,IAAA,kLAAa,EAAC;IAC1B,IAAI,AAAC,aAAa,KAAO,aAAa,SAAS,CAAC,eAAe,QAAQ,CAAC,eAAgB;QAAC;QAAI;KAAG,CAAC,QAAQ,CAAC,aAAa;QACnH,MAAM,IAAI,MAAM;IACpB,OACK,IAAI,CAAC,+KAAQ,CAAC,qBAAqB,CAAC,QAAQ,CAAC,IAAI,MAAM,GAAG;QAC3D,MAAM,IAAI,MAAM,CAAC,6CAA6C,EAAE,+KAAQ,CAAC,qBAAqB,CAAC,IAAI,CAAC,OAAO;IAC/G;IACA,MAAM,QAAQ,IAAA,gKAAS,EAAC,aAAa,KAC/B;QAAC;KAAW,GACZ;QACG,CAAC,aAAa,qBAAqB,KAAK,IAAK;QAC7C,cAAc,IAAM,CAAC,aAAa,qBAAqB,KAAK;KAChE,EAAE;IACP,OAAO,IAAA,8KAAY,EAAC,IAAA,gKAAS,EAAC,OAAO,IAAA,2KAAM,EAAC,OAAO,QAAQ,CAAC,GAAG;QAAC;QAAI;KAAG,CAAC,QAAQ,CAAC,IAAI,MAAM,IAAI,IAAI;AACvG;AACA,MAAM,iBAAiB;IAAC;CAAM","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 380, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/keccak/asU8a.js"],"sourcesContent":["import { keccak_256 as keccak256Js, keccak_512 as keccak512Js } from '@noble/hashes/sha3';\nimport { keccak256, keccak512 } from '@polkadot/wasm-crypto';\nimport { createAsHex, createBitHasher, createDualHasher } from '../helpers.js';\n/**\n * @name keccakAsU8a\n * @summary Creates a keccak Uint8Array from the input.\n * @description\n * From either a `string` or a `Buffer` input, create the keccak and return the result as a `Uint8Array`.\n * @example\n * <BR>\n *\n * ```javascript\n * import { keccakAsU8a } from '@polkadot/util-crypto';\n *\n * keccakAsU8a('123'); // => Uint8Array\n * ```\n */\nexport const keccakAsU8a = /*#__PURE__*/ createDualHasher({ 256: keccak256, 512: keccak512 }, { 256: keccak256Js, 512: keccak512Js });\n/**\n * @name keccak256AsU8a\n * @description Creates a keccak256 Uint8Array from the input.\n */\nexport const keccak256AsU8a = /*#__PURE__*/ createBitHasher(256, keccakAsU8a);\n/**\n * @name keccak512AsU8a\n * @description Creates a keccak512 Uint8Array from the input.\n */\nexport const keccak512AsU8a = /*#__PURE__*/ createBitHasher(512, keccakAsU8a);\n/**\n * @name keccakAsHex\n * @description Creates a keccak hex string from the input.\n */\nexport const keccakAsHex = /*#__PURE__*/ createAsHex(keccakAsU8a);\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AACA;;;;AAeO,MAAM,cAAc,WAAW,GAAG,IAAA,2KAAgB,EAAC;IAAE,KAAK,mLAAS;IAAE,KAAK,mLAAS;AAAC,GAAG;IAAE,KAAK,8JAAW;IAAE,KAAK,8JAAW;AAAC;AAK5H,MAAM,iBAAiB,WAAW,GAAG,IAAA,0KAAe,EAAC,KAAK;AAK1D,MAAM,iBAAiB,WAAW,GAAG,IAAA,0KAAe,EAAC,KAAK;AAK1D,MAAM,cAAc,WAAW,GAAG,IAAA,sKAAW,EAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 410, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/bn.js"],"sourcesContent":["export const BN_BE_OPTS = { isLe: false };\nexport const BN_LE_OPTS = { isLe: true };\nexport const BN_LE_16_OPTS = { bitLength: 16, isLe: true };\nexport const BN_BE_32_OPTS = { bitLength: 32, isLe: false };\nexport const BN_LE_32_OPTS = { bitLength: 32, isLe: true };\nexport const BN_BE_256_OPTS = { bitLength: 256, isLe: false };\nexport const BN_LE_256_OPTS = { bitLength: 256, isLe: true };\nexport const BN_LE_512_OPTS = { bitLength: 512, isLe: true };\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAO,MAAM,aAAa;IAAE,MAAM;AAAM;AACjC,MAAM,aAAa;IAAE,MAAM;AAAK;AAChC,MAAM,gBAAgB;IAAE,WAAW;IAAI,MAAM;AAAK;AAClD,MAAM,gBAAgB;IAAE,WAAW;IAAI,MAAM;AAAM;AACnD,MAAM,gBAAgB;IAAE,WAAW;IAAI,MAAM;AAAK;AAClD,MAAM,iBAAiB;IAAE,WAAW;IAAK,MAAM;AAAM;AACrD,MAAM,iBAAiB;IAAE,WAAW;IAAK,MAAM;AAAK;AACpD,MAAM,iBAAiB;IAAE,WAAW;IAAK,MAAM;AAAK","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 462, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/secp256k1/expand.js"],"sourcesContent":["import { secp256k1 } from '@noble/curves/secp256k1';\nimport { bnToU8a, hasBigInt, u8aConcat } from '@polkadot/util';\nimport { isReady, secp256k1Expand as wasm } from '@polkadot/wasm-crypto';\nimport { BN_BE_256_OPTS } from '../bn.js';\nexport function secp256k1Expand(publicKey, onlyJs) {\n    if (![33, 65].includes(publicKey.length)) {\n        throw new Error(`Invalid publicKey provided, received ${publicKey.length} bytes input`);\n    }\n    if (publicKey.length === 65) {\n        return publicKey.subarray(1);\n    }\n    if (!hasBigInt || (!onlyJs && isReady())) {\n        return wasm(publicKey).subarray(1);\n    }\n    const { px, py } = secp256k1.ProjectivePoint.fromHex(publicKey);\n    return u8aConcat(bnToU8a(px, BN_BE_256_OPTS), bnToU8a(py, BN_BE_256_OPTS));\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AAAA;AAAA;AACA;AACA;;;;;AACO,SAAS,gBAAgB,SAAS,EAAE,MAAM;IAC7C,IAAI,CAAC;QAAC;QAAI;KAAG,CAAC,QAAQ,CAAC,UAAU,MAAM,GAAG;QACtC,MAAM,IAAI,MAAM,CAAC,qCAAqC,EAAE,UAAU,MAAM,CAAC,YAAY,CAAC;IAC1F;IACA,IAAI,UAAU,MAAM,KAAK,IAAI;QACzB,OAAO,UAAU,QAAQ,CAAC;IAC9B;IACA,IAAI,CAAC,sJAAS,IAAK,CAAC,UAAU,IAAA,iLAAO,KAAK;QACtC,OAAO,IAAA,yLAAI,EAAC,WAAW,QAAQ,CAAC;IACpC;IACA,MAAM,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,kKAAS,CAAC,eAAe,CAAC,OAAO,CAAC;IACrD,OAAO,IAAA,gKAAS,EAAC,IAAA,4JAAO,EAAC,IAAI,oKAAc,GAAG,IAAA,4JAAO,EAAC,IAAI,oKAAc;AAC5E","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 496, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/ethereum/encode.js"],"sourcesContent":["import { u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { keccakAsU8a } from '../keccak/index.js';\nimport { secp256k1Expand } from '../secp256k1/index.js';\nfunction getH160(u8a) {\n    if ([33, 65].includes(u8a.length)) {\n        u8a = keccakAsU8a(secp256k1Expand(u8a));\n    }\n    return u8a.slice(-20);\n}\nexport function ethereumEncode(addressOrPublic) {\n    if (!addressOrPublic) {\n        return '0x';\n    }\n    const u8aAddress = u8aToU8a(addressOrPublic);\n    if (![20, 32, 33, 65].includes(u8aAddress.length)) {\n        throw new Error(`Invalid address or publicKey provided, received ${u8aAddress.length} bytes input`);\n    }\n    const address = u8aToHex(getH160(u8aAddress), -1, false);\n    const hash = u8aToHex(keccakAsU8a(address), -1, false);\n    let result = '';\n    for (let i = 0; i < 40; i++) {\n        result = `${result}${parseInt(hash[i], 16) > 7 ? address[i].toUpperCase() : address[i]}`;\n    }\n    return `0x${result}`;\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AACA;;;;AACA,SAAS,QAAQ,GAAG;IAChB,IAAI;QAAC;QAAI;KAAG,CAAC,QAAQ,CAAC,IAAI,MAAM,GAAG;QAC/B,MAAM,IAAA,8KAAW,EAAC,IAAA,sLAAe,EAAC;IACtC;IACA,OAAO,IAAI,KAAK,CAAC,CAAC;AACtB;AACO,SAAS,eAAe,eAAe;IAC1C,IAAI,CAAC,iBAAiB;QAClB,OAAO;IACX;IACA,MAAM,aAAa,IAAA,8JAAQ,EAAC;IAC5B,IAAI,CAAC;QAAC;QAAI;QAAI;QAAI;KAAG,CAAC,QAAQ,CAAC,WAAW,MAAM,GAAG;QAC/C,MAAM,IAAI,MAAM,CAAC,gDAAgD,EAAE,WAAW,MAAM,CAAC,YAAY,CAAC;IACtG;IACA,MAAM,UAAU,IAAA,8JAAQ,EAAC,QAAQ,aAAa,CAAC,GAAG;IAClD,MAAM,OAAO,IAAA,8JAAQ,EAAC,IAAA,8KAAW,EAAC,UAAU,CAAC,GAAG;IAChD,IAAI,SAAS;IACb,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,IAAK;QACzB,SAAS,GAAG,SAAS,SAAS,IAAI,CAAC,EAAE,EAAE,MAAM,IAAI,OAAO,CAAC,EAAE,CAAC,WAAW,KAAK,OAAO,CAAC,EAAE,EAAE;IAC5F;IACA,OAAO,CAAC,EAAE,EAAE,QAAQ;AACxB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 541, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/hmac/shaAsU8a.js"],"sourcesContent":["import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { sha512 } from '@noble/hashes/sha512';\nimport { hasBigInt, u8aToU8a } from '@polkadot/util';\nimport { hmacSha256, hmacSha512, isReady } from '@polkadot/wasm-crypto';\nconst JS_HASH = {\n    256: sha256,\n    512: sha512\n};\nconst WA_MHAC = {\n    256: hmacSha256,\n    512: hmacSha512\n};\nfunction createSha(bitLength) {\n    return (key, data, onlyJs) => hmacShaAsU8a(key, data, bitLength, onlyJs);\n}\n/**\n * @name hmacShaAsU8a\n * @description creates a Hmac Sha (256/512) Uint8Array from the key & data\n */\nexport function hmacShaAsU8a(key, data, bitLength = 256, onlyJs) {\n    const u8aKey = u8aToU8a(key);\n    return !hasBigInt || (!onlyJs && isReady())\n        ? WA_MHAC[bitLength](u8aKey, data)\n        : hmac(JS_HASH[bitLength], u8aKey, data);\n}\n/**\n * @name hmacSha256AsU8a\n * @description creates a Hmac Sha256 Uint8Array from the key & data\n */\nexport const hmacSha256AsU8a = /*#__PURE__*/ createSha(256);\n/**\n * @name hmacSha512AsU8a\n * @description creates a Hmac Sha512 Uint8Array from the key & data\n */\nexport const hmacSha512AsU8a = /*#__PURE__*/ createSha(512);\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AAAA;AACA;;;;;;AACA,MAAM,UAAU;IACZ,KAAK,4JAAM;IACX,KAAK,4JAAM;AACf;AACA,MAAM,UAAU;IACZ,KAAK,oLAAU;IACf,KAAK,oLAAU;AACnB;AACA,SAAS,UAAU,SAAS;IACxB,OAAO,CAAC,KAAK,MAAM,SAAW,aAAa,KAAK,MAAM,WAAW;AACrE;AAKO,SAAS,aAAa,GAAG,EAAE,IAAI,EAAE,YAAY,GAAG,EAAE,MAAM;IAC3D,MAAM,SAAS,IAAA,8JAAQ,EAAC;IACxB,OAAO,CAAC,sJAAS,IAAK,CAAC,UAAU,IAAA,iLAAO,MAClC,OAAO,CAAC,UAAU,CAAC,QAAQ,QAC3B,IAAA,wJAAI,EAAC,OAAO,CAAC,UAAU,EAAE,QAAQ;AAC3C;AAKO,MAAM,kBAAkB,WAAW,GAAG,UAAU;AAKhD,MAAM,kBAAkB,WAAW,GAAG,UAAU","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 581, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/secp256k1/pair/fromSeed.js"],"sourcesContent":["import { secp256k1 } from '@noble/curves/secp256k1';\nimport { hasBigInt, u8aEmpty } from '@polkadot/util';\nimport { isReady, secp256k1FromSeed } from '@polkadot/wasm-crypto';\n/**\n * @name secp256k1PairFromSeed\n * @description Returns a object containing a `publicKey` & `secretKey` generated from the supplied seed.\n */\nexport function secp256k1PairFromSeed(seed, onlyJs) {\n    if (seed.length !== 32) {\n        throw new Error('Expected valid 32-byte private key as a seed');\n    }\n    if (!hasBigInt || (!onlyJs && isReady())) {\n        const full = secp256k1FromSeed(seed);\n        const publicKey = full.slice(32);\n        // There is an issue with the secp256k1 when running in an ASM.js environment where\n        // it seems that the lazy static section yields invalid results on the _first_ run.\n        // If this happens, fail outright, we cannot allow invalid return values\n        // https://github.com/polkadot-js/wasm/issues/307\n        if (u8aEmpty(publicKey)) {\n            throw new Error('Invalid publicKey generated from WASM interface');\n        }\n        return {\n            publicKey,\n            secretKey: full.slice(0, 32)\n        };\n    }\n    return {\n        publicKey: secp256k1.getPublicKey(seed, true),\n        secretKey: seed\n    };\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AAAA;AACA;;;;AAKO,SAAS,sBAAsB,IAAI,EAAE,MAAM;IAC9C,IAAI,KAAK,MAAM,KAAK,IAAI;QACpB,MAAM,IAAI,MAAM;IACpB;IACA,IAAI,CAAC,sJAAS,IAAK,CAAC,UAAU,IAAA,iLAAO,KAAK;QACtC,MAAM,OAAO,IAAA,2LAAiB,EAAC;QAC/B,MAAM,YAAY,KAAK,KAAK,CAAC;QAC7B,mFAAmF;QACnF,mFAAmF;QACnF,wEAAwE;QACxE,iDAAiD;QACjD,IAAI,IAAA,8JAAQ,EAAC,YAAY;YACrB,MAAM,IAAI,MAAM;QACpB;QACA,OAAO;YACH;YACA,WAAW,KAAK,KAAK,CAAC,GAAG;QAC7B;IACJ;IACA,OAAO;QACH,WAAW,kKAAS,CAAC,YAAY,CAAC,MAAM;QACxC,WAAW;IACf;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 620, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/secp256k1/tweakAdd.js"],"sourcesContent":["import { _0n, BN, bnToU8a, hasBigInt, isU8a, nToU8a, u8aToBigInt } from '@polkadot/util';\nimport { BigInt } from '@polkadot/x-bigint';\nimport { BN_BE_256_OPTS, BN_BE_OPTS } from '../bn.js';\nconst N = 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141'.replace(/ /g, '');\nconst N_BI = BigInt(`0x${N}`);\nconst N_BN = new BN(N, 'hex');\nfunction addBi(seckey, tweak) {\n    let res = u8aToBigInt(tweak, BN_BE_OPTS);\n    if (res >= N_BI) {\n        throw new Error('Tweak parameter is out of range');\n    }\n    res += u8aToBigInt(seckey, BN_BE_OPTS);\n    if (res >= N_BI) {\n        res -= N_BI;\n    }\n    if (res === _0n) {\n        throw new Error('Invalid resulting private key');\n    }\n    return nToU8a(res, BN_BE_256_OPTS);\n}\nfunction addBn(seckey, tweak) {\n    const res = new BN(tweak);\n    if (res.cmp(N_BN) >= 0) {\n        throw new Error('Tweak parameter is out of range');\n    }\n    res.iadd(new BN(seckey));\n    if (res.cmp(N_BN) >= 0) {\n        res.isub(N_BN);\n    }\n    if (res.isZero()) {\n        throw new Error('Invalid resulting private key');\n    }\n    return bnToU8a(res, BN_BE_256_OPTS);\n}\nexport function secp256k1PrivateKeyTweakAdd(seckey, tweak, onlyBn) {\n    if (!isU8a(seckey) || seckey.length !== 32) {\n        throw new Error('Expected seckey to be an Uint8Array with length 32');\n    }\n    else if (!isU8a(tweak) || tweak.length !== 32) {\n        throw new Error('Expected tweak to be an Uint8Array with length 32');\n    }\n    return !hasBigInt || onlyBn\n        ? addBn(seckey, tweak)\n        : addBi(seckey, tweak);\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;AACA,MAAM,IAAI,0EAA0E,OAAO,CAAC,MAAM;AAClG,MAAM,OAAO,IAAA,4KAAM,EAAC,CAAC,EAAE,EAAE,GAAG;AAC5B,MAAM,OAAO,IAAI,4KAAE,CAAC,GAAG;AACvB,SAAS,MAAM,MAAM,EAAE,KAAK;IACxB,IAAI,MAAM,IAAA,oKAAW,EAAC,OAAO,gKAAU;IACvC,IAAI,OAAO,MAAM;QACb,MAAM,IAAI,MAAM;IACpB;IACA,OAAO,IAAA,oKAAW,EAAC,QAAQ,gKAAU;IACrC,IAAI,OAAO,MAAM;QACb,OAAO;IACX;IACA,IAAI,QAAQ,yJAAG,EAAE;QACb,MAAM,IAAI,MAAM;IACpB;IACA,OAAO,IAAA,2JAAM,EAAC,KAAK,oKAAc;AACrC;AACA,SAAS,MAAM,MAAM,EAAE,KAAK;IACxB,MAAM,MAAM,IAAI,4KAAE,CAAC;IACnB,IAAI,IAAI,GAAG,CAAC,SAAS,GAAG;QACpB,MAAM,IAAI,MAAM;IACpB;IACA,IAAI,IAAI,CAAC,IAAI,4KAAE,CAAC;IAChB,IAAI,IAAI,GAAG,CAAC,SAAS,GAAG;QACpB,IAAI,IAAI,CAAC;IACb;IACA,IAAI,IAAI,MAAM,IAAI;QACd,MAAM,IAAI,MAAM;IACpB;IACA,OAAO,IAAA,4JAAO,EAAC,KAAK,oKAAc;AACtC;AACO,SAAS,4BAA4B,MAAM,EAAE,KAAK,EAAE,MAAM;IAC7D,IAAI,CAAC,IAAA,wJAAK,EAAC,WAAW,OAAO,MAAM,KAAK,IAAI;QACxC,MAAM,IAAI,MAAM;IACpB,OACK,IAAI,CAAC,IAAA,wJAAK,EAAC,UAAU,MAAM,MAAM,KAAK,IAAI;QAC3C,MAAM,IAAI,MAAM;IACpB;IACA,OAAO,CAAC,sJAAS,IAAI,SACf,MAAM,QAAQ,SACd,MAAM,QAAQ;AACxB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 679, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/hd/validatePath.js"],"sourcesContent":["export const HARDENED = 0x80000000;\nexport function hdValidatePath(path) {\n    if (!path.startsWith('m/')) {\n        return false;\n    }\n    const parts = path.split('/').slice(1);\n    for (const p of parts) {\n        const n = /^\\d+'?$/.test(p)\n            ? parseInt(p.replace(/'$/, ''), 10)\n            : Number.NaN;\n        if (isNaN(n) || (n >= HARDENED) || (n < 0)) {\n            return false;\n        }\n    }\n    return true;\n}\n"],"names":[],"mappings":";;;;;;AAAO,MAAM,WAAW;AACjB,SAAS,eAAe,IAAI;IAC/B,IAAI,CAAC,KAAK,UAAU,CAAC,OAAO;QACxB,OAAO;IACX;IACA,MAAM,QAAQ,KAAK,KAAK,CAAC,KAAK,KAAK,CAAC;IACpC,KAAK,MAAM,KAAK,MAAO;QACnB,MAAM,IAAI,UAAU,IAAI,CAAC,KACnB,SAAS,EAAE,OAAO,CAAC,MAAM,KAAK,MAC9B,OAAO,GAAG;QAChB,IAAI,MAAM,MAAO,KAAK,YAAc,IAAI,GAAI;YACxC,OAAO;QACX;IACJ;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 703, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/hd/ethereum/index.js"],"sourcesContent":["import { bnToU8a, stringToU8a, u8aConcat } from '@polkadot/util';\nimport { BN_BE_32_OPTS } from '../../bn.js';\nimport { hmacShaAsU8a } from '../../hmac/index.js';\nimport { secp256k1PairFromSeed, secp256k1PrivateKeyTweakAdd } from '../../secp256k1/index.js';\nimport { HARDENED, hdValidatePath } from '../validatePath.js';\nconst MASTER_SECRET = stringToU8a('Bitcoin seed');\nfunction createCoded(secretKey, chainCode) {\n    return {\n        chainCode,\n        publicKey: secp256k1PairFromSeed(secretKey).publicKey,\n        secretKey\n    };\n}\nfunction deriveChild(hd, index) {\n    const indexBuffer = bnToU8a(index, BN_BE_32_OPTS);\n    const data = index >= HARDENED\n        ? u8aConcat(new Uint8Array(1), hd.secretKey, indexBuffer)\n        : u8aConcat(hd.publicKey, indexBuffer);\n    try {\n        const I = hmacShaAsU8a(hd.chainCode, data, 512);\n        return createCoded(secp256k1PrivateKeyTweakAdd(hd.secretKey, I.slice(0, 32)), I.slice(32));\n    }\n    catch {\n        // In case parse256(IL) >= n or ki == 0, proceed with the next value for i\n        return deriveChild(hd, index + 1);\n    }\n}\nexport function hdEthereum(seed, path = '') {\n    const I = hmacShaAsU8a(MASTER_SECRET, seed, 512);\n    let hd = createCoded(I.slice(0, 32), I.slice(32));\n    if (!path || path === 'm' || path === 'M' || path === \"m'\" || path === \"M'\") {\n        return hd;\n    }\n    if (!hdValidatePath(path)) {\n        throw new Error('Invalid derivation path');\n    }\n    const parts = path.split('/').slice(1);\n    for (const p of parts) {\n        hd = deriveChild(hd, parseInt(p, 10) + ((p.length > 1) && p.endsWith(\"'\")\n            ? HARDENED\n            : 0));\n    }\n    return hd;\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;;;;;;AACA,MAAM,gBAAgB,IAAA,oKAAW,EAAC;AAClC,SAAS,YAAY,SAAS,EAAE,SAAS;IACrC,OAAO;QACH;QACA,WAAW,IAAA,sMAAqB,EAAC,WAAW,SAAS;QACrD;IACJ;AACJ;AACA,SAAS,YAAY,EAAE,EAAE,KAAK;IAC1B,MAAM,cAAc,IAAA,4JAAO,EAAC,OAAO,mKAAa;IAChD,MAAM,OAAO,SAAS,8KAAQ,GACxB,IAAA,gKAAS,EAAC,IAAI,WAAW,IAAI,GAAG,SAAS,EAAE,eAC3C,IAAA,gKAAS,EAAC,GAAG,SAAS,EAAE;IAC9B,IAAI;QACA,MAAM,IAAI,IAAA,gLAAY,EAAC,GAAG,SAAS,EAAE,MAAM;QAC3C,OAAO,YAAY,IAAA,oMAA2B,EAAC,GAAG,SAAS,EAAE,EAAE,KAAK,CAAC,GAAG,MAAM,EAAE,KAAK,CAAC;IAC1F,EACA,OAAM;QACF,0EAA0E;QAC1E,OAAO,YAAY,IAAI,QAAQ;IACnC;AACJ;AACO,SAAS,WAAW,IAAI,EAAE,OAAO,EAAE;IACtC,MAAM,IAAI,IAAA,gLAAY,EAAC,eAAe,MAAM;IAC5C,IAAI,KAAK,YAAY,EAAE,KAAK,CAAC,GAAG,KAAK,EAAE,KAAK,CAAC;IAC7C,IAAI,CAAC,QAAQ,SAAS,OAAO,SAAS,OAAO,SAAS,QAAQ,SAAS,MAAM;QACzE,OAAO;IACX;IACA,IAAI,CAAC,IAAA,oLAAc,EAAC,OAAO;QACvB,MAAM,IAAI,MAAM;IACpB;IACA,MAAM,QAAQ,KAAK,KAAK,CAAC,KAAK,KAAK,CAAC;IACpC,KAAK,MAAM,KAAK,MAAO;QACnB,KAAK,YAAY,IAAI,SAAS,GAAG,MAAM,CAAC,AAAC,EAAE,MAAM,GAAG,KAAM,EAAE,QAAQ,CAAC,OAC/D,8KAAQ,GACR,CAAC;IACX;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 758, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/key/DeriveJunction.js"],"sourcesContent":["import { BN, bnToU8a, compactAddLength, hexToU8a, isBigInt, isBn, isHex, isNumber, isString, stringToU8a } from '@polkadot/util';\nimport { blake2AsU8a } from '../blake2/asU8a.js';\nimport { BN_LE_256_OPTS } from '../bn.js';\nconst RE_NUMBER = /^\\d+$/;\nconst JUNCTION_ID_LEN = 32;\nexport class DeriveJunction {\n    #chainCode = new Uint8Array(32);\n    #isHard = false;\n    static from(value) {\n        const result = new DeriveJunction();\n        const [code, isHard] = value.startsWith('/')\n            ? [value.substring(1), true]\n            : [value, false];\n        result.soft(RE_NUMBER.test(code)\n            ? new BN(code, 10)\n            : code);\n        return isHard\n            ? result.harden()\n            : result;\n    }\n    get chainCode() {\n        return this.#chainCode;\n    }\n    get isHard() {\n        return this.#isHard;\n    }\n    get isSoft() {\n        return !this.#isHard;\n    }\n    hard(value) {\n        return this.soft(value).harden();\n    }\n    harden() {\n        this.#isHard = true;\n        return this;\n    }\n    soft(value) {\n        if (isNumber(value) || isBn(value) || isBigInt(value)) {\n            return this.soft(bnToU8a(value, BN_LE_256_OPTS));\n        }\n        else if (isHex(value)) {\n            return this.soft(hexToU8a(value));\n        }\n        else if (isString(value)) {\n            return this.soft(compactAddLength(stringToU8a(value)));\n        }\n        else if (value.length > JUNCTION_ID_LEN) {\n            return this.soft(blake2AsU8a(value));\n        }\n        this.#chainCode.fill(0);\n        this.#chainCode.set(value, 0);\n        return this;\n    }\n    soften() {\n        this.#isHard = false;\n        return this;\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;AACA,MAAM,YAAY;AAClB,MAAM,kBAAkB;AACjB,MAAM;IACT,CAAA,SAAU,GAAG,IAAI,WAAW,IAAI;IAChC,CAAA,MAAO,GAAG,MAAM;IAChB,OAAO,KAAK,KAAK,EAAE;QACf,MAAM,SAAS,IAAI;QACnB,MAAM,CAAC,MAAM,OAAO,GAAG,MAAM,UAAU,CAAC,OAClC;YAAC,MAAM,SAAS,CAAC;YAAI;SAAK,GAC1B;YAAC;YAAO;SAAM;QACpB,OAAO,IAAI,CAAC,UAAU,IAAI,CAAC,QACrB,IAAI,4KAAE,CAAC,MAAM,MACb;QACN,OAAO,SACD,OAAO,MAAM,KACb;IACV;IACA,IAAI,YAAY;QACZ,OAAO,IAAI,CAAC,CAAA,SAAU;IAC1B;IACA,IAAI,SAAS;QACT,OAAO,IAAI,CAAC,CAAA,MAAO;IACvB;IACA,IAAI,SAAS;QACT,OAAO,CAAC,IAAI,CAAC,CAAA,MAAO;IACxB;IACA,KAAK,KAAK,EAAE;QACR,OAAO,IAAI,CAAC,IAAI,CAAC,OAAO,MAAM;IAClC;IACA,SAAS;QACL,IAAI,CAAC,CAAA,MAAO,GAAG;QACf,OAAO,IAAI;IACf;IACA,KAAK,KAAK,EAAE;QACR,IAAI,IAAA,8JAAQ,EAAC,UAAU,IAAA,sJAAI,EAAC,UAAU,IAAA,8JAAQ,EAAC,QAAQ;YACnD,OAAO,IAAI,CAAC,IAAI,CAAC,IAAA,4JAAO,EAAC,OAAO,oKAAc;QAClD,OACK,IAAI,IAAA,wJAAK,EAAC,QAAQ;YACnB,OAAO,IAAI,CAAC,IAAI,CAAC,IAAA,8JAAQ,EAAC;QAC9B,OACK,IAAI,IAAA,8JAAQ,EAAC,QAAQ;YACtB,OAAO,IAAI,CAAC,IAAI,CAAC,IAAA,8KAAgB,EAAC,IAAA,oKAAW,EAAC;QAClD,OACK,IAAI,MAAM,MAAM,GAAG,iBAAiB;YACrC,OAAO,IAAI,CAAC,IAAI,CAAC,IAAA,8KAAW,EAAC;QACjC;QACA,IAAI,CAAC,CAAA,SAAU,CAAC,IAAI,CAAC;QACrB,IAAI,CAAC,CAAA,SAAU,CAAC,GAAG,CAAC,OAAO;QAC3B,OAAO,IAAI;IACf;IACA,SAAS;QACL,IAAI,CAAC,CAAA,MAAO,GAAG;QACf,OAAO,IAAI;IACf;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 833, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/key/extractPath.js"],"sourcesContent":["import { DeriveJunction } from './DeriveJunction.js';\nconst RE_JUNCTION = /\\/(\\/?)([^/]+)/g;\n/**\n * @description Extract derivation junctions from the supplied path\n */\nexport function keyExtractPath(derivePath) {\n    const parts = derivePath.match(RE_JUNCTION);\n    const path = [];\n    let constructed = '';\n    if (parts) {\n        constructed = parts.join('');\n        for (const p of parts) {\n            path.push(DeriveJunction.from(p.substring(1)));\n        }\n    }\n    if (constructed !== derivePath) {\n        throw new Error(`Re-constructed path \"${constructed}\" does not match input`);\n    }\n    return {\n        parts,\n        path\n    };\n}\n"],"names":[],"mappings":";;;;AAAA;;AACA,MAAM,cAAc;AAIb,SAAS,eAAe,UAAU;IACrC,MAAM,QAAQ,WAAW,KAAK,CAAC;IAC/B,MAAM,OAAO,EAAE;IACf,IAAI,cAAc;IAClB,IAAI,OAAO;QACP,cAAc,MAAM,IAAI,CAAC;QACzB,KAAK,MAAM,KAAK,MAAO;YACnB,KAAK,IAAI,CAAC,uLAAc,CAAC,IAAI,CAAC,EAAE,SAAS,CAAC;QAC9C;IACJ;IACA,IAAI,gBAAgB,YAAY;QAC5B,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,YAAY,sBAAsB,CAAC;IAC/E;IACA,OAAO;QACH;QACA;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 862, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/key/extractSuri.js"],"sourcesContent":["import { keyExtractPath } from './extractPath.js';\nconst RE_CAPTURE = /^((0x[a-fA-F0-9]+|[\\p{L}\\d]+(?: [\\p{L}\\d]+)*))((\\/\\/?[^/]+)*)(\\/\\/\\/(.*))?$/u;\n/**\n * @description Extracts the phrase, path and password from a SURI format for specifying secret keys `<secret>/<soft-key>//<hard-key>///<password>` (the `///password` may be omitted, and `/<soft-key>` and `//<hard-key>` maybe repeated and mixed).\n */\nexport function keyExtractSuri(suri) {\n    // Normalize Unicode to NFC to avoid accent-related mismatches\n    const normalizedSuri = suri.normalize('NFC');\n    // eslint-disable-next-line @typescript-eslint/prefer-regexp-exec\n    const matches = normalizedSuri.match(RE_CAPTURE);\n    if (matches === null) {\n        throw new Error('Unable to match provided value to a secret URI');\n    }\n    const [, phrase, , derivePath, , , password] = matches;\n    const { path } = keyExtractPath(derivePath);\n    return {\n        derivePath,\n        password,\n        path,\n        phrase\n    };\n}\n"],"names":[],"mappings":";;;;AAAA;;AACA,MAAM,aAAa;AAIZ,SAAS,eAAe,IAAI;IAC/B,8DAA8D;IAC9D,MAAM,iBAAiB,KAAK,SAAS,CAAC;IACtC,iEAAiE;IACjE,MAAM,UAAU,eAAe,KAAK,CAAC;IACrC,IAAI,YAAY,MAAM;QAClB,MAAM,IAAI,MAAM;IACpB;IACA,MAAM,GAAG,UAAU,gBAAgB,SAAS,GAAG;IAC/C,MAAM,EAAE,IAAI,EAAE,GAAG,IAAA,oLAAc,EAAC;IAChC,OAAO;QACH;QACA;QACA;QACA;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 890, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/secp256k1/deriveHard.js"],"sourcesContent":["import { compactAddLength, isU8a, stringToU8a, u8aConcat } from '@polkadot/util';\nimport { blake2AsU8a } from '../blake2/asU8a.js';\nconst HDKD = compactAddLength(stringToU8a('Secp256k1HDKD'));\nexport function secp256k1DeriveHard(seed, chainCode) {\n    if (!isU8a(chainCode) || chainCode.length !== 32) {\n        throw new Error('Invalid chainCode passed to derive');\n    }\n    // NOTE This is specific to the Substrate HDD derivation, so always use the blake2 hasher\n    return blake2AsU8a(u8aConcat(HDKD, seed, chainCode), 256);\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AAAA;AAAA;AACA;;;AACA,MAAM,OAAO,IAAA,8KAAgB,EAAC,IAAA,oKAAW,EAAC;AACnC,SAAS,oBAAoB,IAAI,EAAE,SAAS;IAC/C,IAAI,CAAC,IAAA,wJAAK,EAAC,cAAc,UAAU,MAAM,KAAK,IAAI;QAC9C,MAAM,IAAI,MAAM;IACpB;IACA,yFAAyF;IACzF,OAAO,IAAA,8KAAW,EAAC,IAAA,gKAAS,EAAC,MAAM,MAAM,YAAY;AACzD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 913, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/key/hdkdDerive.js"],"sourcesContent":["export function createSeedDeriveFn(fromSeed, derive) {\n    return (keypair, { chainCode, isHard }) => {\n        if (!isHard) {\n            throw new Error('A soft key was found in the path and is not supported');\n        }\n        return fromSeed(derive(keypair.secretKey.subarray(0, 32), chainCode));\n    };\n}\n"],"names":[],"mappings":";;;;AAAO,SAAS,mBAAmB,QAAQ,EAAE,MAAM;IAC/C,OAAO,CAAC,SAAS,EAAE,SAAS,EAAE,MAAM,EAAE;QAClC,IAAI,CAAC,QAAQ;YACT,MAAM,IAAI,MAAM;QACpB;QACA,OAAO,SAAS,OAAO,QAAQ,SAAS,CAAC,QAAQ,CAAC,GAAG,KAAK;IAC9D;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 929, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/key/hdkdEcdsa.js"],"sourcesContent":["import { secp256k1DeriveHard } from '../secp256k1/deriveHard.js';\nimport { secp256k1PairFromSeed } from '../secp256k1/pair/fromSeed.js';\nimport { createSeedDeriveFn } from './hdkdDerive.js';\nexport const keyHdkdEcdsa = /*#__PURE__*/ createSeedDeriveFn(secp256k1PairFromSeed, secp256k1DeriveHard);\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AACO,MAAM,eAAe,WAAW,GAAG,IAAA,uLAAkB,EAAC,sMAAqB,EAAE,8LAAmB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 944, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/ed25519/deriveHard.js"],"sourcesContent":["import { compactAddLength, isU8a, stringToU8a, u8aConcat } from '@polkadot/util';\nimport { blake2AsU8a } from '../blake2/asU8a.js';\nconst HDKD = compactAddLength(stringToU8a('Ed25519HDKD'));\nexport function ed25519DeriveHard(seed, chainCode) {\n    if (!isU8a(chainCode) || chainCode.length !== 32) {\n        throw new Error('Invalid chainCode passed to derive');\n    }\n    return blake2AsU8a(u8aConcat(HDKD, seed, chainCode));\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AAAA;AAAA;AACA;;;AACA,MAAM,OAAO,IAAA,8KAAgB,EAAC,IAAA,oKAAW,EAAC;AACnC,SAAS,kBAAkB,IAAI,EAAE,SAAS;IAC7C,IAAI,CAAC,IAAA,wJAAK,EAAC,cAAc,UAAU,MAAM,KAAK,IAAI;QAC9C,MAAM,IAAI,MAAM;IACpB;IACA,OAAO,IAAA,8KAAW,EAAC,IAAA,gKAAS,EAAC,MAAM,MAAM;AAC7C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 966, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/key/hdkdEd25519.js"],"sourcesContent":["import { ed25519DeriveHard, ed25519PairFromSeed } from '../ed25519/index.js';\nimport { createSeedDeriveFn } from './hdkdDerive.js';\nexport const keyHdkdEd25519 = /*#__PURE__*/ createSeedDeriveFn(ed25519PairFromSeed, ed25519DeriveHard);\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;;;AACO,MAAM,iBAAiB,WAAW,GAAG,IAAA,uLAAkB,EAAC,kMAAmB,EAAE,0LAAiB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 980, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/sr25519/pair/fromU8a.js"],"sourcesContent":["import { u8aToU8a } from '@polkadot/util';\nconst SEC_LEN = 64;\nconst PUB_LEN = 32;\nconst TOT_LEN = SEC_LEN + PUB_LEN;\nexport function sr25519PairFromU8a(full) {\n    const fullU8a = u8aToU8a(full);\n    if (fullU8a.length !== TOT_LEN) {\n        throw new Error(`Expected keypair with ${TOT_LEN} bytes, found ${fullU8a.length}`);\n    }\n    return {\n        publicKey: fullU8a.slice(SEC_LEN, TOT_LEN),\n        secretKey: fullU8a.slice(0, SEC_LEN)\n    };\n}\n"],"names":[],"mappings":";;;;AAAA;;AACA,MAAM,UAAU;AAChB,MAAM,UAAU;AAChB,MAAM,UAAU,UAAU;AACnB,SAAS,mBAAmB,IAAI;IACnC,MAAM,UAAU,IAAA,8JAAQ,EAAC;IACzB,IAAI,QAAQ,MAAM,KAAK,SAAS;QAC5B,MAAM,IAAI,MAAM,CAAC,sBAAsB,EAAE,QAAQ,cAAc,EAAE,QAAQ,MAAM,EAAE;IACrF;IACA,OAAO;QACH,WAAW,QAAQ,KAAK,CAAC,SAAS;QAClC,WAAW,QAAQ,KAAK,CAAC,GAAG;IAChC;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1003, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/sr25519/pair/toU8a.js"],"sourcesContent":["import { u8aConcat } from '@polkadot/util';\nexport function sr25519KeypairToU8a({ publicKey, secretKey }) {\n    return u8aConcat(secretKey, publicKey).slice();\n}\n"],"names":[],"mappings":";;;;AAAA;;AACO,SAAS,oBAAoB,EAAE,SAAS,EAAE,SAAS,EAAE;IACxD,OAAO,IAAA,gKAAS,EAAC,WAAW,WAAW,KAAK;AAChD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1016, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/sr25519/derive.js"],"sourcesContent":["import { isU8a } from '@polkadot/util';\nimport { sr25519PairFromU8a } from './pair/fromU8a.js';\nimport { sr25519KeypairToU8a } from './pair/toU8a.js';\nexport function createDeriveFn(derive) {\n    return (keypair, chainCode) => {\n        if (!isU8a(chainCode) || chainCode.length !== 32) {\n            throw new Error('Invalid chainCode passed to derive');\n        }\n        return sr25519PairFromU8a(derive(sr25519KeypairToU8a(keypair), chainCode));\n    };\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AACO,SAAS,eAAe,MAAM;IACjC,OAAO,CAAC,SAAS;QACb,IAAI,CAAC,IAAA,wJAAK,EAAC,cAAc,UAAU,MAAM,KAAK,IAAI;YAC9C,MAAM,IAAI,MAAM;QACpB;QACA,OAAO,IAAA,gMAAkB,EAAC,OAAO,IAAA,+LAAmB,EAAC,UAAU;IACnE;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1038, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/sr25519/deriveHard.js"],"sourcesContent":["import { sr25519DeriveKeypairHard } from '@polkadot/wasm-crypto';\nimport { createDeriveFn } from './derive.js';\nexport const sr25519DeriveHard = /*#__PURE__*/ createDeriveFn(sr25519DeriveKeypairHard);\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AACO,MAAM,oBAAoB,WAAW,GAAG,IAAA,mLAAc,EAAC,kMAAwB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1051, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/sr25519/deriveSoft.js"],"sourcesContent":["import { sr25519DeriveKeypairSoft } from '@polkadot/wasm-crypto';\nimport { createDeriveFn } from './derive.js';\nexport const sr25519DeriveSoft = /*#__PURE__*/ createDeriveFn(sr25519DeriveKeypairSoft);\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AACO,MAAM,oBAAoB,WAAW,GAAG,IAAA,mLAAc,EAAC,kMAAwB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1064, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/key/hdkdSr25519.js"],"sourcesContent":["import { sr25519DeriveHard } from '../sr25519/deriveHard.js';\nimport { sr25519DeriveSoft } from '../sr25519/deriveSoft.js';\nexport function keyHdkdSr25519(keypair, { chainCode, isSoft }) {\n    return isSoft\n        ? sr25519DeriveSoft(keypair, chainCode)\n        : sr25519DeriveHard(keypair, chainCode);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AACO,SAAS,eAAe,OAAO,EAAE,EAAE,SAAS,EAAE,MAAM,EAAE;IACzD,OAAO,SACD,IAAA,0LAAiB,EAAC,SAAS,aAC3B,IAAA,0LAAiB,EAAC,SAAS;AACrC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1079, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/key/fromPath.js"],"sourcesContent":["import { keyHdkdEcdsa } from './hdkdEcdsa.js';\nimport { keyHdkdEd25519 } from './hdkdEd25519.js';\nimport { keyHdkdSr25519 } from './hdkdSr25519.js';\nconst generators = {\n    ecdsa: keyHdkdEcdsa,\n    ed25519: keyHdkdEd25519,\n    // FIXME This is Substrate-compatible, not Ethereum-compatible\n    ethereum: keyHdkdEcdsa,\n    sr25519: keyHdkdSr25519\n};\nexport function keyFromPath(pair, path, type) {\n    const keyHdkd = generators[type];\n    let result = pair;\n    for (const junction of path) {\n        result = keyHdkd(result, junction);\n    }\n    return result;\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AACA,MAAM,aAAa;IACf,OAAO,gLAAY;IACnB,SAAS,oLAAc;IACvB,8DAA8D;IAC9D,UAAU,gLAAY;IACtB,SAAS,oLAAc;AAC3B;AACO,SAAS,YAAY,IAAI,EAAE,IAAI,EAAE,IAAI;IACxC,MAAM,UAAU,UAAU,CAAC,KAAK;IAChC,IAAI,SAAS;IACb,KAAK,MAAM,YAAY,KAAM;QACzB,SAAS,QAAQ,QAAQ;IAC7B;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1108, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/random/asU8a.js"],"sourcesContent":["import { getRandomValues } from '@polkadot/x-randomvalues';\nimport { createAsHex } from '../helpers.js';\n/**\n * @name randomAsU8a\n * @summary Creates a Uint8Array filled with random bytes.\n * @description\n * Returns a `Uint8Array` with the specified (optional) length filled with random bytes.\n * @example\n * <BR>\n *\n * ```javascript\n * import { randomAsU8a } from '@polkadot/util-crypto';\n *\n * randomAsU8a(); // => Uint8Array([...])\n * ```\n */\nexport function randomAsU8a(length = 32) {\n    return getRandomValues(new Uint8Array(length));\n}\n/**\n * @name randomAsHex\n * @description Creates a hex string filled with random bytes.\n */\nexport const randomAsHex = /*#__PURE__*/ createAsHex(randomAsU8a);\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAeO,SAAS,YAAY,SAAS,EAAE;IACnC,OAAO,IAAA,0LAAe,EAAC,IAAI,WAAW;AAC1C;AAKO,MAAM,cAAc,WAAW,GAAG,IAAA,sKAAW,EAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1126, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/pbkdf2/encode.js"],"sourcesContent":["import { pbkdf2 as pbkdf2Js } from '@noble/hashes/pbkdf2';\nimport { sha512 } from '@noble/hashes/sha512';\nimport { hasBigInt, u8aToU8a } from '@polkadot/util';\nimport { isReady, pbkdf2 } from '@polkadot/wasm-crypto';\nimport { randomAsU8a } from '../random/asU8a.js';\nexport function pbkdf2Encode(passphrase, salt = randomAsU8a(), rounds = 210000, onlyJs) {\n    // When using the JS implementation (pbkdf2Js), large iteration counts can\n    // cause excessive computation time or memory usage. In that case, we cap\n    // the number of rounds to 2048 to ensure reliable performance.\n    if (onlyJs && rounds > 2048) {\n        rounds = 2048;\n    }\n    const u8aPass = u8aToU8a(passphrase);\n    const u8aSalt = u8aToU8a(salt);\n    return {\n        password: !hasBigInt || (!onlyJs && isReady())\n            ? pbkdf2(u8aPass, u8aSalt, rounds)\n            : pbkdf2Js(sha512, u8aPass, u8aSalt, { c: rounds, dkLen: 64 }),\n        rounds,\n        salt\n    };\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AAAA;AACA;AACA;;;;;;AACO,SAAS,aAAa,UAAU,EAAE,OAAO,IAAA,8KAAW,GAAE,EAAE,SAAS,MAAM,EAAE,MAAM;IAClF,0EAA0E;IAC1E,yEAAyE;IACzE,+DAA+D;IAC/D,IAAI,UAAU,SAAS,MAAM;QACzB,SAAS;IACb;IACA,MAAM,UAAU,IAAA,8JAAQ,EAAC;IACzB,MAAM,UAAU,IAAA,8JAAQ,EAAC;IACzB,OAAO;QACH,UAAU,CAAC,sJAAS,IAAK,CAAC,UAAU,IAAA,iLAAO,MACrC,IAAA,gLAAM,EAAC,SAAS,SAAS,UACzB,IAAA,4JAAQ,EAAC,4JAAM,EAAE,SAAS,SAAS;YAAE,GAAG;YAAQ,OAAO;QAAG;QAChE;QACA;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1163, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/sha/asU8a.js"],"sourcesContent":["import { sha256 as sha256Js } from '@noble/hashes/sha256';\nimport { sha512 as sha512Js } from '@noble/hashes/sha512';\nimport { sha256, sha512 } from '@polkadot/wasm-crypto';\nimport { createBitHasher, createDualHasher } from '../helpers.js';\n/**\n * @name shaAsU8a\n * @summary Creates a sha Uint8Array from the input.\n */\nexport const shaAsU8a = /*#__PURE__*/ createDualHasher({ 256: sha256, 512: sha512 }, { 256: sha256Js, 512: sha512Js });\n/**\n * @name sha256AsU8a\n * @summary Creates a sha256 Uint8Array from the input.\n */\nexport const sha256AsU8a = /*#__PURE__*/ createBitHasher(256, shaAsU8a);\n/**\n * @name sha512AsU8a\n * @summary Creates a sha512 Uint8Array from the input.\n */\nexport const sha512AsU8a = /*#__PURE__*/ createBitHasher(512, shaAsU8a);\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;;;;;AAKO,MAAM,WAAW,WAAW,GAAG,IAAA,2KAAgB,EAAC;IAAE,KAAK,gLAAM;IAAE,KAAK,gLAAM;AAAC,GAAG;IAAE,KAAK,4JAAQ;IAAE,KAAK,4JAAQ;AAAC;AAK7G,MAAM,cAAc,WAAW,GAAG,IAAA,0KAAe,EAAC,KAAK;AAKvD,MAAM,cAAc,WAAW,GAAG,IAAA,0KAAe,EAAC,KAAK","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1192, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/mnemonic/wordlists/en.js"],"sourcesContent":["export default 'abandon|ability|able|about|above|absent|absorb|abstract|absurd|abuse|access|accident|account|accuse|achieve|acid|acoustic|acquire|across|act|action|actor|actress|actual|adapt|add|addict|address|adjust|admit|adult|advance|advice|aerobic|affair|afford|afraid|again|age|agent|agree|ahead|aim|air|airport|aisle|alarm|album|alcohol|alert|alien|all|alley|allow|almost|alone|alpha|already|also|alter|always|amateur|amazing|among|amount|amused|analyst|anchor|ancient|anger|angle|angry|animal|ankle|announce|annual|another|answer|antenna|antique|anxiety|any|apart|apology|appear|apple|approve|april|arch|arctic|area|arena|argue|arm|armed|armor|army|around|arrange|arrest|arrive|arrow|art|artefact|artist|artwork|ask|aspect|assault|asset|assist|assume|asthma|athlete|atom|attack|attend|attitude|attract|auction|audit|august|aunt|author|auto|autumn|average|avocado|avoid|awake|aware|away|awesome|awful|awkward|axis|baby|bachelor|bacon|badge|bag|balance|balcony|ball|bamboo|banana|banner|bar|barely|bargain|barrel|base|basic|basket|battle|beach|bean|beauty|because|become|beef|before|begin|behave|behind|believe|below|belt|bench|benefit|best|betray|better|between|beyond|bicycle|bid|bike|bind|biology|bird|birth|bitter|black|blade|blame|blanket|blast|bleak|bless|blind|blood|blossom|blouse|blue|blur|blush|board|boat|body|boil|bomb|bone|bonus|book|boost|border|boring|borrow|boss|bottom|bounce|box|boy|bracket|brain|brand|brass|brave|bread|breeze|brick|bridge|brief|bright|bring|brisk|broccoli|broken|bronze|broom|brother|brown|brush|bubble|buddy|budget|buffalo|build|bulb|bulk|bullet|bundle|bunker|burden|burger|burst|bus|business|busy|butter|buyer|buzz|cabbage|cabin|cable|cactus|cage|cake|call|calm|camera|camp|can|canal|cancel|candy|cannon|canoe|canvas|canyon|capable|capital|captain|car|carbon|card|cargo|carpet|carry|cart|case|cash|casino|castle|casual|cat|catalog|catch|category|cattle|caught|cause|caution|cave|ceiling|celery|cement|census|century|cereal|certain|chair|chalk|champion|change|chaos|chapter|charge|chase|chat|cheap|check|cheese|chef|cherry|chest|chicken|chief|child|chimney|choice|choose|chronic|chuckle|chunk|churn|cigar|cinnamon|circle|citizen|city|civil|claim|clap|clarify|claw|clay|clean|clerk|clever|click|client|cliff|climb|clinic|clip|clock|clog|close|cloth|cloud|clown|club|clump|cluster|clutch|coach|coast|coconut|code|coffee|coil|coin|collect|color|column|combine|come|comfort|comic|common|company|concert|conduct|confirm|congress|connect|consider|control|convince|cook|cool|copper|copy|coral|core|corn|correct|cost|cotton|couch|country|couple|course|cousin|cover|coyote|crack|cradle|craft|cram|crane|crash|crater|crawl|crazy|cream|credit|creek|crew|cricket|crime|crisp|critic|crop|cross|crouch|crowd|crucial|cruel|cruise|crumble|crunch|crush|cry|crystal|cube|culture|cup|cupboard|curious|current|curtain|curve|cushion|custom|cute|cycle|dad|damage|damp|dance|danger|daring|dash|daughter|dawn|day|deal|debate|debris|decade|december|decide|decline|decorate|decrease|deer|defense|define|defy|degree|delay|deliver|demand|demise|denial|dentist|deny|depart|depend|deposit|depth|deputy|derive|describe|desert|design|desk|despair|destroy|detail|detect|develop|device|devote|diagram|dial|diamond|diary|dice|diesel|diet|differ|digital|dignity|dilemma|dinner|dinosaur|direct|dirt|disagree|discover|disease|dish|dismiss|disorder|display|distance|divert|divide|divorce|dizzy|doctor|document|dog|doll|dolphin|domain|donate|donkey|donor|door|dose|double|dove|draft|dragon|drama|drastic|draw|dream|dress|drift|drill|drink|drip|drive|drop|drum|dry|duck|dumb|dune|during|dust|dutch|duty|dwarf|dynamic|eager|eagle|early|earn|earth|easily|east|easy|echo|ecology|economy|edge|edit|educate|effort|egg|eight|either|elbow|elder|electric|elegant|element|elephant|elevator|elite|else|embark|embody|embrace|emerge|emotion|employ|empower|empty|enable|enact|end|endless|endorse|enemy|energy|enforce|engage|engine|enhance|enjoy|enlist|enough|enrich|enroll|ensure|enter|entire|entry|envelope|episode|equal|equip|era|erase|erode|erosion|error|erupt|escape|essay|essence|estate|eternal|ethics|evidence|evil|evoke|evolve|exact|example|excess|exchange|excite|exclude|excuse|execute|exercise|exhaust|exhibit|exile|exist|exit|exotic|expand|expect|expire|explain|expose|express|extend|extra|eye|eyebrow|fabric|face|faculty|fade|faint|faith|fall|false|fame|family|famous|fan|fancy|fantasy|farm|fashion|fat|fatal|father|fatigue|fault|favorite|feature|february|federal|fee|feed|feel|female|fence|festival|fetch|fever|few|fiber|fiction|field|figure|file|film|filter|final|find|fine|finger|finish|fire|firm|first|fiscal|fish|fit|fitness|fix|flag|flame|flash|flat|flavor|flee|flight|flip|float|flock|floor|flower|fluid|flush|fly|foam|focus|fog|foil|fold|follow|food|foot|force|forest|forget|fork|fortune|forum|forward|fossil|foster|found|fox|fragile|frame|frequent|fresh|friend|fringe|frog|front|frost|frown|frozen|fruit|fuel|fun|funny|furnace|fury|future|gadget|gain|galaxy|gallery|game|gap|garage|garbage|garden|garlic|garment|gas|gasp|gate|gather|gauge|gaze|general|genius|genre|gentle|genuine|gesture|ghost|giant|gift|giggle|ginger|giraffe|girl|give|glad|glance|glare|glass|glide|glimpse|globe|gloom|glory|glove|glow|glue|goat|goddess|gold|good|goose|gorilla|gospel|gossip|govern|gown|grab|grace|grain|grant|grape|grass|gravity|great|green|grid|grief|grit|grocery|group|grow|grunt|guard|guess|guide|guilt|guitar|gun|gym|habit|hair|half|hammer|hamster|hand|happy|harbor|hard|harsh|harvest|hat|have|hawk|hazard|head|health|heart|heavy|hedgehog|height|hello|helmet|help|hen|hero|hidden|high|hill|hint|hip|hire|history|hobby|hockey|hold|hole|holiday|hollow|home|honey|hood|hope|horn|horror|horse|hospital|host|hotel|hour|hover|hub|huge|human|humble|humor|hundred|hungry|hunt|hurdle|hurry|hurt|husband|hybrid|ice|icon|idea|identify|idle|ignore|ill|illegal|illness|image|imitate|immense|immune|impact|impose|improve|impulse|inch|include|income|increase|index|indicate|indoor|industry|infant|inflict|inform|inhale|inherit|initial|inject|injury|inmate|inner|innocent|input|inquiry|insane|insect|inside|inspire|install|intact|interest|into|invest|invite|involve|iron|island|isolate|issue|item|ivory|jacket|jaguar|jar|jazz|jealous|jeans|jelly|jewel|job|join|joke|journey|joy|judge|juice|jump|jungle|junior|junk|just|kangaroo|keen|keep|ketchup|key|kick|kid|kidney|kind|kingdom|kiss|kit|kitchen|kite|kitten|kiwi|knee|knife|knock|know|lab|label|labor|ladder|lady|lake|lamp|language|laptop|large|later|latin|laugh|laundry|lava|law|lawn|lawsuit|layer|lazy|leader|leaf|learn|leave|lecture|left|leg|legal|legend|leisure|lemon|lend|length|lens|leopard|lesson|letter|level|liar|liberty|library|license|life|lift|light|like|limb|limit|link|lion|liquid|list|little|live|lizard|load|loan|lobster|local|lock|logic|lonely|long|loop|lottery|loud|lounge|love|loyal|lucky|luggage|lumber|lunar|lunch|luxury|lyrics|machine|mad|magic|magnet|maid|mail|main|major|make|mammal|man|manage|mandate|mango|mansion|manual|maple|marble|march|margin|marine|market|marriage|mask|mass|master|match|material|math|matrix|matter|maximum|maze|meadow|mean|measure|meat|mechanic|medal|media|melody|melt|member|memory|mention|menu|mercy|merge|merit|merry|mesh|message|metal|method|middle|midnight|milk|million|mimic|mind|minimum|minor|minute|miracle|mirror|misery|miss|mistake|mix|mixed|mixture|mobile|model|modify|mom|moment|monitor|monkey|monster|month|moon|moral|more|morning|mosquito|mother|motion|motor|mountain|mouse|move|movie|much|muffin|mule|multiply|muscle|museum|mushroom|music|must|mutual|myself|mystery|myth|naive|name|napkin|narrow|nasty|nation|nature|near|neck|need|negative|neglect|neither|nephew|nerve|nest|net|network|neutral|never|news|next|nice|night|noble|noise|nominee|noodle|normal|north|nose|notable|note|nothing|notice|novel|now|nuclear|number|nurse|nut|oak|obey|object|oblige|obscure|observe|obtain|obvious|occur|ocean|october|odor|off|offer|office|often|oil|okay|old|olive|olympic|omit|once|one|onion|online|only|open|opera|opinion|oppose|option|orange|orbit|orchard|order|ordinary|organ|orient|original|orphan|ostrich|other|outdoor|outer|output|outside|oval|oven|over|own|owner|oxygen|oyster|ozone|pact|paddle|page|pair|palace|palm|panda|panel|panic|panther|paper|parade|parent|park|parrot|party|pass|patch|path|patient|patrol|pattern|pause|pave|payment|peace|peanut|pear|peasant|pelican|pen|penalty|pencil|people|pepper|perfect|permit|person|pet|phone|photo|phrase|physical|piano|picnic|picture|piece|pig|pigeon|pill|pilot|pink|pioneer|pipe|pistol|pitch|pizza|place|planet|plastic|plate|play|please|pledge|pluck|plug|plunge|poem|poet|point|polar|pole|police|pond|pony|pool|popular|portion|position|possible|post|potato|pottery|poverty|powder|power|practice|praise|predict|prefer|prepare|present|pretty|prevent|price|pride|primary|print|priority|prison|private|prize|problem|process|produce|profit|program|project|promote|proof|property|prosper|protect|proud|provide|public|pudding|pull|pulp|pulse|pumpkin|punch|pupil|puppy|purchase|purity|purpose|purse|push|put|puzzle|pyramid|quality|quantum|quarter|question|quick|quit|quiz|quote|rabbit|raccoon|race|rack|radar|radio|rail|rain|raise|rally|ramp|ranch|random|range|rapid|rare|rate|rather|raven|raw|razor|ready|real|reason|rebel|rebuild|recall|receive|recipe|record|recycle|reduce|reflect|reform|refuse|region|regret|regular|reject|relax|release|relief|rely|remain|remember|remind|remove|render|renew|rent|reopen|repair|repeat|replace|report|require|rescue|resemble|resist|resource|response|result|retire|retreat|return|reunion|reveal|review|reward|rhythm|rib|ribbon|rice|rich|ride|ridge|rifle|right|rigid|ring|riot|ripple|risk|ritual|rival|river|road|roast|robot|robust|rocket|romance|roof|rookie|room|rose|rotate|rough|round|route|royal|rubber|rude|rug|rule|run|runway|rural|sad|saddle|sadness|safe|sail|salad|salmon|salon|salt|salute|same|sample|sand|satisfy|satoshi|sauce|sausage|save|say|scale|scan|scare|scatter|scene|scheme|school|science|scissors|scorpion|scout|scrap|screen|script|scrub|sea|search|season|seat|second|secret|section|security|seed|seek|segment|select|sell|seminar|senior|sense|sentence|series|service|session|settle|setup|seven|shadow|shaft|shallow|share|shed|shell|sheriff|shield|shift|shine|ship|shiver|shock|shoe|shoot|shop|short|shoulder|shove|shrimp|shrug|shuffle|shy|sibling|sick|side|siege|sight|sign|silent|silk|silly|silver|similar|simple|since|sing|siren|sister|situate|six|size|skate|sketch|ski|skill|skin|skirt|skull|slab|slam|sleep|slender|slice|slide|slight|slim|slogan|slot|slow|slush|small|smart|smile|smoke|smooth|snack|snake|snap|sniff|snow|soap|soccer|social|sock|soda|soft|solar|soldier|solid|solution|solve|someone|song|soon|sorry|sort|soul|sound|soup|source|south|space|spare|spatial|spawn|speak|special|speed|spell|spend|sphere|spice|spider|spike|spin|spirit|split|spoil|sponsor|spoon|sport|spot|spray|spread|spring|spy|square|squeeze|squirrel|stable|stadium|staff|stage|stairs|stamp|stand|start|state|stay|steak|steel|stem|step|stereo|stick|still|sting|stock|stomach|stone|stool|story|stove|strategy|street|strike|strong|struggle|student|stuff|stumble|style|subject|submit|subway|success|such|sudden|suffer|sugar|suggest|suit|summer|sun|sunny|sunset|super|supply|supreme|sure|surface|surge|surprise|surround|survey|suspect|sustain|swallow|swamp|swap|swarm|swear|sweet|swift|swim|swing|switch|sword|symbol|symptom|syrup|system|table|tackle|tag|tail|talent|talk|tank|tape|target|task|taste|tattoo|taxi|teach|team|tell|ten|tenant|tennis|tent|term|test|text|thank|that|theme|then|theory|there|they|thing|this|thought|three|thrive|throw|thumb|thunder|ticket|tide|tiger|tilt|timber|time|tiny|tip|tired|tissue|title|toast|tobacco|today|toddler|toe|together|toilet|token|tomato|tomorrow|tone|tongue|tonight|tool|tooth|top|topic|topple|torch|tornado|tortoise|toss|total|tourist|toward|tower|town|toy|track|trade|traffic|tragic|train|transfer|trap|trash|travel|tray|treat|tree|trend|trial|tribe|trick|trigger|trim|trip|trophy|trouble|truck|true|truly|trumpet|trust|truth|try|tube|tuition|tumble|tuna|tunnel|turkey|turn|turtle|twelve|twenty|twice|twin|twist|two|type|typical|ugly|umbrella|unable|unaware|uncle|uncover|under|undo|unfair|unfold|unhappy|uniform|unique|unit|universe|unknown|unlock|until|unusual|unveil|update|upgrade|uphold|upon|upper|upset|urban|urge|usage|use|used|useful|useless|usual|utility|vacant|vacuum|vague|valid|valley|valve|van|vanish|vapor|various|vast|vault|vehicle|velvet|vendor|venture|venue|verb|verify|version|very|vessel|veteran|viable|vibrant|vicious|victory|video|view|village|vintage|violin|virtual|virus|visa|visit|visual|vital|vivid|vocal|voice|void|volcano|volume|vote|voyage|wage|wagon|wait|walk|wall|walnut|want|warfare|warm|warrior|wash|wasp|waste|water|wave|way|wealth|weapon|wear|weasel|weather|web|wedding|weekend|weird|welcome|west|wet|whale|what|wheat|wheel|when|where|whip|whisper|wide|width|wife|wild|will|win|window|wine|wing|wink|winner|winter|wire|wisdom|wise|wish|witness|wolf|woman|wonder|wood|wool|word|work|world|worry|worth|wrap|wreck|wrestle|wrist|write|wrong|yard|year|yellow|you|young|youth|zebra|zero|zone|zoo'.split('|');\n"],"names":[],"mappings":";;;;uCAAe,8zZAA8zZ,KAAK,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1201, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/mnemonic/bip39.js"],"sourcesContent":["import { stringToU8a, u8aToU8a } from '@polkadot/util';\nimport { pbkdf2Encode } from '../pbkdf2/index.js';\nimport { randomAsU8a } from '../random/index.js';\nimport { sha256AsU8a } from '../sha/index.js';\nimport DEFAULT_WORDLIST from './wordlists/en.js';\nconst INVALID_MNEMONIC = 'Invalid mnemonic';\nconst INVALID_ENTROPY = 'Invalid entropy';\nconst INVALID_CHECKSUM = 'Invalid mnemonic checksum';\n/** @internal */\nfunction normalize(str) {\n    return (str || '').normalize('NFKD');\n}\n/** @internal */\nfunction binaryToByte(bin) {\n    return parseInt(bin, 2);\n}\n/** @internal */\nfunction bytesToBinary(bytes) {\n    return bytes.map((x) => x.toString(2).padStart(8, '0')).join('');\n}\n/** @internal */\nfunction deriveChecksumBits(entropyBuffer) {\n    return bytesToBinary(Array.from(sha256AsU8a(entropyBuffer))).slice(0, (entropyBuffer.length * 8) / 32);\n}\n/*\n * @param mnemonic - The BIP-39 mnemonic phrase to derive the secret from.\n * @param password - Optional: password to secure the seed (default: empty string).\n * @param rounds - Optional: Number of PBKDF2 iterations to run (default: 210000).\n*/\nexport function mnemonicToSeedSync(mnemonic, password, rounds) {\n    return pbkdf2Encode(stringToU8a(normalize(mnemonic)), stringToU8a(`mnemonic${normalize(password)}`), rounds).password;\n}\nexport function mnemonicToEntropy(mnemonic, wordlist = DEFAULT_WORDLIST) {\n    const words = normalize(mnemonic).split(' ');\n    if (words.length % 3 !== 0) {\n        throw new Error(INVALID_MNEMONIC);\n    }\n    // convert word indices to 11 bit binary strings\n    const bits = words\n        .map((word) => {\n        const index = wordlist.indexOf(word);\n        if (index === -1) {\n            throw new Error(INVALID_MNEMONIC);\n        }\n        return index.toString(2).padStart(11, '0');\n    })\n        .join('');\n    // split the binary string into ENT/CS\n    const dividerIndex = Math.floor(bits.length / 33) * 32;\n    const entropyBits = bits.slice(0, dividerIndex);\n    const checksumBits = bits.slice(dividerIndex);\n    // calculate the checksum and compare\n    const matched = entropyBits.match(/(.{1,8})/g);\n    const entropyBytes = matched?.map(binaryToByte);\n    if (!entropyBytes || (entropyBytes.length % 4 !== 0) || (entropyBytes.length < 16) || (entropyBytes.length > 32)) {\n        throw new Error(INVALID_ENTROPY);\n    }\n    const entropy = u8aToU8a(entropyBytes);\n    if (deriveChecksumBits(entropy) !== checksumBits) {\n        throw new Error(INVALID_CHECKSUM);\n    }\n    return entropy;\n}\nexport function entropyToMnemonic(entropy, wordlist = DEFAULT_WORDLIST) {\n    // 128 <= ENT <= 256\n    if ((entropy.length % 4 !== 0) || (entropy.length < 16) || (entropy.length > 32)) {\n        throw new Error(INVALID_ENTROPY);\n    }\n    const matched = `${bytesToBinary(Array.from(entropy))}${deriveChecksumBits(entropy)}`.match(/(.{1,11})/g);\n    const mapped = matched?.map((b) => wordlist[binaryToByte(b)]);\n    if (!mapped || (mapped.length < 12)) {\n        throw new Error('Unable to map entropy to mnemonic');\n    }\n    return mapped.join(' ');\n}\nexport function generateMnemonic(numWords, wordlist) {\n    return entropyToMnemonic(randomAsU8a((numWords / 3) * 4), wordlist);\n}\nexport function validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    }\n    catch {\n        return false;\n    }\n    return true;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;AACA,MAAM,mBAAmB;AACzB,MAAM,kBAAkB;AACxB,MAAM,mBAAmB;AACzB,cAAc,GACd,SAAS,UAAU,GAAG;IAClB,OAAO,CAAC,OAAO,EAAE,EAAE,SAAS,CAAC;AACjC;AACA,cAAc,GACd,SAAS,aAAa,GAAG;IACrB,OAAO,SAAS,KAAK;AACzB;AACA,cAAc,GACd,SAAS,cAAc,KAAK;IACxB,OAAO,MAAM,GAAG,CAAC,CAAC,IAAM,EAAE,QAAQ,CAAC,GAAG,QAAQ,CAAC,GAAG,MAAM,IAAI,CAAC;AACjE;AACA,cAAc,GACd,SAAS,mBAAmB,aAAa;IACrC,OAAO,cAAc,MAAM,IAAI,CAAC,IAAA,2KAAW,EAAC,iBAAiB,KAAK,CAAC,GAAG,AAAC,cAAc,MAAM,GAAG,IAAK;AACvG;AAMO,SAAS,mBAAmB,QAAQ,EAAE,QAAQ,EAAE,MAAM;IACzD,OAAO,IAAA,gLAAY,EAAC,IAAA,oKAAW,EAAC,UAAU,YAAY,IAAA,oKAAW,EAAC,CAAC,QAAQ,EAAE,UAAU,WAAW,GAAG,QAAQ,QAAQ;AACzH;AACO,SAAS,kBAAkB,QAAQ,EAAE,WAAW,sLAAgB;IACnE,MAAM,QAAQ,UAAU,UAAU,KAAK,CAAC;IACxC,IAAI,MAAM,MAAM,GAAG,MAAM,GAAG;QACxB,MAAM,IAAI,MAAM;IACpB;IACA,gDAAgD;IAChD,MAAM,OAAO,MACR,GAAG,CAAC,CAAC;QACN,MAAM,QAAQ,SAAS,OAAO,CAAC;QAC/B,IAAI,UAAU,CAAC,GAAG;YACd,MAAM,IAAI,MAAM;QACpB;QACA,OAAO,MAAM,QAAQ,CAAC,GAAG,QAAQ,CAAC,IAAI;IAC1C,GACK,IAAI,CAAC;IACV,sCAAsC;IACtC,MAAM,eAAe,KAAK,KAAK,CAAC,KAAK,MAAM,GAAG,MAAM;IACpD,MAAM,cAAc,KAAK,KAAK,CAAC,GAAG;IAClC,MAAM,eAAe,KAAK,KAAK,CAAC;IAChC,qCAAqC;IACrC,MAAM,UAAU,YAAY,KAAK,CAAC;IAClC,MAAM,eAAe,SAAS,IAAI;IAClC,IAAI,CAAC,gBAAiB,aAAa,MAAM,GAAG,MAAM,KAAO,aAAa,MAAM,GAAG,MAAQ,aAAa,MAAM,GAAG,IAAK;QAC9G,MAAM,IAAI,MAAM;IACpB;IACA,MAAM,UAAU,IAAA,8JAAQ,EAAC;IACzB,IAAI,mBAAmB,aAAa,cAAc;QAC9C,MAAM,IAAI,MAAM;IACpB;IACA,OAAO;AACX;AACO,SAAS,kBAAkB,OAAO,EAAE,WAAW,sLAAgB;IAClE,oBAAoB;IACpB,IAAI,AAAC,QAAQ,MAAM,GAAG,MAAM,KAAO,QAAQ,MAAM,GAAG,MAAQ,QAAQ,MAAM,GAAG,IAAK;QAC9E,MAAM,IAAI,MAAM;IACpB;IACA,MAAM,UAAU,GAAG,cAAc,MAAM,IAAI,CAAC,YAAY,mBAAmB,UAAU,CAAC,KAAK,CAAC;IAC5F,MAAM,SAAS,SAAS,IAAI,CAAC,IAAM,QAAQ,CAAC,aAAa,GAAG;IAC5D,IAAI,CAAC,UAAW,OAAO,MAAM,GAAG,IAAK;QACjC,MAAM,IAAI,MAAM;IACpB;IACA,OAAO,OAAO,IAAI,CAAC;AACvB;AACO,SAAS,iBAAiB,QAAQ,EAAE,QAAQ;IAC/C,OAAO,kBAAkB,IAAA,8KAAW,EAAC,AAAC,WAAW,IAAK,IAAI;AAC9D;AACO,SAAS,iBAAiB,QAAQ,EAAE,QAAQ;IAC/C,IAAI;QACA,kBAAkB,UAAU;IAChC,EACA,OAAM;QACF,OAAO;IACX;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1298, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/mnemonic/validate.js"],"sourcesContent":["import { hasBigInt } from '@polkadot/util';\nimport { bip39Validate, isReady } from '@polkadot/wasm-crypto';\nimport { validateMnemonic } from './bip39.js';\n/**\n * @name mnemonicValidate\n * @summary Validates a mnemonic input using [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki).\n * @example\n * <BR>\n *\n * ```javascript\n * import { mnemonicGenerate, mnemonicValidate } from '@polkadot/util-crypto';\n *\n * const mnemonic = mnemonicGenerate(); // => string\n * const isValidMnemonic = mnemonicValidate(mnemonic); // => boolean\n * ```\n */\nexport function mnemonicValidate(mnemonic, wordlist, onlyJs) {\n    return !hasBigInt || (!wordlist && !onlyJs && isReady())\n        ? bip39Validate(mnemonic)\n        : validateMnemonic(mnemonic, wordlist);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAcO,SAAS,iBAAiB,QAAQ,EAAE,QAAQ,EAAE,MAAM;IACvD,OAAO,CAAC,sJAAS,IAAK,CAAC,YAAY,CAAC,UAAU,IAAA,iLAAO,MAC/C,IAAA,uLAAa,EAAC,YACd,IAAA,qLAAgB,EAAC,UAAU;AACrC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1315, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/mnemonic/toLegacySeed.js"],"sourcesContent":["import { hasBigInt } from '@polkadot/util';\nimport { bip39ToSeed, isReady } from '@polkadot/wasm-crypto';\nimport { mnemonicToSeedSync } from './bip39.js';\nimport { mnemonicValidate } from './validate.js';\n/**\n * @name mnemonicToLegacySeed\n * @summary Creates a valid Ethereum/Bitcoin-compatible seed from a mnemonic input\n * @example\n * <BR>\n *\n * ```javascript\n * import { mnemonicGenerate, mnemonicToLegacySeed, mnemonicValidate } from '@polkadot/util-crypto';\n *\n * const mnemonic = mnemonicGenerate(); // => string\n * const isValidMnemonic = mnemonicValidate(mnemonic); // => boolean\n *\n * if (isValidMnemonic) {\n *   console.log(`Seed generated from mnemonic: ${mnemonicToLegacySeed(mnemonic)}`); => u8a\n * }\n * ```\n *\n * @param mnemonic - The BIP-39 mnemonic phrase to derive the secret from.\n * @param password - Optional: password to secure the seed (default: empty string).\n * @param onlyJs - Optional: If `true`, forces use of the JavaScript implementation instead of WASM.\n * @param byteLength - Optional: Either 32 or 64. Default is 32\n * @param rounds - Optional: Number of PBKDF2 iterations to run (default: 210000).\n*/\nexport function mnemonicToLegacySeed(mnemonic, password = '', onlyJs, byteLength = 32, rounds) {\n    if (!mnemonicValidate(mnemonic)) {\n        throw new Error('Invalid bip39 mnemonic specified');\n    }\n    else if (![32, 64].includes(byteLength)) {\n        throw new Error(`Invalid seed length ${byteLength}, expected 32 or 64`);\n    }\n    return byteLength === 32\n        ? !hasBigInt || (!onlyJs && isReady())\n            ? bip39ToSeed(mnemonic, password)\n            : mnemonicToSeedSync(mnemonic, password, rounds).subarray(0, 32)\n        : mnemonicToSeedSync(mnemonic, password, rounds);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAwBO,SAAS,qBAAqB,QAAQ,EAAE,WAAW,EAAE,EAAE,MAAM,EAAE,aAAa,EAAE,EAAE,MAAM;IACzF,IAAI,CAAC,IAAA,wLAAgB,EAAC,WAAW;QAC7B,MAAM,IAAI,MAAM;IACpB,OACK,IAAI,CAAC;QAAC;QAAI;KAAG,CAAC,QAAQ,CAAC,aAAa;QACrC,MAAM,IAAI,MAAM,CAAC,oBAAoB,EAAE,WAAW,mBAAmB,CAAC;IAC1E;IACA,OAAO,eAAe,KAChB,CAAC,sJAAS,IAAK,CAAC,UAAU,IAAA,iLAAO,MAC7B,IAAA,qLAAW,EAAC,UAAU,YACtB,IAAA,uLAAkB,EAAC,UAAU,UAAU,QAAQ,QAAQ,CAAC,GAAG,MAC/D,IAAA,uLAAkB,EAAC,UAAU,UAAU;AACjD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1342, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/mnemonic/toEntropy.js"],"sourcesContent":["import { hasBigInt } from '@polkadot/util';\nimport { bip39ToEntropy, isReady } from '@polkadot/wasm-crypto';\nimport { mnemonicToEntropy as jsToEntropy } from './bip39.js';\nexport function mnemonicToEntropy(mnemonic, wordlist, onlyJs) {\n    return !hasBigInt || (!wordlist && !onlyJs && isReady())\n        ? bip39ToEntropy(mnemonic)\n        : jsToEntropy(mnemonic, wordlist);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AACO,SAAS,kBAAkB,QAAQ,EAAE,QAAQ,EAAE,MAAM;IACxD,OAAO,CAAC,sJAAS,IAAK,CAAC,YAAY,CAAC,UAAU,IAAA,iLAAO,MAC/C,IAAA,wLAAc,EAAC,YACf,IAAA,sLAAW,EAAC,UAAU;AAChC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1359, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/mnemonic/toMiniSecret.js"],"sourcesContent":["import { stringToU8a } from '@polkadot/util';\nimport { bip39ToMiniSecret, isReady } from '@polkadot/wasm-crypto';\nimport { pbkdf2Encode } from '../pbkdf2/index.js';\nimport { mnemonicToEntropy } from './toEntropy.js';\nimport { mnemonicValidate } from './validate.js';\n/**\n * @param mnemonic - The BIP-39 mnemonic phrase to derive the secret from.\n * @param password - Optional: password to secure the seed (default: empty string).\n * @param wordlist - Optional custom wordlist for mnemonic.\n * @param onlyJs - Optional: If `true`, forces use of the JavaScript implementation instead of WASM.\n * @param rounds - Optional: Number of PBKDF2 iterations to run (default: 210000 (when onlyJS = true) or 2048 (when onlyJS = false).\n*/\nexport function mnemonicToMiniSecret(mnemonic, password = '', wordlist, onlyJs, rounds) {\n    if (!mnemonicValidate(mnemonic, wordlist, onlyJs)) {\n        throw new Error('Invalid bip39 mnemonic specified');\n    }\n    else if (!wordlist && !onlyJs && isReady()) {\n        return bip39ToMiniSecret(mnemonic, password);\n    }\n    const entropy = mnemonicToEntropy(mnemonic, wordlist);\n    const salt = stringToU8a(`mnemonic${password}`);\n    // return the first 32 bytes as the seed\n    return pbkdf2Encode(entropy, salt, rounds).password.slice(0, 32);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAQO,SAAS,qBAAqB,QAAQ,EAAE,WAAW,EAAE,EAAE,QAAQ,EAAE,MAAM,EAAE,MAAM;IAClF,IAAI,CAAC,IAAA,wLAAgB,EAAC,UAAU,UAAU,SAAS;QAC/C,MAAM,IAAI,MAAM;IACpB,OACK,IAAI,CAAC,YAAY,CAAC,UAAU,IAAA,iLAAO,KAAI;QACxC,OAAO,IAAA,2LAAiB,EAAC,UAAU;IACvC;IACA,MAAM,UAAU,IAAA,0LAAiB,EAAC,UAAU;IAC5C,MAAM,OAAO,IAAA,oKAAW,EAAC,CAAC,QAAQ,EAAE,UAAU;IAC9C,wCAAwC;IACxC,OAAO,IAAA,gLAAY,EAAC,SAAS,MAAM,QAAQ,QAAQ,CAAC,KAAK,CAAC,GAAG;AACjE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1388, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/sr25519/pair/fromSeed.js"],"sourcesContent":["import { u8aToU8a } from '@polkadot/util';\nimport { sr25519KeypairFromSeed } from '@polkadot/wasm-crypto';\nimport { sr25519PairFromU8a } from './fromU8a.js';\n/**\n * @name sr25519PairFromSeed\n * @description Returns a object containing a `publicKey` & `secretKey` generated from the supplied seed.\n */\nexport function sr25519PairFromSeed(seed) {\n    const seedU8a = u8aToU8a(seed);\n    if (seedU8a.length !== 32) {\n        throw new Error(`Expected a seed matching 32 bytes, found ${seedU8a.length}`);\n    }\n    return sr25519PairFromU8a(sr25519KeypairFromSeed(seedU8a));\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAKO,SAAS,oBAAoB,IAAI;IACpC,MAAM,UAAU,IAAA,8JAAQ,EAAC;IACzB,IAAI,QAAQ,MAAM,KAAK,IAAI;QACvB,MAAM,IAAI,MAAM,CAAC,yCAAyC,EAAE,QAAQ,MAAM,EAAE;IAChF;IACA,OAAO,IAAA,gMAAkB,EAAC,IAAA,gMAAsB,EAAC;AACrD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1409, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/ed25519/sign.js"],"sourcesContent":["import { ed25519 } from '@noble/curves/ed25519';\nimport { hasBigInt, u8aToU8a } from '@polkadot/util';\nimport { ed25519Sign as wasmSign, isReady } from '@polkadot/wasm-crypto';\n/**\n * @name ed25519Sign\n * @summary Signs a message using the supplied secretKey\n * @description\n * Returns message signature of `message`, using the `secretKey`.\n * @example\n * <BR>\n *\n * ```javascript\n * import { ed25519Sign } from '@polkadot/util-crypto';\n *\n * ed25519Sign([...], [...]); // => [...]\n * ```\n */\nexport function ed25519Sign(message, { publicKey, secretKey }, onlyJs) {\n    if (!secretKey) {\n        throw new Error('Expected a valid secretKey');\n    }\n    else if (!publicKey) {\n        throw new Error('Expected a valid publicKey');\n    }\n    const messageU8a = u8aToU8a(message);\n    const privateU8a = secretKey.subarray(0, 32);\n    return !hasBigInt || (!onlyJs && isReady())\n        ? wasmSign(publicKey, privateU8a, messageU8a)\n        : ed25519.sign(messageU8a, privateU8a);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AAAA;AACA;;;;AAeO,SAAS,YAAY,OAAO,EAAE,EAAE,SAAS,EAAE,SAAS,EAAE,EAAE,MAAM;IACjE,IAAI,CAAC,WAAW;QACZ,MAAM,IAAI,MAAM;IACpB,OACK,IAAI,CAAC,WAAW;QACjB,MAAM,IAAI,MAAM;IACpB;IACA,MAAM,aAAa,IAAA,8JAAQ,EAAC;IAC5B,MAAM,aAAa,UAAU,QAAQ,CAAC,GAAG;IACzC,OAAO,CAAC,sJAAS,IAAK,CAAC,UAAU,IAAA,iLAAO,MAClC,IAAA,qLAAQ,EAAC,WAAW,YAAY,cAChC,8JAAO,CAAC,IAAI,CAAC,YAAY;AACnC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1434, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/secp256k1/compress.js"],"sourcesContent":["import { secp256k1 } from '@noble/curves/secp256k1';\nimport { hasBigInt } from '@polkadot/util';\nimport { isReady, secp256k1Compress as wasm } from '@polkadot/wasm-crypto';\nexport function secp256k1Compress(publicKey, onlyJs) {\n    if (![33, 65].includes(publicKey.length)) {\n        throw new Error(`Invalid publicKey provided, received ${publicKey.length} bytes input`);\n    }\n    if (publicKey.length === 33) {\n        return publicKey;\n    }\n    return !hasBigInt || (!onlyJs && isReady())\n        ? wasm(publicKey)\n        : secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes(true);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AACO,SAAS,kBAAkB,SAAS,EAAE,MAAM;IAC/C,IAAI,CAAC;QAAC;QAAI;KAAG,CAAC,QAAQ,CAAC,UAAU,MAAM,GAAG;QACtC,MAAM,IAAI,MAAM,CAAC,qCAAqC,EAAE,UAAU,MAAM,CAAC,YAAY,CAAC;IAC1F;IACA,IAAI,UAAU,MAAM,KAAK,IAAI;QACzB,OAAO;IACX;IACA,OAAO,CAAC,sJAAS,IAAK,CAAC,UAAU,IAAA,iLAAO,MAClC,IAAA,2LAAI,EAAC,aACL,kKAAS,CAAC,eAAe,CAAC,OAAO,CAAC,WAAW,UAAU,CAAC;AAClE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1460, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/secp256k1/hasher.js"],"sourcesContent":["import { blake2AsU8a } from '../blake2/index.js';\nimport { keccakAsU8a } from '../keccak/index.js';\nexport function hasher(hashType, data, onlyJs) {\n    return hashType === 'keccak'\n        ? keccakAsU8a(data, undefined, onlyJs)\n        : blake2AsU8a(data, undefined, undefined, onlyJs);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AACO,SAAS,OAAO,QAAQ,EAAE,IAAI,EAAE,MAAM;IACzC,OAAO,aAAa,WACd,IAAA,8KAAW,EAAC,MAAM,WAAW,UAC7B,IAAA,8KAAW,EAAC,MAAM,WAAW,WAAW;AAClD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1475, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/secp256k1/sign.js"],"sourcesContent":["import { secp256k1 } from '@noble/curves/secp256k1';\nimport { bnToU8a, hasBigInt, u8aConcat } from '@polkadot/util';\nimport { isReady, secp256k1Sign as wasm } from '@polkadot/wasm-crypto';\nimport { BN_BE_256_OPTS } from '../bn.js';\nimport { hasher } from './hasher.js';\n/**\n * @name secp256k1Sign\n * @description Returns message signature of `message`, using the supplied pair\n */\nexport function secp256k1Sign(message, { secretKey }, hashType = 'blake2', onlyJs) {\n    if (secretKey?.length !== 32) {\n        throw new Error('Expected valid secp256k1 secretKey, 32-bytes');\n    }\n    const data = hasher(hashType, message, onlyJs);\n    if (!hasBigInt || (!onlyJs && isReady())) {\n        return wasm(data, secretKey);\n    }\n    const signature = secp256k1.sign(data, secretKey, { lowS: true });\n    return u8aConcat(bnToU8a(signature.r, BN_BE_256_OPTS), bnToU8a(signature.s, BN_BE_256_OPTS), new Uint8Array([signature.recovery || 0]));\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;;;;;;AAKO,SAAS,cAAc,OAAO,EAAE,EAAE,SAAS,EAAE,EAAE,WAAW,QAAQ,EAAE,MAAM;IAC7E,IAAI,WAAW,WAAW,IAAI;QAC1B,MAAM,IAAI,MAAM;IACpB;IACA,MAAM,OAAO,IAAA,6KAAM,EAAC,UAAU,SAAS;IACvC,IAAI,CAAC,sJAAS,IAAK,CAAC,UAAU,IAAA,iLAAO,KAAK;QACtC,OAAO,IAAA,uLAAI,EAAC,MAAM;IACtB;IACA,MAAM,YAAY,kKAAS,CAAC,IAAI,CAAC,MAAM,WAAW;QAAE,MAAM;IAAK;IAC/D,OAAO,IAAA,gKAAS,EAAC,IAAA,4JAAO,EAAC,UAAU,CAAC,EAAE,oKAAc,GAAG,IAAA,4JAAO,EAAC,UAAU,CAAC,EAAE,oKAAc,GAAG,IAAI,WAAW;QAAC,UAAU,QAAQ,IAAI;KAAE;AACzI","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1510, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/ed25519/verify.js"],"sourcesContent":["import { ed25519 } from '@noble/curves/ed25519';\nimport { hasBigInt, u8aToU8a } from '@polkadot/util';\nimport { ed25519Verify as wasmVerify, isReady } from '@polkadot/wasm-crypto';\n/**\n * @name ed25519Sign\n * @summary Verifies the signature on the supplied message.\n * @description\n * Verifies the `signature` on `message` with the supplied `publicKey`. Returns `true` on sucess, `false` otherwise.\n * @example\n * <BR>\n *\n * ```javascript\n * import { ed25519Verify } from '@polkadot/util-crypto';\n *\n * ed25519Verify([...], [...], [...]); // => true/false\n * ```\n */\nexport function ed25519Verify(message, signature, publicKey, onlyJs) {\n    const messageU8a = u8aToU8a(message);\n    const publicKeyU8a = u8aToU8a(publicKey);\n    const signatureU8a = u8aToU8a(signature);\n    if (publicKeyU8a.length !== 32) {\n        throw new Error(`Invalid publicKey, received ${publicKeyU8a.length}, expected 32`);\n    }\n    else if (signatureU8a.length !== 64) {\n        throw new Error(`Invalid signature, received ${signatureU8a.length} bytes, expected 64`);\n    }\n    try {\n        return !hasBigInt || (!onlyJs && isReady())\n            ? wasmVerify(signatureU8a, messageU8a, publicKeyU8a)\n            : ed25519.verify(signatureU8a, messageU8a, publicKeyU8a);\n    }\n    catch {\n        return false;\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AAAA;AACA;;;;AAeO,SAAS,cAAc,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE,MAAM;IAC/D,MAAM,aAAa,IAAA,8JAAQ,EAAC;IAC5B,MAAM,eAAe,IAAA,8JAAQ,EAAC;IAC9B,MAAM,eAAe,IAAA,8JAAQ,EAAC;IAC9B,IAAI,aAAa,MAAM,KAAK,IAAI;QAC5B,MAAM,IAAI,MAAM,CAAC,4BAA4B,EAAE,aAAa,MAAM,CAAC,aAAa,CAAC;IACrF,OACK,IAAI,aAAa,MAAM,KAAK,IAAI;QACjC,MAAM,IAAI,MAAM,CAAC,4BAA4B,EAAE,aAAa,MAAM,CAAC,mBAAmB,CAAC;IAC3F;IACA,IAAI;QACA,OAAO,CAAC,sJAAS,IAAK,CAAC,UAAU,IAAA,iLAAO,MAClC,IAAA,uLAAU,EAAC,cAAc,YAAY,gBACrC,8JAAO,CAAC,MAAM,CAAC,cAAc,YAAY;IACnD,EACA,OAAM;QACF,OAAO;IACX;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1540, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/secp256k1/recover.js"],"sourcesContent":["import { secp256k1 } from '@noble/curves/secp256k1';\nimport { hasBigInt, u8aToU8a } from '@polkadot/util';\nimport { isReady, secp256k1Recover as wasm } from '@polkadot/wasm-crypto';\nimport { secp256k1Compress } from './compress.js';\nimport { secp256k1Expand } from './expand.js';\n/**\n * @name secp256k1Recover\n * @description Recovers a publicKey from the supplied signature\n */\nexport function secp256k1Recover(msgHash, signature, recovery, hashType = 'blake2', onlyJs) {\n    const sig = u8aToU8a(signature).subarray(0, 64);\n    const msg = u8aToU8a(msgHash);\n    const publicKey = !hasBigInt || (!onlyJs && isReady())\n        ? wasm(msg, sig, recovery)\n        : secp256k1.Signature\n            .fromCompact(sig)\n            .addRecoveryBit(recovery)\n            .recoverPublicKey(msg)\n            .toRawBytes();\n    if (!publicKey) {\n        throw new Error('Unable to recover publicKey from signature');\n    }\n    return hashType === 'keccak'\n        ? secp256k1Expand(publicKey, onlyJs)\n        : secp256k1Compress(publicKey, onlyJs);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AAAA;AACA;AACA;AACA;;;;;;AAKO,SAAS,iBAAiB,OAAO,EAAE,SAAS,EAAE,QAAQ,EAAE,WAAW,QAAQ,EAAE,MAAM;IACtF,MAAM,MAAM,IAAA,8JAAQ,EAAC,WAAW,QAAQ,CAAC,GAAG;IAC5C,MAAM,MAAM,IAAA,8JAAQ,EAAC;IACrB,MAAM,YAAY,CAAC,sJAAS,IAAK,CAAC,UAAU,IAAA,iLAAO,MAC7C,IAAA,0LAAI,EAAC,KAAK,KAAK,YACf,kKAAS,CAAC,SAAS,CAChB,WAAW,CAAC,KACZ,cAAc,CAAC,UACf,gBAAgB,CAAC,KACjB,UAAU;IACnB,IAAI,CAAC,WAAW;QACZ,MAAM,IAAI,MAAM;IACpB;IACA,OAAO,aAAa,WACd,IAAA,sLAAe,EAAC,WAAW,UAC3B,IAAA,0LAAiB,EAAC,WAAW;AACvC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1568, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/secp256k1/verify.js"],"sourcesContent":["import { u8aEq, u8aToU8a } from '@polkadot/util';\nimport { hasher } from './hasher.js';\nimport { secp256k1Recover } from './recover.js';\n/**\n * @name secp256k1Verify\n * @description Verifies the signature of `message`, using the supplied pair\n */\nexport function secp256k1Verify(msgHash, signature, address, hashType = 'blake2', onlyJs) {\n    const sig = u8aToU8a(signature);\n    if (sig.length !== 65) {\n        throw new Error(`Expected signature with 65 bytes, ${sig.length} found instead`);\n    }\n    const publicKey = secp256k1Recover(hasher(hashType, msgHash), sig, sig[64], hashType, onlyJs);\n    const signerAddr = hasher(hashType, publicKey, onlyJs);\n    const inputAddr = u8aToU8a(address);\n    // for Ethereum (keccak) the last 20 bytes is the address\n    return u8aEq(publicKey, inputAddr) || (hashType === 'keccak'\n        ? u8aEq(signerAddr.slice(-20), inputAddr.slice(-20))\n        : u8aEq(signerAddr, inputAddr));\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AACA;;;;AAKO,SAAS,gBAAgB,OAAO,EAAE,SAAS,EAAE,OAAO,EAAE,WAAW,QAAQ,EAAE,MAAM;IACpF,MAAM,MAAM,IAAA,8JAAQ,EAAC;IACrB,IAAI,IAAI,MAAM,KAAK,IAAI;QACnB,MAAM,IAAI,MAAM,CAAC,kCAAkC,EAAE,IAAI,MAAM,CAAC,cAAc,CAAC;IACnF;IACA,MAAM,YAAY,IAAA,wLAAgB,EAAC,IAAA,6KAAM,EAAC,UAAU,UAAU,KAAK,GAAG,CAAC,GAAG,EAAE,UAAU;IACtF,MAAM,aAAa,IAAA,6KAAM,EAAC,UAAU,WAAW;IAC/C,MAAM,YAAY,IAAA,8JAAQ,EAAC;IAC3B,yDAAyD;IACzD,OAAO,IAAA,wJAAK,EAAC,WAAW,cAAc,CAAC,aAAa,WAC9C,IAAA,wJAAK,EAAC,WAAW,KAAK,CAAC,CAAC,KAAK,UAAU,KAAK,CAAC,CAAC,OAC9C,IAAA,wJAAK,EAAC,YAAY,UAAU;AACtC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1594, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/sr25519/verify.js"],"sourcesContent":["import { u8aToU8a } from '@polkadot/util';\nimport { sr25519Verify as wasmVerify } from '@polkadot/wasm-crypto';\n/**\n * @name sr25519Verify\n * @description Verifies the signature of `message`, using the supplied pair\n */\nexport function sr25519Verify(message, signature, publicKey) {\n    const publicKeyU8a = u8aToU8a(publicKey);\n    const signatureU8a = u8aToU8a(signature);\n    if (publicKeyU8a.length !== 32) {\n        throw new Error(`Invalid publicKey, received ${publicKeyU8a.length} bytes, expected 32`);\n    }\n    else if (signatureU8a.length !== 64) {\n        throw new Error(`Invalid signature, received ${signatureU8a.length} bytes, expected 64`);\n    }\n    return wasmVerify(signatureU8a, u8aToU8a(message), publicKeyU8a);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAKO,SAAS,cAAc,OAAO,EAAE,SAAS,EAAE,SAAS;IACvD,MAAM,eAAe,IAAA,8JAAQ,EAAC;IAC9B,MAAM,eAAe,IAAA,8JAAQ,EAAC;IAC9B,IAAI,aAAa,MAAM,KAAK,IAAI;QAC5B,MAAM,IAAI,MAAM,CAAC,4BAA4B,EAAE,aAAa,MAAM,CAAC,mBAAmB,CAAC;IAC3F,OACK,IAAI,aAAa,MAAM,KAAK,IAAI;QACjC,MAAM,IAAI,MAAM,CAAC,4BAA4B,EAAE,aAAa,MAAM,CAAC,mBAAmB,CAAC;IAC3F;IACA,OAAO,IAAA,uLAAU,EAAC,cAAc,IAAA,8JAAQ,EAAC,UAAU;AACvD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1616, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/signature/verify.js"],"sourcesContent":["import { u8aIsWrapped, u8aToU8a, u8aUnwrapBytes, u8aWrapBytes } from '@polkadot/util';\nimport { decodeAddress } from '../address/decode.js';\nimport { ed25519Verify } from '../ed25519/verify.js';\nimport { secp256k1Verify } from '../secp256k1/verify.js';\nimport { sr25519Verify } from '../sr25519/verify.js';\nconst secp256k1VerifyHasher = (hashType) => (message, signature, publicKey) => secp256k1Verify(message, signature, publicKey, hashType, true);\nconst VERIFIERS_ECDSA = [\n    ['ecdsa', secp256k1VerifyHasher('blake2')],\n    ['ethereum', secp256k1VerifyHasher('keccak')]\n];\nconst VERIFIERS = [\n    ['ed25519', ed25519Verify],\n    ['sr25519', sr25519Verify]\n];\nfunction verifyDetect(result, { message, publicKey, signature }, verifiers = [...VERIFIERS, ...VERIFIERS_ECDSA]) {\n    result.isValid = verifiers.some(([crypto, verify]) => {\n        try {\n            if (verify(message, signature, publicKey)) {\n                result.crypto = crypto;\n                return true;\n            }\n        }\n        catch {\n            // do nothing, result.isValid still set to false\n        }\n        return false;\n    });\n    return result;\n}\nfunction verifyMultisig(result, { message, publicKey, signature }) {\n    if (![0, 1, 2].includes(signature[0]) || ![65, 66].includes(signature.length)) {\n        throw new Error(`Unknown crypto type, expected signature prefix [0..2], found ${signature[0]}`);\n    }\n    // If the signature is 66 bytes it must be an ecdsa signature\n    // containing: prefix [1 byte] + signature [65] bytes.\n    // Remove the and then verify\n    if (signature.length === 66) {\n        result = verifyDetect(result, { message, publicKey, signature: signature.subarray(1) }, VERIFIERS_ECDSA);\n    }\n    else {\n        // The signature contains 65 bytes which is either\n        // - A ed25519 or sr25519 signature [1 byte prefix + 64 bytes]\n        // - An ecdsa signature [65 bytes]\n        result = verifyDetect(result, { message, publicKey, signature: signature.subarray(1) }, VERIFIERS);\n        if (!result.isValid) {\n            result = verifyDetect(result, { message, publicKey, signature }, VERIFIERS_ECDSA);\n        }\n        // If both failed, explicitly set crypto to 'none'\n        if (!result.isValid) {\n            result.crypto = 'none';\n        }\n    }\n    return result;\n}\nfunction getVerifyFn(signature) {\n    return [0, 1, 2].includes(signature[0]) && [65, 66].includes(signature.length)\n        ? verifyMultisig\n        : verifyDetect;\n}\nexport function signatureVerify(message, signature, addressOrPublicKey) {\n    const signatureU8a = u8aToU8a(signature);\n    if (![64, 65, 66].includes(signatureU8a.length)) {\n        throw new Error(`Invalid signature length, expected [64..66] bytes, found ${signatureU8a.length}`);\n    }\n    const publicKey = decodeAddress(addressOrPublicKey);\n    const input = { message: u8aToU8a(message), publicKey, signature: signatureU8a };\n    const result = { crypto: 'none', isValid: false, isWrapped: u8aIsWrapped(input.message, true), publicKey };\n    const isWrappedBytes = u8aIsWrapped(input.message, false);\n    const verifyFn = getVerifyFn(signatureU8a);\n    verifyFn(result, input);\n    if (result.crypto !== 'none' || (result.isWrapped && !isWrappedBytes)) {\n        return result;\n    }\n    input.message = isWrappedBytes\n        ? u8aUnwrapBytes(input.message)\n        : u8aWrapBytes(input.message);\n    return verifyFn(result, input);\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1756, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/sr25519/sign.js"],"sourcesContent":["import { u8aToU8a } from '@polkadot/util';\nimport { sr25519Sign as wasmSign } from '@polkadot/wasm-crypto';\n/**\n * @name sr25519Sign\n * @description Returns message signature of `message`, using the supplied pair\n */\nexport function sr25519Sign(message, { publicKey, secretKey }) {\n    if (publicKey?.length !== 32) {\n        throw new Error('Expected a valid publicKey, 32-bytes');\n    }\n    else if (secretKey?.length !== 64) {\n        throw new Error('Expected a valid secretKey, 64-bytes');\n    }\n    return wasmSign(publicKey, secretKey, u8aToU8a(message));\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAKO,SAAS,YAAY,OAAO,EAAE,EAAE,SAAS,EAAE,SAAS,EAAE;IACzD,IAAI,WAAW,WAAW,IAAI;QAC1B,MAAM,IAAI,MAAM;IACpB,OACK,IAAI,WAAW,WAAW,IAAI;QAC/B,MAAM,IAAI,MAAM;IACpB;IACA,OAAO,IAAA,qLAAQ,EAAC,WAAW,WAAW,IAAA,8JAAQ,EAAC;AACnD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1776, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/sr25519/vrfSign.js"],"sourcesContent":["import { u8aToU8a } from '@polkadot/util';\nimport { vrfSign } from '@polkadot/wasm-crypto';\nconst EMPTY_U8A = new Uint8Array();\n/**\n * @name sr25519VrfSign\n * @description Sign with sr25519 vrf signing (deterministic)\n */\nexport function sr25519VrfSign(message, { secretKey }, context = EMPTY_U8A, extra = EMPTY_U8A) {\n    if (secretKey?.length !== 64) {\n        throw new Error('Invalid secretKey, expected 64-bytes');\n    }\n    return vrfSign(secretKey, u8aToU8a(context), u8aToU8a(message), u8aToU8a(extra));\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AACA,MAAM,YAAY,IAAI;AAKf,SAAS,eAAe,OAAO,EAAE,EAAE,SAAS,EAAE,EAAE,UAAU,SAAS,EAAE,QAAQ,SAAS;IACzF,IAAI,WAAW,WAAW,IAAI;QAC1B,MAAM,IAAI,MAAM;IACpB;IACA,OAAO,IAAA,iLAAO,EAAC,WAAW,IAAA,8JAAQ,EAAC,UAAU,IAAA,8JAAQ,EAAC,UAAU,IAAA,8JAAQ,EAAC;AAC7E","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1795, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/sr25519/vrfVerify.js"],"sourcesContent":["import { u8aToU8a } from '@polkadot/util';\nimport { vrfVerify } from '@polkadot/wasm-crypto';\nconst EMPTY_U8A = new Uint8Array();\n/**\n * @name sr25519VrfVerify\n * @description Verify with sr25519 vrf verification\n */\nexport function sr25519VrfVerify(message, signOutput, publicKey, context = EMPTY_U8A, extra = EMPTY_U8A) {\n    const publicKeyU8a = u8aToU8a(publicKey);\n    const proofU8a = u8aToU8a(signOutput);\n    if (publicKeyU8a.length !== 32) {\n        throw new Error('Invalid publicKey, expected 32-bytes');\n    }\n    else if (proofU8a.length !== 96) {\n        throw new Error('Invalid vrfSign output, expected 96 bytes');\n    }\n    return vrfVerify(publicKeyU8a, u8aToU8a(context), u8aToU8a(message), u8aToU8a(extra), proofU8a);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AACA,MAAM,YAAY,IAAI;AAKf,SAAS,iBAAiB,OAAO,EAAE,UAAU,EAAE,SAAS,EAAE,UAAU,SAAS,EAAE,QAAQ,SAAS;IACnG,MAAM,eAAe,IAAA,8JAAQ,EAAC;IAC9B,MAAM,WAAW,IAAA,8JAAQ,EAAC;IAC1B,IAAI,aAAa,MAAM,KAAK,IAAI;QAC5B,MAAM,IAAI,MAAM;IACpB,OACK,IAAI,SAAS,MAAM,KAAK,IAAI;QAC7B,MAAM,IAAI,MAAM;IACpB;IACA,OAAO,IAAA,mLAAS,EAAC,cAAc,IAAA,8JAAQ,EAAC,UAAU,IAAA,8JAAQ,EAAC,UAAU,IAAA,8JAAQ,EAAC,QAAQ;AAC1F","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1818, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/nacl/tweetnacl.js"],"sourcesContent":["/* eslint-disable brace-style,camelcase,comma-spacing,curly,one-var,padding-line-between-statements,space-infix-ops */\nfunction L32(x, c) { return (x << c) | (x >>> (32 - c)); }\nfunction ld32(x, i) {\n    let u = x[i + 3] & 0xff;\n    u = (u << 8) | (x[i + 2] & 0xff);\n    u = (u << 8) | (x[i + 1] & 0xff);\n    return (u << 8) | (x[i + 0] & 0xff);\n}\nfunction st32(x, j, u) {\n    for (let i = 0; i < 4; i++) {\n        x[j + i] = u & 255;\n        u >>>= 8;\n    }\n}\nfunction vn(x, xi, y, yi, n) {\n    let d = 0;\n    for (let i = 0; i < n; i++)\n        d |= x[xi + i] ^ y[yi + i];\n    return (1 & ((d - 1) >>> 8)) - 1;\n}\nfunction core(out, inp, k, c, h) {\n    const w = new Uint32Array(16), x = new Uint32Array(16), y = new Uint32Array(16), t = new Uint32Array(4);\n    let i, j, m;\n    for (i = 0; i < 4; i++) {\n        x[5 * i] = ld32(c, 4 * i);\n        x[1 + i] = ld32(k, 4 * i);\n        x[6 + i] = ld32(inp, 4 * i);\n        x[11 + i] = ld32(k, 16 + 4 * i);\n    }\n    for (i = 0; i < 16; i++)\n        y[i] = x[i];\n    for (i = 0; i < 20; i++) {\n        for (j = 0; j < 4; j++) {\n            for (m = 0; m < 4; m++)\n                t[m] = x[(5 * j + 4 * m) % 16];\n            t[1] ^= L32((t[0] + t[3]) | 0, 7);\n            t[2] ^= L32((t[1] + t[0]) | 0, 9);\n            t[3] ^= L32((t[2] + t[1]) | 0, 13);\n            t[0] ^= L32((t[3] + t[2]) | 0, 18);\n            for (m = 0; m < 4; m++)\n                w[4 * j + (j + m) % 4] = t[m];\n        }\n        for (m = 0; m < 16; m++)\n            x[m] = w[m];\n    }\n    if (h) {\n        for (i = 0; i < 16; i++)\n            x[i] = (x[i] + y[i]) | 0;\n        for (i = 0; i < 4; i++) {\n            x[5 * i] = (x[5 * i] - ld32(c, 4 * i)) | 0;\n            x[6 + i] = (x[6 + i] - ld32(inp, 4 * i)) | 0;\n        }\n        for (i = 0; i < 4; i++) {\n            st32(out, 4 * i, x[5 * i]);\n            st32(out, 16 + 4 * i, x[6 + i]);\n        }\n    }\n    else {\n        for (i = 0; i < 16; i++)\n            st32(out, 4 * i, (x[i] + y[i]) | 0);\n    }\n}\nconst sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);\nfunction crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {\n    const z = new Uint8Array(16), x = new Uint8Array(64);\n    let u, i;\n    if (!b)\n        return 0;\n    for (i = 0; i < 16; i++)\n        z[i] = 0;\n    for (i = 0; i < 8; i++)\n        z[i] = n[i];\n    while (b >= 64) {\n        core(x, z, k, sigma, false);\n        for (i = 0; i < 64; i++)\n            c[cpos + i] = (m ? m[mpos + i] : 0) ^ x[i];\n        u = 1;\n        for (i = 8; i < 16; i++) {\n            u = u + (z[i] & 0xff) | 0;\n            z[i] = u & 0xff;\n            u >>>= 8;\n        }\n        b -= 64;\n        cpos += 64;\n        if (m)\n            mpos += 64;\n    }\n    if (b > 0) {\n        core(x, z, k, sigma, false);\n        for (i = 0; i < b; i++)\n            c[cpos + i] = (m ? m[mpos + i] : 0) ^ x[i];\n    }\n    return 0;\n}\nfunction crypto_stream_xor(c, cpos, m, mpos, d, n, k) {\n    const s = new Uint8Array(32);\n    core(s, n, k, sigma, true);\n    return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, n.subarray(16), s);\n}\nfunction add1305(h, c) {\n    let u = 0;\n    for (let j = 0; j < 17; j++) {\n        u = (u + ((h[j] + c[j]) | 0)) | 0;\n        h[j] = u & 255;\n        u >>>= 8;\n    }\n}\nconst minusp = new Uint32Array([5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 252]);\nfunction crypto_onetimeauth(out, outpos, m, mpos, n, k) {\n    let i, j, u;\n    const x = new Uint32Array(17), r = new Uint32Array(17), h = new Uint32Array(17), c = new Uint32Array(17), g = new Uint32Array(17);\n    for (j = 0; j < 17; j++)\n        r[j] = h[j] = 0;\n    for (j = 0; j < 16; j++)\n        r[j] = k[j];\n    r[3] &= 15;\n    r[4] &= 252;\n    r[7] &= 15;\n    r[8] &= 252;\n    r[11] &= 15;\n    r[12] &= 252;\n    r[15] &= 15;\n    while (n > 0) {\n        for (j = 0; j < 17; j++)\n            c[j] = 0;\n        for (j = 0; (j < 16) && (j < n); ++j)\n            c[j] = m[mpos + j];\n        c[j] = 1;\n        mpos += j;\n        n -= j;\n        add1305(h, c);\n        for (i = 0; i < 17; i++) {\n            x[i] = 0;\n            for (j = 0; j < 17; j++)\n                x[i] = (x[i] + (h[j] * ((j <= i) ? r[i - j] : ((320 * r[i + 17 - j]) | 0))) | 0) | 0;\n        }\n        for (i = 0; i < 17; i++)\n            h[i] = x[i];\n        u = 0;\n        for (j = 0; j < 16; j++) {\n            u = (u + h[j]) | 0;\n            h[j] = u & 255;\n            u >>>= 8;\n        }\n        u = (u + h[16]) | 0;\n        h[16] = u & 3;\n        u = (5 * (u >>> 2)) | 0;\n        for (j = 0; j < 16; j++) {\n            u = (u + h[j]) | 0;\n            h[j] = u & 255;\n            u >>>= 8;\n        }\n        u = (u + h[16]) | 0;\n        h[16] = u;\n    }\n    for (j = 0; j < 17; j++)\n        g[j] = h[j];\n    add1305(h, minusp);\n    const s = (-(h[16] >>> 7) | 0);\n    for (j = 0; j < 17; j++)\n        h[j] ^= s & (g[j] ^ h[j]);\n    for (j = 0; j < 16; j++)\n        c[j] = k[j + 16];\n    c[16] = 0;\n    add1305(h, c);\n    for (j = 0; j < 16; j++)\n        out[outpos + j] = h[j];\n    return 0;\n}\nfunction crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {\n    const x = new Uint8Array(16);\n    crypto_onetimeauth(x, 0, m, mpos, n, k);\n    return vn(h, hpos, x, 0, 16);\n}\nfunction crypto_secretbox(c, m, d, n, k) {\n    if (d < 32)\n        return -1;\n    crypto_stream_xor(c, 0, m, 0, d, n, k);\n    crypto_onetimeauth(c, 16, c, 32, d - 32, c);\n    for (let i = 0; i < 16; i++)\n        c[i] = 0;\n    return 0;\n}\nfunction crypto_secretbox_open(m, c, d, n, k) {\n    const x = new Uint8Array(32);\n    if (d < 32)\n        return -1;\n    crypto_stream_xor(x, 0, null, 0, 32, n, k);\n    if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)\n        return -1;\n    crypto_stream_xor(m, 0, c, 0, d, n, k);\n    for (let i = 0; i < 32; i++)\n        m[i] = 0;\n    return 0;\n}\nconst crypto_secretbox_KEYBYTES = 32;\nconst crypto_secretbox_NONCEBYTES = 24;\nconst crypto_secretbox_ZEROBYTES = 32;\nconst crypto_secretbox_BOXZEROBYTES = 16;\nfunction checkLengths(k, n) {\n    if (k.length !== crypto_secretbox_KEYBYTES)\n        throw new Error('bad key size');\n    if (n.length !== crypto_secretbox_NONCEBYTES)\n        throw new Error('bad nonce size');\n}\nfunction checkArrayTypes(...args) {\n    for (let i = 0, count = args.length; i < count; i++) {\n        if (!(args[i] instanceof Uint8Array))\n            throw new TypeError('unexpected type, use Uint8Array');\n    }\n}\nexport function naclSecretbox(msg, nonce, key) {\n    checkArrayTypes(msg, nonce, key);\n    checkLengths(key, nonce);\n    const m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);\n    const c = new Uint8Array(m.length);\n    for (let i = 0; i < msg.length; i++)\n        m[i + crypto_secretbox_ZEROBYTES] = msg[i];\n    crypto_secretbox(c, m, m.length, nonce, key);\n    return c.subarray(crypto_secretbox_BOXZEROBYTES);\n}\nexport function naclSecretboxOpen(box, nonce, key) {\n    checkArrayTypes(box, nonce, key);\n    checkLengths(key, nonce);\n    const c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);\n    const m = new Uint8Array(c.length);\n    for (let i = 0; i < box.length; i++)\n        c[i + crypto_secretbox_BOXZEROBYTES] = box[i];\n    if (c.length < 32)\n        return null;\n    if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)\n        return null;\n    return m.subarray(crypto_secretbox_ZEROBYTES);\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2062, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/nacl/decrypt.js"],"sourcesContent":["import { naclSecretboxOpen } from './tweetnacl.js';\n/**\n * @name naclDecrypt\n * @summary Decrypts a message using the supplied secretKey and nonce\n * @description\n * Returns an decrypted message, using the `secret` and `nonce`.\n * @example\n * <BR>\n *\n * ```javascript\n * import { naclDecrypt } from '@polkadot/util-crypto';\n *\n * naclDecrypt([...], [...], [...]); // => [...]\n * ```\n */\nexport function naclDecrypt(encrypted, nonce, secret) {\n    return naclSecretboxOpen(encrypted, nonce, secret);\n}\n"],"names":[],"mappings":";;;;AAAA;;AAeO,SAAS,YAAY,SAAS,EAAE,KAAK,EAAE,MAAM;IAChD,OAAO,IAAA,sLAAiB,EAAC,WAAW,OAAO;AAC/C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2075, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/scrypt/defaults.js"],"sourcesContent":["export const ALLOWED_PARAMS = [\n    { N: 1 << 13, p: 10, r: 8 },\n    { N: 1 << 14, p: 5, r: 8 },\n    { N: 1 << 15, p: 3, r: 8 },\n    { N: 1 << 15, p: 1, r: 8 },\n    { N: 1 << 16, p: 2, r: 8 },\n    { N: 1 << 17, p: 1, r: 8 }\n];\nexport const DEFAULT_PARAMS = {\n    N: 1 << 17,\n    p: 1,\n    r: 8\n};\n"],"names":[],"mappings":";;;;;;AAAO,MAAM,iBAAiB;IAC1B;QAAE,GAAG,KAAK;QAAI,GAAG;QAAI,GAAG;IAAE;IAC1B;QAAE,GAAG,KAAK;QAAI,GAAG;QAAG,GAAG;IAAE;IACzB;QAAE,GAAG,KAAK;QAAI,GAAG;QAAG,GAAG;IAAE;IACzB;QAAE,GAAG,KAAK;QAAI,GAAG;QAAG,GAAG;IAAE;IACzB;QAAE,GAAG,KAAK;QAAI,GAAG;QAAG,GAAG;IAAE;IACzB;QAAE,GAAG,KAAK;QAAI,GAAG;QAAG,GAAG;IAAE;CAC5B;AACM,MAAM,iBAAiB;IAC1B,GAAG,KAAK;IACR,GAAG;IACH,GAAG;AACP","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2122, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/scrypt/encode.js"],"sourcesContent":["import { scrypt as scryptJs } from '@noble/hashes/scrypt';\nimport { hasBigInt, objectSpread, u8aToU8a } from '@polkadot/util';\nimport { isReady, scrypt } from '@polkadot/wasm-crypto';\nimport { randomAsU8a } from '../random/asU8a.js';\nimport { DEFAULT_PARAMS } from './defaults.js';\nexport function scryptEncode(passphrase, salt = randomAsU8a(), params = DEFAULT_PARAMS, onlyJs) {\n    const u8a = u8aToU8a(passphrase);\n    return {\n        params,\n        password: !hasBigInt || (!onlyJs && isReady())\n            ? scrypt(u8a, salt, Math.log2(params.N), params.r, params.p)\n            : scryptJs(u8a, salt, objectSpread({ dkLen: 64 }, params)),\n        salt\n    };\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;;;;;;AACO,SAAS,aAAa,UAAU,EAAE,OAAO,IAAA,8KAAW,GAAE,EAAE,SAAS,oLAAc,EAAE,MAAM;IAC1F,MAAM,MAAM,IAAA,8JAAQ,EAAC;IACrB,OAAO;QACH;QACA,UAAU,CAAC,sJAAS,IAAK,CAAC,UAAU,IAAA,iLAAO,MACrC,IAAA,gLAAM,EAAC,KAAK,MAAM,KAAK,IAAI,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC,EAAE,OAAO,CAAC,IACzD,IAAA,4JAAQ,EAAC,KAAK,MAAM,IAAA,sKAAY,EAAC;YAAE,OAAO;QAAG,GAAG;QACtD;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2152, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/scrypt/fromU8a.js"],"sourcesContent":["import { u8aToBn } from '@polkadot/util';\nimport { BN_LE_OPTS } from '../bn.js';\nimport { ALLOWED_PARAMS } from './defaults.js';\nexport function scryptFromU8a(data) {\n    if (!(data instanceof Uint8Array)) {\n        throw new Error('Expected input to be a Uint8Array');\n    }\n    // Ensure the input is exactly 44 bytes: 32 for salt + 3 * 4 for N, p, r\n    if (data.length < 32 + 12) {\n        throw new Error(`Invalid input length: expected 44 bytes, found ${data.length}`);\n    }\n    const salt = data.subarray(0, 32);\n    const N = u8aToBn(data.subarray(32, 36), BN_LE_OPTS).toNumber();\n    const p = u8aToBn(data.subarray(36, 40), BN_LE_OPTS).toNumber();\n    const r = u8aToBn(data.subarray(40, 44), BN_LE_OPTS).toNumber();\n    if (N > (1 << 20) || p > 4 || r > 16) {\n        throw new Error('Scrypt parameters exceed safe limits');\n    }\n    const isAllowed = ALLOWED_PARAMS.some((preset) => preset.N === N && preset.p === p && preset.r === r);\n    if (!isAllowed) {\n        throw new Error('Invalid injected scrypt params found');\n    }\n    return { params: { N, p, r }, salt };\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AACO,SAAS,cAAc,IAAI;IAC9B,IAAI,CAAC,CAAC,gBAAgB,UAAU,GAAG;QAC/B,MAAM,IAAI,MAAM;IACpB;IACA,wEAAwE;IACxE,IAAI,KAAK,MAAM,GAAG,KAAK,IAAI;QACvB,MAAM,IAAI,MAAM,CAAC,+CAA+C,EAAE,KAAK,MAAM,EAAE;IACnF;IACA,MAAM,OAAO,KAAK,QAAQ,CAAC,GAAG;IAC9B,MAAM,IAAI,IAAA,4JAAO,EAAC,KAAK,QAAQ,CAAC,IAAI,KAAK,gKAAU,EAAE,QAAQ;IAC7D,MAAM,IAAI,IAAA,4JAAO,EAAC,KAAK,QAAQ,CAAC,IAAI,KAAK,gKAAU,EAAE,QAAQ;IAC7D,MAAM,IAAI,IAAA,4JAAO,EAAC,KAAK,QAAQ,CAAC,IAAI,KAAK,gKAAU,EAAE,QAAQ;IAC7D,IAAI,IAAK,KAAK,MAAO,IAAI,KAAK,IAAI,IAAI;QAClC,MAAM,IAAI,MAAM;IACpB;IACA,MAAM,YAAY,oLAAc,CAAC,IAAI,CAAC,CAAC,SAAW,OAAO,CAAC,KAAK,KAAK,OAAO,CAAC,KAAK,KAAK,OAAO,CAAC,KAAK;IACnG,IAAI,CAAC,WAAW;QACZ,MAAM,IAAI,MAAM;IACpB;IACA,OAAO;QAAE,QAAQ;YAAE;YAAG;YAAG;QAAE;QAAG;IAAK;AACvC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2194, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/json/constants.js"],"sourcesContent":["export const ENCODING = ['scrypt', 'xsalsa20-poly1305'];\nexport const ENCODING_NONE = ['none'];\nexport const ENCODING_VERSION = '3';\nexport const NONCE_LENGTH = 24;\nexport const SCRYPT_LENGTH = 32 + (3 * 4);\n"],"names":[],"mappings":";;;;;;;;;;;;AAAO,MAAM,WAAW;IAAC;IAAU;CAAoB;AAChD,MAAM,gBAAgB;IAAC;CAAO;AAC9B,MAAM,mBAAmB;AACzB,MAAM,eAAe;AACrB,MAAM,gBAAgB,KAAM,IAAI","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2220, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/json/decryptData.js"],"sourcesContent":["import { stringToU8a, u8aFixLength } from '@polkadot/util';\nimport { naclDecrypt } from '../nacl/index.js';\nimport { scryptEncode, scryptFromU8a } from '../scrypt/index.js';\nimport { ENCODING, NONCE_LENGTH, SCRYPT_LENGTH } from './constants.js';\nexport function jsonDecryptData(encrypted, passphrase, encType = ENCODING) {\n    if (!encrypted) {\n        throw new Error('No encrypted data available to decode');\n    }\n    else if (encType.includes('xsalsa20-poly1305') && !passphrase) {\n        throw new Error('Password required to decode encrypted data');\n    }\n    let encoded = encrypted;\n    if (passphrase) {\n        let password;\n        if (encType.includes('scrypt')) {\n            const { params, salt } = scryptFromU8a(encrypted);\n            password = scryptEncode(passphrase, salt, params).password;\n            encrypted = encrypted.subarray(SCRYPT_LENGTH);\n        }\n        else {\n            password = stringToU8a(passphrase);\n        }\n        encoded = naclDecrypt(encrypted.subarray(NONCE_LENGTH), encrypted.subarray(0, NONCE_LENGTH), u8aFixLength(password, 256, true));\n    }\n    if (!encoded) {\n        throw new Error('Unable to decode using the supplied passphrase');\n    }\n    return encoded;\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AACA;AAAA;AACA;;;;;AACO,SAAS,gBAAgB,SAAS,EAAE,UAAU,EAAE,UAAU,6KAAQ;IACrE,IAAI,CAAC,WAAW;QACZ,MAAM,IAAI,MAAM;IACpB,OACK,IAAI,QAAQ,QAAQ,CAAC,wBAAwB,CAAC,YAAY;QAC3D,MAAM,IAAI,MAAM;IACpB;IACA,IAAI,UAAU;IACd,IAAI,YAAY;QACZ,IAAI;QACJ,IAAI,QAAQ,QAAQ,CAAC,WAAW;YAC5B,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,IAAA,kLAAa,EAAC;YACvC,WAAW,IAAA,gLAAY,EAAC,YAAY,MAAM,QAAQ,QAAQ;YAC1D,YAAY,UAAU,QAAQ,CAAC,kLAAa;QAChD,OACK;YACD,WAAW,IAAA,oKAAW,EAAC;QAC3B;QACA,UAAU,IAAA,8KAAW,EAAC,UAAU,QAAQ,CAAC,iLAAY,GAAG,UAAU,QAAQ,CAAC,GAAG,iLAAY,GAAG,IAAA,sKAAY,EAAC,UAAU,KAAK;IAC7H;IACA,IAAI,CAAC,SAAS;QACV,MAAM,IAAI,MAAM;IACpB;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2261, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/nacl/encrypt.js"],"sourcesContent":["import { randomAsU8a } from '../random/asU8a.js';\nimport { naclSecretbox } from './tweetnacl.js';\n/**\n * @name naclEncrypt\n * @summary Encrypts a message using the supplied secretKey and nonce\n * @description\n * Returns an encrypted message, using the `secretKey` and `nonce`. If the `nonce` was not supplied, a random value is generated.\n * @example\n * <BR>\n *\n * ```javascript\n * import { naclEncrypt } from '@polkadot/util-crypto';\n *\n * naclEncrypt([...], [...]); // => [...]\n * ```\n */\nexport function naclEncrypt(message, secret, nonce = randomAsU8a(24)) {\n    return {\n        encrypted: naclSecretbox(message, nonce, secret),\n        nonce\n    };\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAeO,SAAS,YAAY,OAAO,EAAE,MAAM,EAAE,QAAQ,IAAA,8KAAW,EAAC,GAAG;IAChE,OAAO;QACH,WAAW,IAAA,kLAAa,EAAC,SAAS,OAAO;QACzC;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2279, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/scrypt/toU8a.js"],"sourcesContent":["import { bnToU8a, u8aConcat } from '@polkadot/util';\nimport { BN_LE_32_OPTS } from '../bn.js';\nexport function scryptToU8a(salt, { N, p, r }) {\n    return u8aConcat(salt, bnToU8a(N, BN_LE_32_OPTS), bnToU8a(p, BN_LE_32_OPTS), bnToU8a(r, BN_LE_32_OPTS));\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;;;AACO,SAAS,YAAY,IAAI,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE;IACzC,OAAO,IAAA,gKAAS,EAAC,MAAM,IAAA,4JAAO,EAAC,GAAG,mKAAa,GAAG,IAAA,4JAAO,EAAC,GAAG,mKAAa,GAAG,IAAA,4JAAO,EAAC,GAAG,mKAAa;AACzG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2295, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/json/encryptFormat.js"],"sourcesContent":["import { base64Encode } from '../base64/index.js';\nimport { ENCODING, ENCODING_NONE, ENCODING_VERSION } from './constants.js';\nexport function jsonEncryptFormat(encoded, contentType, isEncrypted) {\n    return {\n        encoded: base64Encode(encoded),\n        encoding: {\n            content: contentType,\n            type: isEncrypted\n                ? ENCODING\n                : ENCODING_NONE,\n            version: ENCODING_VERSION\n        }\n    };\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AACO,SAAS,kBAAkB,OAAO,EAAE,WAAW,EAAE,WAAW;IAC/D,OAAO;QACH,SAAS,IAAA,8KAAY,EAAC;QACtB,UAAU;YACN,SAAS;YACT,MAAM,cACA,6KAAQ,GACR,kLAAa;YACnB,SAAS,qLAAgB;QAC7B;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2317, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/ethereum/isChecksum.js"],"sourcesContent":["import { u8aToHex } from '@polkadot/util';\nimport { keccakAsU8a } from '../keccak/index.js';\nfunction isInvalidChar(char, byte) {\n    return char !== (byte > 7\n        ? char.toUpperCase()\n        : char.toLowerCase());\n}\nexport function isEthereumChecksum(_address) {\n    const address = _address.replace('0x', '');\n    const hash = u8aToHex(keccakAsU8a(address.toLowerCase()), -1, false);\n    for (let i = 0; i < 40; i++) {\n        if (isInvalidChar(address[i], parseInt(hash[i], 16))) {\n            return false;\n        }\n    }\n    return true;\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AACA,SAAS,cAAc,IAAI,EAAE,IAAI;IAC7B,OAAO,SAAS,CAAC,OAAO,IAClB,KAAK,WAAW,KAChB,KAAK,WAAW,EAAE;AAC5B;AACO,SAAS,mBAAmB,QAAQ;IACvC,MAAM,UAAU,SAAS,OAAO,CAAC,MAAM;IACvC,MAAM,OAAO,IAAA,8JAAQ,EAAC,IAAA,8KAAW,EAAC,QAAQ,WAAW,KAAK,CAAC,GAAG;IAC9D,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,IAAK;QACzB,IAAI,cAAc,OAAO,CAAC,EAAE,EAAE,SAAS,IAAI,CAAC,EAAE,EAAE,MAAM;YAClD,OAAO;QACX;IACJ;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2342, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/ethereum/isAddress.js"],"sourcesContent":["import { isHex } from '@polkadot/util';\nimport { isEthereumChecksum } from './isChecksum.js';\nexport function isEthereumAddress(address) {\n    if (!address || address.length !== 42 || !isHex(address)) {\n        return false;\n    }\n    else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {\n        return true;\n    }\n    return isEthereumChecksum(address);\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AACO,SAAS,kBAAkB,OAAO;IACrC,IAAI,CAAC,WAAW,QAAQ,MAAM,KAAK,MAAM,CAAC,IAAA,wJAAK,EAAC,UAAU;QACtD,OAAO;IACX,OACK,IAAI,sBAAsB,IAAI,CAAC,YAAY,sBAAsB,IAAI,CAAC,UAAU;QACjF,OAAO;IACX;IACA,OAAO,IAAA,4LAAkB,EAAC;AAC9B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2362, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/crypto.js"],"sourcesContent":["import { isReady, waitReady } from '@polkadot/wasm-crypto';\nexport const cryptoIsReady = isReady;\nexport function cryptoWaitReady() {\n    return waitReady()\n        .then(() => {\n        if (!isReady()) {\n            throw new Error('Unable to initialize @polkadot/util-crypto');\n        }\n        return true;\n    })\n        .catch(() => false);\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AACO,MAAM,gBAAgB,iLAAO;AAC7B,SAAS;IACZ,OAAO,IAAA,mLAAS,IACX,IAAI,CAAC;QACN,IAAI,CAAC,IAAA,iLAAO,KAAI;YACZ,MAAM,IAAI,MAAM;QACpB;QACA,OAAO;IACX,GACK,KAAK,CAAC,IAAM;AACrB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2383, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/xxhash/xxhash64.js"],"sourcesContent":["import { _0n, _1n } from '@polkadot/util';\nimport { BigInt } from '@polkadot/x-bigint';\nconst P64_1 = BigInt('11400714785074694791');\nconst P64_2 = BigInt('14029467366897019727');\nconst P64_3 = BigInt('1609587929392839161');\nconst P64_4 = BigInt('9650029242287828579');\nconst P64_5 = BigInt('2870177450012600261');\nconst U64 = BigInt('0xffffffffffffffff');\nconst _7n = BigInt(7);\nconst _11n = BigInt(11);\nconst _12n = BigInt(12);\nconst _16n = BigInt(16);\nconst _18n = BigInt(18);\nconst _23n = BigInt(23);\nconst _27n = BigInt(27);\nconst _29n = BigInt(29);\nconst _31n = BigInt(31);\nconst _32n = BigInt(32);\nconst _33n = BigInt(33);\nconst _64n = BigInt(64);\nconst _256n = BigInt(256);\nfunction rotl(a, b) {\n    const c = a & U64;\n    return ((c << b) | (c >> (_64n - b))) & U64;\n}\nfunction fromU8a(u8a, p, count) {\n    const bigints = new Array(count);\n    let offset = 0;\n    for (let i = 0; i < count; i++, offset += 2) {\n        bigints[i] = BigInt(u8a[p + offset] | (u8a[p + 1 + offset] << 8));\n    }\n    let result = _0n;\n    for (let i = count - 1; i >= 0; i--) {\n        result = (result << _16n) + bigints[i];\n    }\n    return result;\n}\nfunction init(seed, input) {\n    const state = {\n        seed,\n        u8a: new Uint8Array(32),\n        u8asize: 0,\n        v1: seed + P64_1 + P64_2,\n        v2: seed + P64_2,\n        v3: seed,\n        v4: seed - P64_1\n    };\n    if (input.length < 32) {\n        state.u8a.set(input);\n        state.u8asize = input.length;\n        return state;\n    }\n    const limit = input.length - 32;\n    let p = 0;\n    if (limit >= 0) {\n        const adjustV = (v) => P64_1 * rotl(v + P64_2 * fromU8a(input, p, 4), _31n);\n        do {\n            state.v1 = adjustV(state.v1);\n            p += 8;\n            state.v2 = adjustV(state.v2);\n            p += 8;\n            state.v3 = adjustV(state.v3);\n            p += 8;\n            state.v4 = adjustV(state.v4);\n            p += 8;\n        } while (p <= limit);\n    }\n    if (p < input.length) {\n        state.u8a.set(input.subarray(p, input.length));\n        state.u8asize = input.length - p;\n    }\n    return state;\n}\nexport function xxhash64(input, initSeed) {\n    const { seed, u8a, u8asize, v1, v2, v3, v4 } = init(BigInt(initSeed), input);\n    let p = 0;\n    let h64 = U64 & (BigInt(input.length) + (input.length >= 32\n        ? (((((((((rotl(v1, _1n) + rotl(v2, _7n) + rotl(v3, _12n) + rotl(v4, _18n)) ^ (P64_1 * rotl(v1 * P64_2, _31n))) * P64_1 + P64_4) ^ (P64_1 * rotl(v2 * P64_2, _31n))) * P64_1 + P64_4) ^ (P64_1 * rotl(v3 * P64_2, _31n))) * P64_1 + P64_4) ^ (P64_1 * rotl(v4 * P64_2, _31n))) * P64_1 + P64_4)\n        : (seed + P64_5)));\n    while (p <= (u8asize - 8)) {\n        h64 = U64 & (P64_4 + P64_1 * rotl(h64 ^ (P64_1 * rotl(P64_2 * fromU8a(u8a, p, 4), _31n)), _27n));\n        p += 8;\n    }\n    if ((p + 4) <= u8asize) {\n        h64 = U64 & (P64_3 + P64_2 * rotl(h64 ^ (P64_1 * fromU8a(u8a, p, 2)), _23n));\n        p += 4;\n    }\n    while (p < u8asize) {\n        h64 = U64 & (P64_1 * rotl(h64 ^ (P64_5 * BigInt(u8a[p++])), _11n));\n    }\n    h64 = U64 & (P64_2 * (h64 ^ (h64 >> _33n)));\n    h64 = U64 & (P64_3 * (h64 ^ (h64 >> _29n)));\n    h64 = U64 & (h64 ^ (h64 >> _32n));\n    const result = new Uint8Array(8);\n    for (let i = 7; i >= 0; i--) {\n        result[i] = Number(h64 % _256n);\n        h64 = h64 / _256n;\n    }\n    return result;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2491, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/util-crypto/xxhash/asU8a.js"],"sourcesContent":["import { hasBigInt, u8aToU8a } from '@polkadot/util';\nimport { isReady, twox } from '@polkadot/wasm-crypto';\nimport { createAsHex } from '../helpers.js';\nimport { xxhash64 } from './xxhash64.js';\n/**\n * @name xxhashAsU8a\n * @summary Creates a xxhash64 u8a from the input.\n * @description\n * From either a `string`, `Uint8Array` or a `Buffer` input, create the xxhash64 and return the result as a `Uint8Array` with the specified `bitLength`.\n * @example\n * <BR>\n *\n * ```javascript\n * import { xxhashAsU8a } from '@polkadot/util-crypto';\n *\n * xxhashAsU8a('abc'); // => 0x44bc2cf5ad770999\n * ```\n */\nexport function xxhashAsU8a(data, bitLength = 64, onlyJs) {\n    const rounds = Math.ceil(bitLength / 64);\n    const u8a = u8aToU8a(data);\n    if (!hasBigInt || (!onlyJs && isReady())) {\n        return twox(u8a, rounds);\n    }\n    const result = new Uint8Array(rounds * 8);\n    for (let seed = 0; seed < rounds; seed++) {\n        result.set(xxhash64(u8a, seed).reverse(), seed * 8);\n    }\n    return result;\n}\n/**\n * @name xxhashAsHex\n * @description Creates a xxhash64 hex from the input.\n */\nexport const xxhashAsHex = /*#__PURE__*/ createAsHex(xxhashAsU8a);\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;AACA;AACA;AACA;;;;;AAeO,SAAS,YAAY,IAAI,EAAE,YAAY,EAAE,EAAE,MAAM;IACpD,MAAM,SAAS,KAAK,IAAI,CAAC,YAAY;IACrC,MAAM,MAAM,IAAA,8JAAQ,EAAC;IACrB,IAAI,CAAC,sJAAS,IAAK,CAAC,UAAU,IAAA,iLAAO,KAAK;QACtC,OAAO,IAAA,8KAAI,EAAC,KAAK;IACrB;IACA,MAAM,SAAS,IAAI,WAAW,SAAS;IACvC,IAAK,IAAI,OAAO,GAAG,OAAO,QAAQ,OAAQ;QACtC,OAAO,GAAG,CAAC,IAAA,8KAAQ,EAAC,KAAK,MAAM,OAAO,IAAI,OAAO;IACrD;IACA,OAAO;AACX;AAKO,MAAM,cAAc,WAAW,GAAG,IAAA,sKAAW,EAAC","ignoreList":[0],"debugId":null}}]
}