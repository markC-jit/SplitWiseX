{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/utils/util.js"],"sourcesContent":["import { isFunction } from '@polkadot/util';\nexport function hasEq(o) {\n    return isFunction(o.eq);\n}\n"],"names":[],"mappings":";;;;AAAA;;AACO,SAAS,MAAM,CAAC;IACnB,OAAO,IAAA,kKAAU,EAAC,EAAE,EAAE;AAC1B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 17, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/utils/compareMap.js"],"sourcesContent":["import { isObject, isUndefined } from '@polkadot/util';\nimport { hasEq } from './util.js';\nfunction hasMismatch(a, b) {\n    return isUndefined(a) || (hasEq(a)\n        ? !a.eq(b)\n        : a !== b);\n}\nfunction notEntry(value) {\n    return !Array.isArray(value) || value.length !== 2;\n}\nfunction compareMapArray(a, b) {\n    // equal number of entries and each entry in the array should match\n    return (a.size === b.length) && !b.some((e) => notEntry(e) ||\n        hasMismatch(a.get(e[0]), e[1]));\n}\nexport function compareMap(a, b) {\n    if (Array.isArray(b)) {\n        return compareMapArray(a, b);\n    }\n    else if (b instanceof Map) {\n        return compareMapArray(a, [...b.entries()]);\n    }\n    else if (isObject(b)) {\n        return compareMapArray(a, Object.entries(b));\n    }\n    return false;\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;;;AACA,SAAS,YAAY,CAAC,EAAE,CAAC;IACrB,OAAO,IAAA,oKAAW,EAAC,MAAM,CAAC,IAAA,sKAAK,EAAC,KAC1B,CAAC,EAAE,EAAE,CAAC,KACN,MAAM,CAAC;AACjB;AACA,SAAS,SAAS,KAAK;IACnB,OAAO,CAAC,MAAM,OAAO,CAAC,UAAU,MAAM,MAAM,KAAK;AACrD;AACA,SAAS,gBAAgB,CAAC,EAAE,CAAC;IACzB,mEAAmE;IACnE,OAAO,AAAC,EAAE,IAAI,KAAK,EAAE,MAAM,IAAK,CAAC,EAAE,IAAI,CAAC,CAAC,IAAM,SAAS,MACpD,YAAY,EAAE,GAAG,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,EAAE;AACrC;AACO,SAAS,WAAW,CAAC,EAAE,CAAC;IAC3B,IAAI,MAAM,OAAO,CAAC,IAAI;QAClB,OAAO,gBAAgB,GAAG;IAC9B,OACK,IAAI,aAAa,KAAK;QACvB,OAAO,gBAAgB,GAAG;eAAI,EAAE,OAAO;SAAG;IAC9C,OACK,IAAI,IAAA,8JAAQ,EAAC,IAAI;QAClB,OAAO,gBAAgB,GAAG,OAAO,OAAO,CAAC;IAC7C;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/utils/decodeU8a.js"],"sourcesContent":["import { u8aToHex } from '@polkadot/util';\nconst MAX_DEPTH = 1024;\n/** @internal */\nfunction isComplexType(Type) {\n    const typeName = Type.name?.toLowerCase() || '';\n    return ['enum', 'hashmap', 'linkage', 'null', 'option', 'range', 'rangeinclusive', 'result', 'struct', 'tuple', 'vec', 'vecfixed'].includes(typeName);\n}\n/** @internal */\nfunction formatFailure(registry, fn, _result, { message }, u8a, i, count, Type, key) {\n    let type = '';\n    try {\n        type = `: ${new Type(registry).toRawType()}`;\n    }\n    catch {\n        // ignore\n    }\n    // This is extra debugging info (we most-probably want this in in some way, shape or form,\n    // but at this point not quite sure how to include and format it (it can be quite massive)\n    // console.error(JSON.stringify(result, null, 2));\n    return `${fn}: failed at ${u8aToHex(u8a.subarray(0, 16))}â€¦${key ? ` on ${key}` : ''} (index ${i + 1}/${count})${type}:: ${message}`;\n}\n/**\n * @internal\n *\n * Given an u8a, and an array of Type constructors, decode the u8a against the\n * types, and return an array of decoded values.\n *\n * @param u8a - The u8a to decode.\n * @param result - The result array (will be returned with values pushed)\n * @param types - The array of CodecClass to decode the U8a against.\n */\nexport function decodeU8a(registry, result, u8a, [Types, keys]) {\n    const count = result.length;\n    let offset = 0;\n    let i = 0;\n    try {\n        while (i < count) {\n            const value = new Types[i](registry, u8a.subarray(offset));\n            offset += value.initialU8aLength || value.encodedLength;\n            result[i] = value;\n            i++;\n        }\n    }\n    catch (error) {\n        throw new Error(formatFailure(registry, 'decodeU8a', result, error, u8a.subarray(offset), i, count, Types[i], keys[i]));\n    }\n    return [result, offset];\n}\n/**\n * @internal\n *\n * Split from decodeU8a since this is specialized to zip returns ... while we duplicate, this\n * is all on the hot-path, so it is not great, however there is (some) method behind the madness\n */\nexport function decodeU8aStruct(registry, result, u8a, [Types, keys]) {\n    const count = result.length;\n    let offset = 0;\n    let i = 0;\n    if (count > MAX_DEPTH && isComplexType(Types[i])) {\n        throw new Error(`decodeU8aStruct: Maximum depth exceeded, received ${count} elements, limit ${MAX_DEPTH}`);\n    }\n    try {\n        while (i < count) {\n            const value = new Types[i](registry, u8a.subarray(offset));\n            offset += value.initialU8aLength || value.encodedLength;\n            result[i] = [keys[i], value];\n            i++;\n        }\n    }\n    catch (error) {\n        throw new Error(formatFailure(registry, 'decodeU8aStruct', result, error, u8a.subarray(offset), i, count, Types[i], keys[i]));\n    }\n    return [result, offset];\n}\n/**\n * @internal\n *\n * Split from decodeU8a since this is specialized to 1 instance ... while we duplicate, this\n * is all on the hot-path, so it is not great, however there is (some) method behind the madness\n */\nexport function decodeU8aVec(registry, result, u8a, startAt, Type) {\n    const count = result.length;\n    if (count > MAX_DEPTH && isComplexType(Type)) {\n        throw new Error(`decodeU8aVec: Maximum depth exceeded, received ${count} elements, limit ${MAX_DEPTH}`);\n    }\n    let offset = startAt;\n    let i = 0;\n    try {\n        while (i < count) {\n            const value = new Type(registry, u8a.subarray(offset));\n            offset += value.initialU8aLength || value.encodedLength;\n            result[i] = value;\n            i++;\n        }\n    }\n    catch (error) {\n        throw new Error(formatFailure(registry, 'decodeU8aVec', result, error, u8a.subarray(offset), i, count, Type));\n    }\n    return [offset, offset - startAt];\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 162, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/utils/toConstructors.js"],"sourcesContent":["/**\n * @internal\n * From a type string or class, return the associated type class\n */\nexport function typeToConstructor(registry, type) {\n    return typeof type === 'function'\n        ? type\n        : registry.createClassUnsafe(type);\n}\n/**\n * @internal\n * Takes an input array of types and returns the associated classes for it\n*/\nexport function typesToConstructors(registry, types) {\n    const count = types.length;\n    const result = new Array(count);\n    for (let i = 0; i < count; i++) {\n        result[i] = typeToConstructor(registry, types[i]);\n    }\n    return result;\n}\n/**\n * @internal\n * Takes an input map of the form `{ [string]: string | CodecClass }` and returns a map of `{ [string]: CodecClass }`\n */\nexport function mapToTypeMap(registry, input) {\n    const entries = Object.entries(input);\n    const count = entries.length;\n    const output = [new Array(count), new Array(count)];\n    for (let i = 0; i < count; i++) {\n        output[1][i] = entries[i][0];\n        output[0][i] = typeToConstructor(registry, entries[i][1]);\n    }\n    return output;\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;AACM,SAAS,kBAAkB,QAAQ,EAAE,IAAI;IAC5C,OAAO,OAAO,SAAS,aACjB,OACA,SAAS,iBAAiB,CAAC;AACrC;AAKO,SAAS,oBAAoB,QAAQ,EAAE,KAAK;IAC/C,MAAM,QAAQ,MAAM,MAAM;IAC1B,MAAM,SAAS,IAAI,MAAM;IACzB,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,IAAK;QAC5B,MAAM,CAAC,EAAE,GAAG,kBAAkB,UAAU,KAAK,CAAC,EAAE;IACpD;IACA,OAAO;AACX;AAKO,SAAS,aAAa,QAAQ,EAAE,KAAK;IACxC,MAAM,UAAU,OAAO,OAAO,CAAC;IAC/B,MAAM,QAAQ,QAAQ,MAAM;IAC5B,MAAM,SAAS;QAAC,IAAI,MAAM;QAAQ,IAAI,MAAM;KAAO;IACnD,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,IAAK;QAC5B,MAAM,CAAC,EAAE,CAAC,EAAE,GAAG,OAAO,CAAC,EAAE,CAAC,EAAE;QAC5B,MAAM,CAAC,EAAE,CAAC,EAAE,GAAG,kBAAkB,UAAU,OAAO,CAAC,EAAE,CAAC,EAAE;IAC5D;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 201, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/utils/typesToMap.js"],"sourcesContent":["export function typesToMap(registry, [Types, keys]) {\n    const result = {};\n    for (let i = 0, count = keys.length; i < count; i++) {\n        result[keys[i]] = registry.getClassName(Types[i]) || new Types[i](registry).toRawType();\n    }\n    return result;\n}\n"],"names":[],"mappings":";;;;AAAO,SAAS,WAAW,QAAQ,EAAE,CAAC,OAAO,KAAK;IAC9C,MAAM,SAAS,CAAC;IAChB,IAAK,IAAI,IAAI,GAAG,QAAQ,KAAK,MAAM,EAAE,IAAI,OAAO,IAAK;QACjD,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,GAAG,SAAS,YAAY,CAAC,KAAK,CAAC,EAAE,KAAK,IAAI,KAAK,CAAC,EAAE,CAAC,UAAU,SAAS;IACzF;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 216, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/native/Struct.js"],"sourcesContent":["import { isBoolean, isHex, isObject, isU8a, isUndefined, objectProperties, stringCamelCase, stringify, u8aConcatStrict, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { compareMap, decodeU8aStruct, mapToTypeMap, typesToMap } from '../utils/index.js';\nfunction noopSetDefinition(d) {\n    return d;\n}\n/** @internal */\nfunction decodeStructFromObject(registry, [Types, keys], value, jsonMap) {\n    let jsonObj;\n    const typeofArray = Array.isArray(value);\n    const typeofMap = value instanceof Map;\n    const count = keys.length;\n    if (!typeofArray && !typeofMap && !isObject(value)) {\n        throw new Error(`Struct: Cannot decode value ${stringify(value)} (typeof ${typeof value}), expected an input object, map or array`);\n    }\n    else if (typeofArray && value.length !== count) {\n        throw new Error(`Struct: Unable to map ${stringify(value)} array to object with known keys ${keys.join(', ')}`);\n    }\n    const raw = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const key = keys[i];\n        const jsonKey = jsonMap.get(key) || key;\n        const Type = Types[i];\n        let assign;\n        try {\n            if (typeofArray) {\n                assign = value[i];\n            }\n            else if (typeofMap) {\n                assign = jsonKey && value.get(jsonKey);\n            }\n            else {\n                assign = jsonKey && Object.prototype.hasOwnProperty.call(value, jsonKey) ? value[jsonKey] : undefined;\n                if (isUndefined(assign)) {\n                    if (isUndefined(jsonObj)) {\n                        const entries = Object.entries(value);\n                        jsonObj = {};\n                        for (let e = 0, ecount = entries.length; e < ecount; e++) {\n                            if (Object.prototype.hasOwnProperty.call(value, entries[e][0])) {\n                                jsonObj[stringCamelCase(entries[e][0])] = entries[e][1];\n                            }\n                        }\n                    }\n                    assign = jsonKey && Object.prototype.hasOwnProperty.call(jsonObj, jsonKey) ? jsonObj[jsonKey] : undefined;\n                }\n            }\n            raw[i] = [\n                key,\n                assign instanceof Type\n                    ? assign\n                    : new Type(registry, assign)\n            ];\n        }\n        catch (error) {\n            let type = Type.name;\n            try {\n                type = new Type(registry).toRawType();\n            }\n            catch {\n                // ignore\n            }\n            throw new Error(`Struct: failed on ${jsonKey}: ${type}:: ${error.message}`);\n        }\n    }\n    return [raw, 0];\n}\n/**\n * @name Struct\n * @description\n * A Struct defines an Object with key-value pairs - where the values are Codec values. It removes\n * a lot of repetition from the actual coding, define a structure type, pass it the key/Codec\n * values in the constructor and it manages the decoding. It is important that the constructor\n * values matches 100% to the order in th Rust code, i.e. don't go crazy and make it alphabetical,\n * it needs to decoded in the specific defined order.\n * @noInheritDoc\n */\nexport class Struct extends Map {\n    registry;\n    createdAtHash;\n    initialU8aLength;\n    isStorageFallback;\n    #jsonMap;\n    #Types;\n    constructor(registry, Types, value, jsonMap = new Map(), { definition, setDefinition = noopSetDefinition } = {}) {\n        const typeMap = definition || setDefinition(mapToTypeMap(registry, Types));\n        const [decoded, decodedLength] = isU8a(value) || isHex(value)\n            ? decodeU8aStruct(registry, new Array(typeMap[0].length), u8aToU8a(value), typeMap)\n            : value instanceof Struct\n                ? [value, 0]\n                : decodeStructFromObject(registry, typeMap, value || {}, jsonMap);\n        super(decoded);\n        this.initialU8aLength = decodedLength;\n        this.registry = registry;\n        this.#jsonMap = jsonMap;\n        this.#Types = typeMap;\n    }\n    static with(Types, jsonMap) {\n        let definition;\n        // eslint-disable-next-line no-return-assign\n        const setDefinition = (d) => definition = d;\n        return class extends Struct {\n            static {\n                const keys = Object.keys(Types);\n                objectProperties(this.prototype, keys, (k, _, self) => self.get(k));\n            }\n            constructor(registry, value) {\n                super(registry, Types, value, jsonMap, { definition, setDefinition });\n            }\n        };\n    }\n    /**\n     * @description The available keys for this struct\n     */\n    get defKeys() {\n        return this.#Types[1];\n    }\n    /**\n     * @description Checks if the value is an empty value '{}'\n     */\n    get isEmpty() {\n        return [...this.keys()].length === 0;\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        let total = 0;\n        for (const v of this.values()) {\n            total += v.encodedLength;\n        }\n        return total;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Returns the Type description of the structure\n     */\n    get Type() {\n        const result = {};\n        const [Types, keys] = this.#Types;\n        for (let i = 0, count = keys.length; i < count; i++) {\n            result[keys[i]] = new Types[i](this.registry).toRawType();\n        }\n        return result;\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        return compareMap(this, other);\n    }\n    /**\n     * @description Returns a specific names entry in the structure\n     * @param key The name of the entry to retrieve\n     */\n    get(key) {\n        return super.get(key);\n    }\n    /**\n     * @description Returns the values of a member at a specific index (Rather use get(name) for performance)\n     */\n    getAtIndex(index) {\n        return this.toArray()[index];\n    }\n    /**\n     * @description Returns the a types value by name\n     */\n    getT(key) {\n        return super.get(key);\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect(isBare) {\n        const inner = [];\n        for (const [k, v] of this.entries()) {\n            inner.push({\n                ...v.inspect(!isBare || isBoolean(isBare)\n                    ? isBare\n                    : isBare[k]),\n                name: stringCamelCase(k)\n            });\n        }\n        return {\n            inner\n        };\n    }\n    /**\n     * @description Converts the Object to an standard JavaScript Array\n     */\n    toArray() {\n        return [...this.values()];\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n    toHex() {\n        return u8aToHex(this.toU8a());\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman(isExtended, disableAscii) {\n        const json = {};\n        for (const [k, v] of this.entries()) {\n            json[k] = v.toHuman(isExtended, disableAscii);\n        }\n        return json;\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        const json = {};\n        for (const [k, v] of this.entries()) {\n            // Here we pull out the entry against the JSON mapping (if supplied)\n            // since this representation goes over RPC and needs to be correct\n            json[(this.#jsonMap.get(k) || k)] = v.toJSON();\n        }\n        return json;\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive(disableAscii) {\n        const json = {};\n        for (const [k, v] of this.entries()) {\n            json[k] = v.toPrimitive(disableAscii);\n        }\n        return json;\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return stringify(typesToMap(this.registry, this.#Types));\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        return stringify(this.toJSON());\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        const encoded = [];\n        for (const [k, v] of this.entries()) {\n            encoded.push(v.toU8a(!isBare || isBoolean(isBare)\n                ? isBare\n                : isBare[k]));\n        }\n        return u8aConcatStrict(encoded);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 468, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/utils/sanitize.js"],"sourcesContent":["const BOUNDED = ['BTreeMap', 'BTreeSet', 'HashMap', 'Vec'];\nconst ALLOWED_BOXES = BOUNDED.concat(['Compact', 'DoNotConstruct', 'Int', 'Linkage', 'Range', 'RangeInclusive', 'Result', 'Opaque', 'Option', 'UInt', 'WrapperKeepOpaque', 'WrapperOpaque']);\nconst BOX_PRECEDING = ['<', '(', '[', '\"', ',', ' ']; // start of vec, tuple, fixed array, part of struct def or in tuple\nconst mappings = [\n    // alias <T::InherentOfflineReport as InherentOfflineReport>::Inherent -> InherentOfflineReport\n    alias('<T::InherentOfflineReport as InherentOfflineReport>::Inherent', 'InherentOfflineReport', false),\n    alias('VecDeque<', 'Vec<', false),\n    // <T::Balance as HasCompact>\n    cleanupCompact(),\n    // Change BoundedVec<Type, Size> to Vec<Type>\n    removeExtensions('Bounded', true),\n    // Change WeakVec<Type> to Vec<Type>\n    removeExtensions('Weak', false),\n    // Remove all the trait prefixes\n    removeTraits(),\n    // remove PairOf<T> -> (T, T)\n    removePairOf(),\n    // remove boxing, `Box<Proposal>` -> `Proposal`\n    removeWrap('Box<'),\n    // remove generics, `MisbehaviorReport<Hash, BlockNumber>` -> `MisbehaviorReport`\n    removeGenerics(),\n    // alias String -> Text (compat with jsonrpc methods)\n    alias('String', 'Text'),\n    // alias Vec<u8> -> Bytes\n    alias('Vec<u8>', 'Bytes'),\n    alias('&\\\\[u8\\\\]', 'Bytes'),\n    alias(\"&'static\\\\[u8\\\\]\", 'Bytes'),\n    // alias RawAddress -> Address\n    alias('RawAddress', 'Address'),\n    // lookups, mapped to Address/AccountId as appropriate in runtime\n    alias('Lookup::Source', 'LookupSource'),\n    alias('Lookup::Target', 'LookupTarget'),\n    // HACK duplication between contracts & primitives, however contracts prefixed with exec\n    alias('exec::StorageKey', 'ContractStorageKey'),\n    // flattens tuples with one value, `(AccountId)` -> `AccountId`\n    flattenSingleTuple(),\n    // converts ::Type to Type, <T as Trait<I>>::Proposal -> Proposal\n    removeColons(),\n    // remove all trailing spaces - this should always be the last\n    trim()\n];\nexport function trim() {\n    return (value) => value.trim();\n}\nexport function findClosing(value, start) {\n    let depth = 0;\n    for (let i = start, count = value.length; i < count; i++) {\n        if (value[i] === '>') {\n            if (!depth) {\n                return i;\n            }\n            depth--;\n        }\n        else if (value[i] === '<') {\n            depth++;\n        }\n    }\n    throw new Error(`Unable to find closing matching <> on '${value}' (start ${start})`);\n}\nexport function alias(src, dest, withChecks = true) {\n    const from = new RegExp(`(^${src}|${BOX_PRECEDING.map((box) => `\\\\${box}${src}`).join('|')})`, 'g');\n    const to = (src) => {\n        from.lastIndex = 0;\n        return withChecks && BOX_PRECEDING.includes(src[0])\n            ? `${src[0]}${dest}`\n            : dest;\n    };\n    return (value) => value.replace(from, to);\n}\nexport function cleanupCompact() {\n    return (value) => {\n        if (value.includes(' as HasCompact')) {\n            for (let i = 0, count = value.length; i < count; i++) {\n                if (value[i] === '<') {\n                    const end = findClosing(value, i + 1) - 14;\n                    if (value.substring(end, end + 14) === ' as HasCompact') {\n                        value = `Compact<${value.substring(i + 1, end)}>`;\n                    }\n                }\n            }\n        }\n        return value;\n    };\n}\nexport function flattenSingleTuple() {\n    const from1 = /,\\)/g;\n    const from2 = /\\(([^,]+)\\)/;\n    return (value) => {\n        from1.lastIndex = 0;\n        return value\n            // tuples may have trailing commas, e.g. (u32, BlockNumber, )\n            .replace(from1, ')')\n            // change (u32) -> u32\n            .replace(from2, '$1');\n    };\n}\nfunction replaceTagWith(value, matcher, replacer) {\n    let index = -1;\n    while (true) {\n        index = value.indexOf(matcher, index + 1);\n        if (index === -1) {\n            return value;\n        }\n        const start = index + matcher.length;\n        const end = findClosing(value, start);\n        value = `${value.substring(0, index)}${replacer(value.substring(start, end))}${value.substring(end + 1)}`;\n    }\n}\nexport function removeExtensions(type, isSized) {\n    return (value) => {\n        for (let i = 0, count = BOUNDED.length; i < count; i++) {\n            const tag = BOUNDED[i];\n            value = replaceTagWith(value, `${type}${tag}<`, (v) => {\n                const parts = v\n                    .split(',')\n                    .map((s) => s.trim())\n                    .filter((s) => s);\n                if (isSized) {\n                    parts.pop();\n                }\n                return `${tag}<${parts.join(',')}>`;\n            });\n        }\n        return value;\n    };\n}\nexport function removeColons() {\n    return (value) => {\n        let index = 0;\n        while (index !== -1) {\n            index = value.indexOf('::');\n            if (index === 0) {\n                value = value.substring(2);\n            }\n            else if (index !== -1) {\n                let start = index;\n                while (start !== -1 && !BOX_PRECEDING.includes(value[start])) {\n                    start--;\n                }\n                value = `${value.substring(0, start + 1)}${value.substring(index + 2)}`;\n            }\n        }\n        return value;\n    };\n}\nexport function removeGenerics() {\n    return (value) => {\n        for (let i = 0, count = value.length; i < count; i++) {\n            if (value[i] === '<') {\n                // check against the allowed wrappers, be it Vec<..>, Option<...> ...\n                const box = ALLOWED_BOXES.find((box) => {\n                    const start = i - box.length;\n                    return ((start >= 0 &&\n                        value.substring(start, i) === box) && (\n                    // make sure it is stand-alone, i.e. don't catch ElectionResult<...> as Result<...>\n                    start === 0 ||\n                        BOX_PRECEDING.includes(value[start - 1])));\n                });\n                // we have not found anything, unwrap generic innards\n                if (!box) {\n                    const end = findClosing(value, i + 1);\n                    value = `${value.substring(0, i)}${value.substring(end + 1)}`;\n                }\n            }\n        }\n        return value;\n    };\n}\nexport function removePairOf() {\n    const replacer = (v) => `(${v},${v})`;\n    return (value) => replaceTagWith(value, 'PairOf<', replacer);\n}\nexport function removeTraits() {\n    const from1 = /\\s/g;\n    const from2 = /(T|Self)::/g;\n    const from3 = /<(T|Self)asTrait>::/g;\n    const from4 = /<Tas[a-z]+::Trait>::/g;\n    const from5 = /<LookupasStaticLookup>/g;\n    const from6 = /::Type/g;\n    return (value) => {\n        from1.lastIndex = 0;\n        from2.lastIndex = 0;\n        from3.lastIndex = 0;\n        from4.lastIndex = 0;\n        from5.lastIndex = 0;\n        from6.lastIndex = 0;\n        return value\n            // remove all whitespaces\n            .replace(from1, '')\n            // anything `T::<type>` to end up as `<type>`\n            .replace(from2, '')\n            // replace `<T as Trait>::` (whitespaces were removed above)\n            .replace(from3, '')\n            // replace `<T as something::Trait>::` (whitespaces were removed above)\n            .replace(from4, '')\n            // replace <Lookup as StaticLookup>\n            .replace(from5, 'Lookup')\n            // replace `<...>::Type`\n            .replace(from6, '');\n    };\n}\nexport function removeWrap(check) {\n    const replacer = (v) => v;\n    return (value) => replaceTagWith(value, check, replacer);\n}\nconst sanitizeMap = new Map();\nexport function sanitize(value) {\n    const startValue = value.toString();\n    const memoized = sanitizeMap.get(startValue);\n    if (memoized) {\n        return memoized;\n    }\n    let result = startValue;\n    for (let i = 0, count = mappings.length; i < count; i++) {\n        result = mappings[i](result);\n    }\n    sanitizeMap.set(startValue, result);\n    return result;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 724, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/abstract/Int.js"],"sourcesContent":["import { BN, BN_BILLION, BN_HUNDRED, BN_MILLION, BN_QUINTILL, bnToBn, bnToHex, bnToU8a, formatBalance, formatNumber, hexToBn, isBigInt, isBn, isFunction, isHex, isNumber, isObject, isString, isU8a, u8aToBn, u8aToNumber } from '@polkadot/util';\nexport const DEFAULT_UINT_BITS = 64;\nconst MAX_NUMBER_BITS = 52;\nconst MUL_P = new BN(1_00_00);\nconst FORMATTERS = [\n    ['Perquintill', BN_QUINTILL],\n    ['Perbill', BN_BILLION],\n    ['Permill', BN_MILLION],\n    ['Percent', BN_HUNDRED]\n];\nfunction isToBn(value) {\n    return isFunction(value.toBn);\n}\nfunction toPercentage(value, divisor) {\n    return `${(value.mul(MUL_P).div(divisor).toNumber() / 100).toFixed(2)}%`;\n}\n/** @internal */\nfunction decodeAbstractInt(value, isNegative) {\n    if (isNumber(value)) {\n        if (!Number.isInteger(value) || value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER) {\n            throw new Error('Number needs to be an integer <= Number.MAX_SAFE_INTEGER, i.e. 2 ^ 53 - 1');\n        }\n        return value;\n    }\n    else if (isString(value)) {\n        if (isHex(value, -1, true)) {\n            return hexToBn(value, { isLe: false, isNegative }).toString();\n        }\n        if (value.includes('.') || value.includes(',') || value.includes('e')) {\n            throw new Error('String should not contain decimal points or scientific notation');\n        }\n        return value;\n    }\n    else if (isBn(value) || isBigInt(value)) {\n        return value.toString();\n    }\n    else if (isObject(value)) {\n        if (isToBn(value)) {\n            return value.toBn().toString();\n        }\n        // Allow the construction from an object with a single top-level key. This means that\n        // single key objects can be treated equivalently to numbers, assuming they meet the\n        // specific requirements. (This is useful in Weights 1.5 where Objects are compact)\n        const keys = Object.keys(value);\n        if (keys.length !== 1) {\n            throw new Error('Unable to construct number from multi-key object');\n        }\n        return decodeAbstractInt(value[keys[0]], isNegative);\n    }\n    else if (!value) {\n        return 0;\n    }\n    throw new Error(`Unable to create BN from unknown type ${typeof value}`);\n}\n/**\n * @name AbstractInt\n * @ignore\n * @noInheritDoc\n */\nexport class AbstractInt extends BN {\n    registry;\n    encodedLength;\n    isUnsigned;\n    createdAtHash;\n    initialU8aLength;\n    isStorageFallback;\n    #bitLength;\n    constructor(registry, value = 0, bitLength = DEFAULT_UINT_BITS, isSigned = false) {\n        // Construct via a string/number, which will be passed in the BN constructor.\n        // It would be ideal to actually return a BN, but there is an issue:\n        // https://github.com/indutny/bn.js/issues/206\n        super(\n        // shortcut isU8a as used in SCALE decoding\n        isU8a(value)\n            ? bitLength <= 48\n                ? u8aToNumber(value.subarray(0, bitLength / 8), { isNegative: isSigned })\n                : u8aToBn(value.subarray(0, bitLength / 8), { isLe: true, isNegative: isSigned }).toString()\n            : decodeAbstractInt(value, isSigned));\n        this.registry = registry;\n        this.#bitLength = bitLength;\n        this.encodedLength = this.#bitLength / 8;\n        this.initialU8aLength = this.#bitLength / 8;\n        this.isUnsigned = !isSigned;\n        const isNegative = this.isNeg();\n        const maxBits = bitLength - (isSigned && !isNegative ? 1 : 0);\n        if (isNegative && !isSigned) {\n            throw new Error(`${this.toRawType()}: Negative number passed to unsigned type`);\n        }\n        else if (super.bitLength() > maxBits) {\n            throw new Error(`${this.toRawType()}: Input too large. Found input with ${super.bitLength()} bits, expected ${maxBits}`);\n        }\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Checks if the value is a zero value (align elsewhere)\n     */\n    get isEmpty() {\n        return this.isZero();\n    }\n    /**\n     * @description Returns the number of bits in the value\n     */\n    bitLength() {\n        return this.#bitLength;\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    eq(other) {\n        // Here we are actually overriding the built-in .eq to take care of both\n        // number and BN inputs (no `.eqn` needed) - numbers will be converted\n        return super.eq(isHex(other)\n            ? hexToBn(other.toString(), { isLe: false, isNegative: !this.isUnsigned })\n            : bnToBn(other));\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return {\n            outer: [this.toU8a()]\n        };\n    }\n    /**\n     * @description True if this value is the max of the type\n     */\n    isMax() {\n        const u8a = this.toU8a().filter((b) => b === 0xff);\n        return u8a.length === (this.#bitLength / 8);\n    }\n    /**\n     * @description Returns a BigInt representation of the number\n     */\n    toBigInt() {\n        return BigInt(this.toString());\n    }\n    /**\n     * @description Returns the BN representation of the number. (Compatibility)\n     */\n    toBn() {\n        return this;\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n    toHex(isLe = false) {\n        // For display/JSON, this is BE, for compare, use isLe\n        return bnToHex(this, {\n            bitLength: this.bitLength(),\n            isLe,\n            isNegative: !this.isUnsigned\n        });\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman(_isExpanded) {\n        const rawType = this.toRawType();\n        if (rawType === 'Balance') {\n            return this.isMax()\n                ? 'everything'\n                // FIXME In the case of multiples we need some way of detecting which instance this belongs\n                // to. as it stands we will always format (incorrectly) against the first token defined\n                : formatBalance(this, { decimals: this.registry.chainDecimals[0], withSi: true, withUnit: this.registry.chainTokens[0] });\n        }\n        const [, divisor] = FORMATTERS.find(([type]) => type === rawType) || [];\n        return divisor\n            ? toPercentage(this, divisor)\n            : formatNumber(this);\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON(onlyHex = false) {\n        // FIXME this return type should by string | number, however BN returns string\n        // Options here are\n        //   - super.bitLength() - the actual used bits, use hex when close to MAX_SAFE_INTEGER\n        //   - this.#bitLength - the max used bits, use hex when larger than native Rust type\n        return onlyHex || (this.#bitLength > 128) || (super.bitLength() > MAX_NUMBER_BITS)\n            ? this.toHex()\n            : this.toNumber();\n    }\n    /**\n     * @description Returns the value in a primitive form, either number when <= 52 bits, or string otherwise\n     */\n    toPrimitive() {\n        return super.bitLength() > MAX_NUMBER_BITS\n            ? this.toString()\n            : this.toNumber();\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        // NOTE In the case of balances, which have a special meaning on the UI\n        // and can be interpreted differently, return a specific value for it so\n        // underlying it always matches (no matter which length it actually is)\n        return this instanceof this.registry.createClassUnsafe('Balance')\n            ? 'Balance'\n            : `${this.isUnsigned ? 'u' : 'i'}${this.bitLength()}`;\n    }\n    /**\n     * @description Returns the string representation of the value\n     * @param base The base to use for the conversion\n     */\n    toString(base) {\n        // only included here since we do not inherit docs\n        return super.toString(base);\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     */\n    toU8a(_isBare) {\n        return bnToU8a(this, {\n            bitLength: this.bitLength(),\n            isLe: true,\n            isNegative: !this.isUnsigned\n        });\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 962, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/base/UInt.js"],"sourcesContent":["import { AbstractInt } from '../abstract/Int.js';\n/**\n * @name UInt\n * @description\n * A generic unsigned integer codec. For Substrate all numbers are Little Endian encoded,\n * this handles the encoding and decoding of those numbers. Upon construction\n * the bitLength is provided and any additional use keeps the number to this\n * length. This extends `BN`, so all methods available on a normal `BN` object\n * is available here.\n * @noInheritDoc\n */\nexport class UInt extends AbstractInt {\n    static with(bitLength, typeName) {\n        return class extends UInt {\n            constructor(registry, value) {\n                super(registry, value, bitLength);\n            }\n            toRawType() {\n                return typeName || super.toRawType();\n            }\n        };\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;AAWO,MAAM,aAAa,8KAAW;IACjC,OAAO,KAAK,SAAS,EAAE,QAAQ,EAAE;QAC7B,OAAO,cAAc;YACjB,YAAY,QAAQ,EAAE,KAAK,CAAE;gBACzB,KAAK,CAAC,UAAU,OAAO;YAC3B;YACA,YAAY;gBACR,OAAO,YAAY,KAAK,CAAC;YAC7B;QACJ;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 984, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/primitive/U32.js"],"sourcesContent":["import { UInt } from '../base/UInt.js';\n/**\n * @name u32\n * @description\n * A 32-bit unsigned integer\n */\nexport class u32 extends UInt.with(32) {\n    // NOTE without this, we cannot properly determine extensions\n    __UIntType = 'u32';\n}\n"],"names":[],"mappings":";;;;AAAA;;AAMO,MAAM,YAAY,oKAAI,CAAC,IAAI,CAAC;IAC/B,6DAA6D;IAC7D,aAAa,MAAM;AACvB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1007, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/base/DoNotConstruct.js"],"sourcesContent":["/**\n * @name DoNotConstruct\n * @description\n * An unknown type that fails on construction with the type info\n */\nexport class DoNotConstruct {\n    registry;\n    createdAtHash;\n    isStorageFallback;\n    #neverError;\n    constructor(registry, typeName = 'DoNotConstruct') {\n        this.registry = registry;\n        this.#neverError = new Error(`DoNotConstruct: Cannot construct unknown type ${typeName}`);\n        throw this.#neverError;\n    }\n    static with(typeName) {\n        return class extends DoNotConstruct {\n            constructor(registry) {\n                super(registry, typeName);\n            }\n        };\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        throw this.#neverError;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        throw this.#neverError;\n    }\n    /**\n     * @description Checks if the value is an empty value (always true)\n     */\n    get isEmpty() {\n        throw this.#neverError;\n    }\n    /**\n     * @description Unimplemented\n     */\n    eq() {\n        throw this.#neverError;\n    }\n    /**\n     * @description Unimplemented\n     */\n    inspect() {\n        throw this.#neverError;\n    }\n    /**\n     * @description Unimplemented\n     */\n    toHex() {\n        throw this.#neverError;\n    }\n    /**\n     * @description Unimplemented\n     */\n    toHuman() {\n        throw this.#neverError;\n    }\n    /**\n     * @description Unimplemented\n     */\n    toJSON() {\n        throw this.#neverError;\n    }\n    /**\n     * @description Unimplemented\n     */\n    toPrimitive() {\n        throw this.#neverError;\n    }\n    /**\n     * @description Unimplemented\n     */\n    toRawType() {\n        throw this.#neverError;\n    }\n    /**\n     * @description Unimplemented\n     */\n    toString() {\n        throw this.#neverError;\n    }\n    /**\n     * @description Unimplemented\n     */\n    toU8a() {\n        throw this.#neverError;\n    }\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;AACM,MAAM;IACT,SAAS;IACT,cAAc;IACd,kBAAkB;IAClB,CAAA,UAAW,CAAC;IACZ,YAAY,QAAQ,EAAE,WAAW,gBAAgB,CAAE;QAC/C,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,CAAA,UAAW,GAAG,IAAI,MAAM,CAAC,8CAA8C,EAAE,UAAU;QACxF,MAAM,IAAI,CAAC,CAAA,UAAW;IAC1B;IACA,OAAO,KAAK,QAAQ,EAAE;QAClB,OAAO,cAAc;YACjB,YAAY,QAAQ,CAAE;gBAClB,KAAK,CAAC,UAAU;YACpB;QACJ;IACJ;IACA;;KAEC,GACD,IAAI,gBAAgB;QAChB,MAAM,IAAI,CAAC,CAAA,UAAW;IAC1B;IACA;;KAEC,GACD,IAAI,OAAO;QACP,MAAM,IAAI,CAAC,CAAA,UAAW;IAC1B;IACA;;KAEC,GACD,IAAI,UAAU;QACV,MAAM,IAAI,CAAC,CAAA,UAAW;IAC1B;IACA;;KAEC,GACD,KAAK;QACD,MAAM,IAAI,CAAC,CAAA,UAAW;IAC1B;IACA;;KAEC,GACD,UAAU;QACN,MAAM,IAAI,CAAC,CAAA,UAAW;IAC1B;IACA;;KAEC,GACD,QAAQ;QACJ,MAAM,IAAI,CAAC,CAAA,UAAW;IAC1B;IACA;;KAEC,GACD,UAAU;QACN,MAAM,IAAI,CAAC,CAAA,UAAW;IAC1B;IACA;;KAEC,GACD,SAAS;QACL,MAAM,IAAI,CAAC,CAAA,UAAW;IAC1B;IACA;;KAEC,GACD,cAAc;QACV,MAAM,IAAI,CAAC,CAAA,UAAW;IAC1B;IACA;;KAEC,GACD,YAAY;QACR,MAAM,IAAI,CAAC,CAAA,UAAW;IAC1B;IACA;;KAEC,GACD,WAAW;QACP,MAAM,IAAI,CAAC,CAAA,UAAW;IAC1B;IACA;;KAEC,GACD,QAAQ;QACJ,MAAM,IAAI,CAAC,CAAA,UAAW;IAC1B;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1097, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/native/Json.js"],"sourcesContent":["import { isFunction, objectProperties, stringify } from '@polkadot/util';\nimport { compareMap } from '../utils/index.js';\n/** @internal */\nfunction decodeJson(value) {\n    return Object.entries(value || {});\n}\n/**\n * @name Json\n * @description\n * Wraps the a JSON structure retrieve via RPC. It extends the standard JS Map with. While it\n * implements a Codec, it is limited in that it can only be used with input objects via RPC,\n * i.e. no hex decoding. Unlike a struct, this waps a JSON object with unknown keys\n * @noInheritDoc\n */\nexport class Json extends Map {\n    registry;\n    createdAtHash;\n    initialU8aLength;\n    isStorageFallback;\n    constructor(registry, value) {\n        const decoded = decodeJson(value);\n        super(decoded);\n        this.registry = registry;\n        objectProperties(this, decoded.map(([k]) => k), (k) => this.get(k));\n    }\n    /**\n     * @description Always 0, never encodes as a Uint8Array\n     */\n    get encodedLength() {\n        return 0 | 0;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Checks if the value is an empty value\n     */\n    get isEmpty() {\n        return [...this.keys()].length === 0;\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        return compareMap(this, other);\n    }\n    /**\n     * @description Returns a typed value from the internal map\n     */\n    getT(key) {\n        return this.get(key);\n    }\n    /**\n     * @description Unimplemented, will throw\n     */\n    inspect() {\n        throw new Error('Unimplemented');\n    }\n    /**\n     * @description Unimplemented, will throw\n     */\n    toHex() {\n        throw new Error('Unimplemented');\n    }\n    /**\n     * @description Converts the Object to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman() {\n        return [...this.entries()].reduce((json, [key, value]) => {\n            json[key] = isFunction(value?.toHuman)\n                ? value.toHuman()\n                : value;\n            return json;\n        }, {});\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        return [...this.entries()].reduce((json, [key, value]) => {\n            json[key] = value;\n            return json;\n        }, {});\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive(disableAscii) {\n        return [...this.entries()].reduce((json, [key, value]) => {\n            json[key] = isFunction(value.toPrimitive)\n                ? value.toPrimitive(disableAscii)\n                : value;\n            return json;\n        }, {});\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'Json';\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        return stringify(this.toJSON());\n    }\n    /**\n     * @description Unimplemented, will throw\n     */\n    toU8a(_isBare) {\n        throw new Error('Unimplemented');\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AAAA;AACA;;;AACA,cAAc,GACd,SAAS,WAAW,KAAK;IACrB,OAAO,OAAO,OAAO,CAAC,SAAS,CAAC;AACpC;AASO,MAAM,aAAa;IACtB,SAAS;IACT,cAAc;IACd,iBAAiB;IACjB,kBAAkB;IAClB,YAAY,QAAQ,EAAE,KAAK,CAAE;QACzB,MAAM,UAAU,WAAW;QAC3B,KAAK,CAAC;QACN,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAA,4KAAgB,EAAC,IAAI,EAAE,QAAQ,GAAG,CAAC,CAAC,CAAC,EAAE,GAAK,IAAI,CAAC,IAAM,IAAI,CAAC,GAAG,CAAC;IACpE;IACA;;KAEC,GACD,IAAI,gBAAgB;QAChB,OAAO,IAAI;IACf;IACA;;KAEC,GACD,IAAI,OAAO;QACP,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK;IACxC;IACA;;KAEC,GACD,IAAI,UAAU;QACV,OAAO;eAAI,IAAI,CAAC,IAAI;SAAG,CAAC,MAAM,KAAK;IACvC;IACA;;KAEC,GACD,GAAG,KAAK,EAAE;QACN,OAAO,IAAA,iLAAU,EAAC,IAAI,EAAE;IAC5B;IACA;;KAEC,GACD,KAAK,GAAG,EAAE;QACN,OAAO,IAAI,CAAC,GAAG,CAAC;IACpB;IACA;;KAEC,GACD,UAAU;QACN,MAAM,IAAI,MAAM;IACpB;IACA;;KAEC,GACD,QAAQ;QACJ,MAAM,IAAI,MAAM;IACpB;IACA;;KAEC,GACD,UAAU;QACN,OAAO;eAAI,IAAI,CAAC,OAAO;SAAG,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,KAAK,MAAM;YACjD,IAAI,CAAC,IAAI,GAAG,IAAA,kKAAU,EAAC,OAAO,WACxB,MAAM,OAAO,KACb;YACN,OAAO;QACX,GAAG,CAAC;IACR;IACA;;KAEC,GACD,SAAS;QACL,OAAO;eAAI,IAAI,CAAC,OAAO;SAAG,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,KAAK,MAAM;YACjD,IAAI,CAAC,IAAI,GAAG;YACZ,OAAO;QACX,GAAG,CAAC;IACR;IACA;;KAEC,GACD,YAAY,YAAY,EAAE;QACtB,OAAO;eAAI,IAAI,CAAC,OAAO;SAAG,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,KAAK,MAAM;YACjD,IAAI,CAAC,IAAI,GAAG,IAAA,kKAAU,EAAC,MAAM,WAAW,IAClC,MAAM,WAAW,CAAC,gBAClB;YACN,OAAO;QACX,GAAG,CAAC;IACR;IACA;;KAEC,GACD,YAAY;QACR,OAAO;IACX;IACA;;KAEC,GACD,WAAW;QACP,OAAO,IAAA,4JAAS,EAAC,IAAI,CAAC,MAAM;IAChC;IACA;;KAEC,GACD,MAAM,OAAO,EAAE;QACX,MAAM,IAAI,MAAM;IACpB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1208, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/native/Raw.js"],"sourcesContent":["import { isAscii, isUndefined, isUtf8, u8aToHex, u8aToString, u8aToU8a } from '@polkadot/util';\n/**\n * @name Raw\n * @description\n * A basic wrapper around Uint8Array, with no frills and no fuss. It does differ\n * from other implementations where it will consume the full Uint8Array as passed to it.\n * As such it is meant to be subclassed where the wrapper takes care of the\n * actual lengths instead of used directly.\n * @noInheritDoc\n */\nexport class Raw extends Uint8Array {\n    registry;\n    createdAtHash;\n    initialU8aLength;\n    isStorageFallback;\n    /**\n     * @description This ensures that operators such as clice, filter, map, etc. return\n     * new Array instances (without this we need to apply overrides)\n     */\n    static get [Symbol.species]() {\n        return Uint8Array;\n    }\n    constructor(registry, value, initialU8aLength) {\n        super(u8aToU8a(value));\n        this.registry = registry;\n        this.initialU8aLength = initialU8aLength;\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        return this.length;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Returns true if the wrapped value contains only ASCII printable characters\n     */\n    get isAscii() {\n        return isAscii(this);\n    }\n    /**\n     * @description Returns true if the type wraps an empty/default all-0 value\n     */\n    get isEmpty() {\n        return !this.length || isUndefined(this.find((b) => !!b));\n    }\n    /**\n     * @description Returns true if the wrapped value contains only utf8 characters\n     */\n    get isUtf8() {\n        return isUtf8(this);\n    }\n    /**\n     * @description Returns the number of bits in the value\n     */\n    bitLength() {\n        return this.length * 8;\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        if (other instanceof Uint8Array) {\n            return (this.length === other.length) &&\n                !this.some((b, index) => b !== other[index]);\n        }\n        return this.eq(u8aToU8a(other));\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return {\n            outer: [this.toU8a()]\n        };\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n    toHex() {\n        return u8aToHex(this);\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman(_isExtended, disableAscii) {\n        return this.toPrimitive(disableAscii);\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        return this.toHex();\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive(disableAscii) {\n        if (!disableAscii && this.isAscii) {\n            const text = this.toUtf8();\n            // ensure we didn't end up with multibyte codepoints\n            if (isAscii(text)) {\n                return text;\n            }\n        }\n        return this.toJSON();\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'Raw';\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        return this.toHex();\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     */\n    toU8a(_isBare) {\n        return Uint8Array.from(this);\n    }\n    /**\n     * @description Returns the wrapped data as a UTF-8 string\n     */\n    toUtf8() {\n        if (!this.isUtf8) {\n            throw new Error('The character sequence is not a valid Utf8 string');\n        }\n        return u8aToString(this);\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAUO,MAAM,YAAY;IACrB,SAAS;IACT,cAAc;IACd,iBAAiB;IACjB,kBAAkB;IAClB;;;KAGC,GACD,WAAW,CAAC,OAAO,OAAO,CAAC,GAAG;QAC1B,OAAO;IACX;IACA,YAAY,QAAQ,EAAE,KAAK,EAAE,gBAAgB,CAAE;QAC3C,KAAK,CAAC,IAAA,8JAAQ,EAAC;QACf,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,gBAAgB,GAAG;IAC5B;IACA;;KAEC,GACD,IAAI,gBAAgB;QAChB,OAAO,IAAI,CAAC,MAAM;IACtB;IACA;;KAEC,GACD,IAAI,OAAO;QACP,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK;IACxC;IACA;;KAEC,GACD,IAAI,UAAU;QACV,OAAO,IAAA,4JAAO,EAAC,IAAI;IACvB;IACA;;KAEC,GACD,IAAI,UAAU;QACV,OAAO,CAAC,IAAI,CAAC,MAAM,IAAI,IAAA,oKAAW,EAAC,IAAI,CAAC,IAAI,CAAC,CAAC,IAAM,CAAC,CAAC;IAC1D;IACA;;KAEC,GACD,IAAI,SAAS;QACT,OAAO,IAAA,0JAAM,EAAC,IAAI;IACtB;IACA;;KAEC,GACD,YAAY;QACR,OAAO,IAAI,CAAC,MAAM,GAAG;IACzB;IACA;;KAEC,GACD,GAAG,KAAK,EAAE;QACN,IAAI,iBAAiB,YAAY;YAC7B,OAAO,AAAC,IAAI,CAAC,MAAM,KAAK,MAAM,MAAM,IAChC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,GAAG,QAAU,MAAM,KAAK,CAAC,MAAM;QACnD;QACA,OAAO,IAAI,CAAC,EAAE,CAAC,IAAA,8JAAQ,EAAC;IAC5B;IACA;;KAEC,GACD,UAAU;QACN,OAAO;YACH,OAAO;gBAAC,IAAI,CAAC,KAAK;aAAG;QACzB;IACJ;IACA;;KAEC,GACD,QAAQ;QACJ,OAAO,IAAA,8JAAQ,EAAC,IAAI;IACxB;IACA;;KAEC,GACD,QAAQ,WAAW,EAAE,YAAY,EAAE;QAC/B,OAAO,IAAI,CAAC,WAAW,CAAC;IAC5B;IACA;;KAEC,GACD,SAAS;QACL,OAAO,IAAI,CAAC,KAAK;IACrB;IACA;;KAEC,GACD,YAAY,YAAY,EAAE;QACtB,IAAI,CAAC,gBAAgB,IAAI,CAAC,OAAO,EAAE;YAC/B,MAAM,OAAO,IAAI,CAAC,MAAM;YACxB,oDAAoD;YACpD,IAAI,IAAA,4JAAO,EAAC,OAAO;gBACf,OAAO;YACX;QACJ;QACA,OAAO,IAAI,CAAC,MAAM;IACtB;IACA;;KAEC,GACD,YAAY;QACR,OAAO;IACX;IACA;;KAEC,GACD,WAAW;QACP,OAAO,IAAI,CAAC,KAAK;IACrB;IACA;;KAEC,GACD,MAAM,OAAO,EAAE;QACX,OAAO,WAAW,IAAI,CAAC,IAAI;IAC/B;IACA;;KAEC,GACD,SAAS;QACL,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE;YACd,MAAM,IAAI,MAAM;QACpB;QACA,OAAO,IAAA,oKAAW,EAAC,IAAI;IAC3B;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1337, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/utils/compareArray.js"],"sourcesContent":["import { isUndefined } from '@polkadot/util';\nimport { hasEq } from './util.js';\nexport function compareArray(a, b) {\n    if (Array.isArray(b)) {\n        return (a.length === b.length) && isUndefined(a.find((v, index) => hasEq(v)\n            ? !v.eq(b[index])\n            : v !== b[index]));\n    }\n    return false;\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AACO,SAAS,aAAa,CAAC,EAAE,CAAC;IAC7B,IAAI,MAAM,OAAO,CAAC,IAAI;QAClB,OAAO,AAAC,EAAE,MAAM,KAAK,EAAE,MAAM,IAAK,IAAA,oKAAW,EAAC,EAAE,IAAI,CAAC,CAAC,GAAG,QAAU,IAAA,sKAAK,EAAC,KACnE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,MAAM,IACd,MAAM,CAAC,CAAC,MAAM;IACxB;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1355, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/abstract/Array.js"],"sourcesContent":["import { compactToU8a, u8aConcatStrict, u8aToHex } from '@polkadot/util';\nimport { compareArray } from '../utils/compareArray.js';\n/**\n * @name AbstractArray\n * @description\n * This manages codec arrays. It is an extension to Array, providing\n * specific encoding/decoding on top of the base type.\n * @noInheritDoc\n */\nexport class AbstractArray extends Array {\n    registry;\n    createdAtHash;\n    initialU8aLength;\n    isStorageFallback;\n    /**\n     * @description This ensures that operators such as clice, filter, map, etc. return\n     * new Array instances (without this we need to apply overrides)\n     */\n    static get [Symbol.species]() {\n        return Array;\n    }\n    constructor(registry, length) {\n        super(length);\n        this.registry = registry;\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        // We need to loop through all entries since they may have a variable length themselves,\n        // e.g. when a Vec or Compact is contained withing, it has a variable length based on data\n        const count = this.length;\n        let total = compactToU8a(count).length;\n        for (let i = 0; i < count; i++) {\n            total += this[i].encodedLength;\n        }\n        return total;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Checks if the value is an empty value\n     */\n    get isEmpty() {\n        return this.length === 0;\n    }\n    /**\n     * @description The length of the value\n     */\n    get length() {\n        // only included here since we ignore inherited docs\n        return super.length;\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        return compareArray(this, other);\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return {\n            inner: this.inspectInner(),\n            outer: [compactToU8a(this.length)]\n        };\n    }\n    /**\n     * @internal\n     * @description Internal per-item inspection of internal values\n     */\n    inspectInner() {\n        const count = this.length;\n        const inner = new Array(count);\n        for (let i = 0; i < count; i++) {\n            inner[i] = this[i].inspect();\n        }\n        return inner;\n    }\n    /**\n     * @description Converts the Object to an standard JavaScript Array\n     */\n    toArray() {\n        return Array.from(this);\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n    toHex() {\n        return u8aToHex(this.toU8a());\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman(isExtended, disableAscii) {\n        const count = this.length;\n        const result = new Array(count);\n        for (let i = 0; i < count; i++) {\n            result[i] = this[i] && this[i].toHuman(isExtended, disableAscii);\n        }\n        return result;\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        const count = this.length;\n        const result = new Array(count);\n        for (let i = 0; i < count; i++) {\n            // We actually log inside the U8a decoding and use JSON.stringify(...), which\n            // means that the Vec may be partially populated (same applies to toHuman, same check)\n            result[i] = this[i] && this[i].toJSON();\n        }\n        return result;\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive(disableAscii) {\n        const count = this.length;\n        const result = new Array(count);\n        for (let i = 0; i < count; i++) {\n            result[i] = this[i] && this[i].toPrimitive(disableAscii);\n        }\n        return result;\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        const count = this.length;\n        const result = new Array(count);\n        for (let i = 0; i < count; i++) {\n            result[i] = this[i].toString();\n        }\n        return `[${result.join(', ')}]`;\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        const encoded = this.toU8aInner();\n        return isBare\n            ? u8aConcatStrict(encoded)\n            : u8aConcatStrict([compactToU8a(this.length), ...encoded]);\n    }\n    /**\n     * @internal\n     * @description Internal per-item SCALE encoding of contained values\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8aInner(isBare) {\n        const count = this.length;\n        const encoded = new Array(count);\n        for (let i = 0; i < count; i++) {\n            encoded[i] = this[i].toU8a(isBare);\n        }\n        return encoded;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1513, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/base/Null.js"],"sourcesContent":["import { isNull } from '@polkadot/util';\n/**\n * @name Null\n * @description\n * Implements a type that does not contain anything (apart from `null`)\n */\nexport class Null {\n    encodedLength = 0;\n    isEmpty = true;\n    registry;\n    createdAtHash;\n    initialU8aLength = 0;\n    isStorageFallback;\n    constructor(registry) {\n        this.registry = registry;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        throw new Error('.hash is not implemented on Null');\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        return other instanceof Null || isNull(other);\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return {};\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n    toHex() {\n        return '0x';\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman() {\n        return this.toJSON();\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        return null;\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive() {\n        return null;\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'Null';\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        return '';\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     */\n    toU8a(_isBare) {\n        return new Uint8Array();\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;AAMO,MAAM;IACT,gBAAgB,EAAE;IAClB,UAAU,KAAK;IACf,SAAS;IACT,cAAc;IACd,mBAAmB,EAAE;IACrB,kBAAkB;IAClB,YAAY,QAAQ,CAAE;QAClB,IAAI,CAAC,QAAQ,GAAG;IACpB;IACA;;KAEC,GACD,IAAI,OAAO;QACP,MAAM,IAAI,MAAM;IACpB;IACA;;KAEC,GACD,GAAG,KAAK,EAAE;QACN,OAAO,iBAAiB,QAAQ,IAAA,0JAAM,EAAC;IAC3C;IACA;;KAEC,GACD,UAAU;QACN,OAAO,CAAC;IACZ;IACA;;KAEC,GACD,QAAQ;QACJ,OAAO;IACX;IACA;;KAEC,GACD,UAAU;QACN,OAAO,IAAI,CAAC,MAAM;IACtB;IACA;;KAEC,GACD,SAAS;QACL,OAAO;IACX;IACA;;KAEC,GACD,cAAc;QACV,OAAO;IACX;IACA;;KAEC,GACD,YAAY;QACR,OAAO;IACX;IACA;;KAEC,GACD,WAAW;QACP,OAAO;IACX;IACA;;KAEC,GACD,MAAM,OAAO,EAAE;QACX,OAAO,IAAI;IACf;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1584, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/base/Enum.js"],"sourcesContent":["import { identity, isHex, isNumber, isObject, isString, isU8a, objectProperties, stringCamelCase, stringify, stringPascalCase, u8aConcatStrict, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { mapToTypeMap, typesToMap } from '../utils/index.js';\nimport { Null } from './Null.js';\nfunction isRustEnum(def) {\n    const defValues = Object.values(def);\n    if (defValues.some((v) => isNumber(v))) {\n        if (!defValues.every((v) => isNumber(v) && v >= 0 && v <= 255)) {\n            throw new Error('Invalid number-indexed enum definition');\n        }\n        return false;\n    }\n    return true;\n}\nfunction extractDef(registry, _def) {\n    const def = {};\n    let isBasic;\n    let isIndexed;\n    if (Array.isArray(_def)) {\n        for (let i = 0, count = _def.length; i < count; i++) {\n            def[_def[i]] = { Type: Null, index: i };\n        }\n        isBasic = true;\n        isIndexed = false;\n    }\n    else if (isRustEnum(_def)) {\n        const [Types, keys] = mapToTypeMap(registry, _def);\n        for (let i = 0, count = keys.length; i < count; i++) {\n            def[keys[i]] = { Type: Types[i], index: i };\n        }\n        isBasic = !Object.values(def).some(({ Type }) => Type !== Null);\n        isIndexed = false;\n    }\n    else {\n        const entries = Object.entries(_def);\n        for (let i = 0, count = entries.length; i < count; i++) {\n            const [key, index] = entries[i];\n            def[key] = { Type: Null, index };\n        }\n        isBasic = true;\n        isIndexed = true;\n    }\n    return {\n        def,\n        isBasic,\n        isIndexed\n    };\n}\nfunction getEntryType(def, checkIdx) {\n    const values = Object.values(def);\n    for (let i = 0, count = values.length; i < count; i++) {\n        const { Type, index } = values[i];\n        if (index === checkIdx) {\n            return Type;\n        }\n    }\n    throw new Error(`Unable to create Enum via index ${checkIdx}, in ${Object.keys(def).join(', ')}`);\n}\nfunction createFromU8a(registry, def, index, value) {\n    const Type = getEntryType(def, index);\n    return {\n        index,\n        value: new Type(registry, value)\n    };\n}\nfunction createFromValue(registry, def, index = 0, value) {\n    const Type = getEntryType(def, index);\n    return {\n        index,\n        value: value instanceof Type\n            ? value\n            : new Type(registry, value)\n    };\n}\nfunction decodeFromJSON(registry, def, key, value) {\n    // JSON comes in the form of { \"<type (camelCase)>\": \"<value for type>\" }, here we\n    // additionally force to lower to ensure forward compat\n    const keys = Object.keys(def).map((k) => k.toLowerCase());\n    const keyLower = key.toLowerCase();\n    const index = keys.indexOf(keyLower);\n    if (index === -1) {\n        throw new Error(`Cannot map Enum JSON, unable to find '${key}' in ${keys.join(', ')}`);\n    }\n    try {\n        return createFromValue(registry, def, Object.values(def)[index].index, value);\n    }\n    catch (error) {\n        throw new Error(`Enum(${key}):: ${error.message}`);\n    }\n}\nfunction decodeEnum(registry, def, value, index) {\n    // NOTE We check the index path first, before looking at values - this allows treating\n    // the optional indexes before anything else, more-specific > less-specific\n    if (isNumber(index)) {\n        return createFromValue(registry, def, index, value);\n    }\n    else if (isU8a(value) || isHex(value)) {\n        const u8a = u8aToU8a(value);\n        // nested, we don't want to match isObject below\n        if (u8a.length) {\n            return createFromU8a(registry, def, u8a[0], u8a.subarray(1));\n        }\n    }\n    else if (value instanceof Enum) {\n        return createFromValue(registry, def, value.index, value.value);\n    }\n    else if (isNumber(value)) {\n        return createFromValue(registry, def, value);\n    }\n    else if (isString(value)) {\n        return decodeFromJSON(registry, def, value.toString());\n    }\n    else if (isObject(value)) {\n        const key = Object.keys(value)[0];\n        return decodeFromJSON(registry, def, key, value[key]);\n    }\n    // Worst-case scenario, return the first with default\n    return createFromValue(registry, def, Object.values(def)[0].index);\n}\n/**\n * @name Enum\n * @description\n * This implements an enum, that based on the value wraps a different type. It is effectively\n * an extension to enum where the value type is determined by the actual index.\n */\nexport class Enum {\n    registry;\n    createdAtHash;\n    initialU8aLength;\n    isStorageFallback;\n    #def;\n    #entryIndex;\n    #indexes;\n    #isBasic;\n    #isIndexed;\n    #raw;\n    constructor(registry, Types, value, index, { definition, setDefinition = identity } = {}) {\n        const { def, isBasic, isIndexed } = definition || setDefinition(extractDef(registry, Types));\n        // shortcut isU8a as used in SCALE decoding\n        const decoded = isU8a(value) && value.length && !isNumber(index)\n            ? createFromU8a(registry, def, value[0], value.subarray(1))\n            : decodeEnum(registry, def, value, index);\n        this.registry = registry;\n        this.#def = def;\n        this.#isBasic = isBasic;\n        this.#isIndexed = isIndexed;\n        this.#indexes = Object.values(def).map(({ index }) => index);\n        this.#entryIndex = this.#indexes.indexOf(decoded.index);\n        this.#raw = decoded.value;\n        if (this.#raw.initialU8aLength) {\n            this.initialU8aLength = 1 + this.#raw.initialU8aLength;\n        }\n    }\n    static with(Types) {\n        let definition;\n        // eslint-disable-next-line no-return-assign\n        const setDefinition = (d) => definition = d;\n        return class extends Enum {\n            static {\n                const keys = Array.isArray(Types)\n                    ? Types\n                    : Object.keys(Types);\n                const count = keys.length;\n                const asKeys = new Array(count);\n                const isKeys = new Array(count);\n                for (let i = 0; i < count; i++) {\n                    const name = stringPascalCase(keys[i]);\n                    asKeys[i] = `as${name}`;\n                    isKeys[i] = `is${name}`;\n                }\n                objectProperties(this.prototype, isKeys, (_, i, self) => self.type === keys[i]);\n                objectProperties(this.prototype, asKeys, (k, i, self) => {\n                    if (self.type !== keys[i]) {\n                        throw new Error(`Cannot convert '${self.type}' via ${k}`);\n                    }\n                    return self.value;\n                });\n            }\n            constructor(registry, value, index) {\n                super(registry, Types, value, index, { definition, setDefinition });\n            }\n        };\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        return 1 + this.#raw.encodedLength;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description The index of the enum value\n     */\n    get index() {\n        return this.#indexes[this.#entryIndex];\n    }\n    /**\n     * @description The value of the enum\n     */\n    get inner() {\n        return this.#raw;\n    }\n    /**\n     * @description true if this is a basic enum (no values)\n     */\n    get isBasic() {\n        return this.#isBasic;\n    }\n    /**\n     * @description Checks if the value is an empty value\n     */\n    get isEmpty() {\n        return this.#raw.isEmpty;\n    }\n    /**\n     * @description Checks if the Enum points to a [[Null]] type\n     */\n    get isNone() {\n        return this.#raw instanceof Null;\n    }\n    /**\n     * @description The available keys for this enum\n     */\n    get defIndexes() {\n        return this.#indexes;\n    }\n    /**\n     * @description The available keys for this enum\n     */\n    get defKeys() {\n        return Object.keys(this.#def);\n    }\n    /**\n     * @description The name of the type this enum value represents\n     */\n    get type() {\n        return this.defKeys[this.#entryIndex];\n    }\n    /**\n     * @description The value of the enum\n     */\n    get value() {\n        return this.#raw;\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        // cater for the case where we only pass the enum index\n        if (isU8a(other)) {\n            return !this.toU8a().some((entry, index) => entry !== other[index]);\n        }\n        else if (isNumber(other)) {\n            return this.toNumber() === other;\n        }\n        else if (this.#isBasic && isString(other)) {\n            return this.type === other;\n        }\n        else if (isHex(other)) {\n            return this.toHex() === other;\n        }\n        else if (other instanceof Enum) {\n            return this.index === other.index && this.value.eq(other.value);\n        }\n        else if (isObject(other)) {\n            return this.value.eq(other[this.type]);\n        }\n        // compare the actual wrapper value\n        return this.value.eq(other);\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        if (this.#isBasic) {\n            return { outer: [new Uint8Array([this.index])] };\n        }\n        const { inner, outer = [] } = this.#raw.inspect();\n        return {\n            inner,\n            outer: [new Uint8Array([this.index]), ...outer]\n        };\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n    toHex() {\n        return u8aToHex(this.toU8a());\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman(isExtended, disableAscii) {\n        return this.#isBasic || this.isNone\n            ? this.type\n            : { [this.type]: this.#raw.toHuman(isExtended, disableAscii) };\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        return this.#isBasic\n            ? this.type\n            : { [stringCamelCase(this.type)]: this.#raw.toJSON() };\n    }\n    /**\n     * @description Returns the number representation for the value\n     */\n    toNumber() {\n        return this.index;\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive(disableAscii) {\n        return this.#isBasic\n            ? this.type\n            : { [stringCamelCase(this.type)]: this.#raw.toPrimitive(disableAscii) };\n    }\n    /**\n     * @description Returns a raw struct representation of the enum types\n     */\n    _toRawStruct() {\n        if (this.#isBasic) {\n            return this.#isIndexed\n                ? this.defKeys.reduce((out, key, index) => {\n                    out[key] = this.#indexes[index];\n                    return out;\n                }, {})\n                : this.defKeys;\n        }\n        const entries = Object.entries(this.#def);\n        return typesToMap(this.registry, entries.reduce((out, [key, { Type }], i) => {\n            out[0][i] = Type;\n            out[1][i] = key;\n            return out;\n        }, [new Array(entries.length), new Array(entries.length)]));\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return stringify({ _enum: this._toRawStruct() });\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        return this.isNone\n            ? this.type\n            : stringify(this.toJSON());\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        return isBare\n            ? this.#raw.toU8a(isBare)\n            : u8aConcatStrict([\n                new Uint8Array([this.index]),\n                this.#raw.toU8a(isBare)\n            ]);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1953, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/utils/sortValues.js"],"sourcesContent":["import { bnToBn, isBigInt, isBn, isBoolean, isCodec, isNumber, stringify } from '@polkadot/util';\n/** @internal **/\nfunction isArrayLike(arg) {\n    return arg instanceof Uint8Array || Array.isArray(arg);\n}\n/** @internal **/\nfunction isEnum(arg) {\n    return isCodec(arg) && isNumber(arg.index) && isCodec(arg.value);\n}\n/** @internal **/\nfunction isOption(arg) {\n    return isCodec(arg) && isBoolean(arg.isSome) && isCodec(arg.value);\n}\n/** @internal */\nfunction isNumberLike(arg) {\n    return isNumber(arg) || isBn(arg) || isBigInt(arg);\n}\n/** @internal */\nfunction sortArray(a, b) {\n    // Vec, Tuple, Bytes etc.\n    let sortRes = 0;\n    const minLen = Math.min(a.length, b.length);\n    for (let i = 0; i < minLen; ++i) {\n        sortRes = sortAsc(a[i], b[i]);\n        if (sortRes !== 0) {\n            return sortRes;\n        }\n    }\n    return a.length - b.length;\n}\n/** @internal */\nfunction checkForDuplicates(container, seen, arg) {\n    // Convert the value to hex.\n    if (isCodec(arg)) {\n        const hex = arg.toHex();\n        // Check if we have seen the value.\n        if (seen.has(hex)) {\n            // Duplicates are not allowed.\n            throw new Error(`Duplicate value in ${container}: ${stringify(arg)}`);\n        }\n        seen.add(hex);\n    }\n    return true;\n}\n/**\n* Sort keys/values of BTreeSet/BTreeMap in ascending order for encoding compatibility with Rust's BTreeSet/BTreeMap\n* (https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html)\n* (https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html)\n*/\nexport function sortAsc(a, b) {\n    if (isNumberLike(a) && isNumberLike(b)) {\n        return bnToBn(a).cmp(bnToBn(b));\n    }\n    else if (a instanceof Map && b instanceof Map) {\n        return sortAsc(Array.from(a.values()), Array.from(b.values()));\n    }\n    else if (isEnum(a) && isEnum(b)) {\n        return sortAsc(a.index, b.index) || sortAsc(a.value, b.value);\n    }\n    else if (isOption(a) && isOption(b)) {\n        return sortAsc(a.isNone ? 0 : 1, b.isNone ? 0 : 1) || sortAsc(a.value, b.value);\n    }\n    else if (isArrayLike(a) && isArrayLike(b)) {\n        return sortArray(a, b);\n    }\n    else if (isCodec(a) && isCodec(b)) {\n        // Text, Bool etc.\n        return sortAsc(a.toU8a(true), b.toU8a(true));\n    }\n    throw new Error(`Attempting to sort unrecognized values: ${stringify(a)} (typeof ${typeof a}) <-> ${stringify(b)} (typeof ${typeof b})`);\n}\nexport function sortSet(set) {\n    const seen = new Set();\n    return new Set(Array.from(set).filter((value) => checkForDuplicates('BTreeSet', seen, value)).sort(sortAsc));\n}\nexport function sortMap(map) {\n    const seen = new Set();\n    return new Map(Array.from(map.entries()).filter(([key]) => checkForDuplicates('BTreeMap', seen, key)).sort(([keyA], [keyB]) => sortAsc(keyA, keyB)));\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2035, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/extended/Map.js"],"sourcesContent":["import { compactFromU8aLim, compactToU8a, isHex, isObject, isU8a, logger, stringify, u8aConcatStrict, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { AbstractArray } from '../abstract/Array.js';\nimport { Enum } from '../base/Enum.js';\nimport { Raw } from '../native/Raw.js';\nimport { Struct } from '../native/Struct.js';\nimport { compareMap, decodeU8a, sortMap, typeToConstructor } from '../utils/index.js';\nconst l = logger('Map');\n/** @internal */\nfunction decodeMapFromU8a(registry, KeyClass, ValClass, u8a) {\n    const output = new Map();\n    const [offset, count] = compactFromU8aLim(u8a);\n    const types = [];\n    for (let i = 0; i < count; i++) {\n        types.push(KeyClass, ValClass);\n    }\n    const [values, decodedLength] = decodeU8a(registry, new Array(types.length), u8a.subarray(offset), [types, []]);\n    for (let i = 0, count = values.length; i < count; i += 2) {\n        output.set(values[i], values[i + 1]);\n    }\n    return [KeyClass, ValClass, output, offset + decodedLength];\n}\n/** @internal */\nfunction decodeMapFromMap(registry, KeyClass, ValClass, value) {\n    const output = new Map();\n    for (const [key, val] of value.entries()) {\n        const isComplex = KeyClass.prototype instanceof AbstractArray ||\n            KeyClass.prototype instanceof Struct ||\n            KeyClass.prototype instanceof Enum;\n        try {\n            output.set(key instanceof KeyClass\n                ? key\n                : new KeyClass(registry, isComplex && typeof key === 'string' ? JSON.parse(key) : key), val instanceof ValClass\n                ? val\n                : new ValClass(registry, val));\n        }\n        catch (error) {\n            l.error('Failed to decode key or value:', error.message);\n            throw error;\n        }\n    }\n    return [KeyClass, ValClass, output, 0];\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param KeyClass - Type of the map key\n * @param ValClass - Type of the map value\n * @param value - Value to decode, one of:\n * - null\n * - undefined\n * - hex\n * - Uint8Array\n * - Map<any, any>, where both key and value types are either\n *   constructors or decodeable values for their types.\n * @param jsonMap\n * @internal\n */\nfunction decodeMap(registry, keyType, valType, value) {\n    const KeyClass = typeToConstructor(registry, keyType);\n    const ValClass = typeToConstructor(registry, valType);\n    if (!value) {\n        return [KeyClass, ValClass, new Map(), 0];\n    }\n    else if (isU8a(value) || isHex(value)) {\n        return decodeMapFromU8a(registry, KeyClass, ValClass, u8aToU8a(value));\n    }\n    else if (value instanceof Map) {\n        return decodeMapFromMap(registry, KeyClass, ValClass, value);\n    }\n    else if (isObject(value)) {\n        return decodeMapFromMap(registry, KeyClass, ValClass, new Map(Object.entries(value)));\n    }\n    throw new Error('Map: cannot decode type');\n}\nexport class CodecMap extends Map {\n    registry;\n    createdAtHash;\n    initialU8aLength;\n    isStorageFallback;\n    #KeyClass;\n    #ValClass;\n    #type;\n    constructor(registry, keyType, valType, rawValue, type = 'HashMap') {\n        const [KeyClass, ValClass, decoded, decodedLength] = decodeMap(registry, keyType, valType, rawValue);\n        super(type === 'BTreeMap' ? sortMap(decoded) : decoded);\n        this.registry = registry;\n        this.initialU8aLength = decodedLength;\n        this.#KeyClass = KeyClass;\n        this.#ValClass = ValClass;\n        this.#type = type;\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        let len = compactToU8a(this.size).length;\n        for (const [k, v] of this.entries()) {\n            len += k.encodedLength + v.encodedLength;\n        }\n        return len;\n    }\n    /**\n     * @description Returns a hash of the value\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Checks if the value is an empty value\n     */\n    get isEmpty() {\n        return this.size === 0;\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        return compareMap(this, other);\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        const inner = [];\n        for (const [k, v] of this.entries()) {\n            inner.push(k.inspect());\n            inner.push(v.inspect());\n        }\n        return {\n            inner,\n            outer: [compactToU8a(this.size)]\n        };\n    }\n    /**\n     * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation\n     */\n    toHex() {\n        return u8aToHex(this.toU8a());\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman(isExtended, disableAscii) {\n        const json = {};\n        for (const [k, v] of this.entries()) {\n            json[k instanceof Raw && !disableAscii && k.isAscii\n                ? k.toUtf8()\n                : k.toString()] = v.toHuman(isExtended, disableAscii);\n        }\n        return json;\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        const json = {};\n        for (const [k, v] of this.entries()) {\n            json[k.toString()] = v.toJSON();\n        }\n        return json;\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive(disableAscii) {\n        const json = {};\n        for (const [k, v] of this.entries()) {\n            json[k instanceof Raw && !disableAscii && k.isAscii\n                ? k.toUtf8()\n                : k.toString()] = v.toPrimitive(disableAscii);\n        }\n        return json;\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return `${this.#type}<${this.registry.getClassName(this.#KeyClass) || new this.#KeyClass(this.registry).toRawType()},${this.registry.getClassName(this.#ValClass) || new this.#ValClass(this.registry).toRawType()}>`;\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        return stringify(this.toJSON());\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        const encoded = [];\n        if (!isBare) {\n            encoded.push(compactToU8a(this.size));\n        }\n        for (const [k, v] of this.entries()) {\n            encoded.push(k.toU8a(isBare), v.toU8a(isBare));\n        }\n        return u8aConcatStrict(encoded);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2252, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/extended/BTreeMap.js"],"sourcesContent":["import { CodecMap } from './Map.js';\nexport class BTreeMap extends CodecMap {\n    static with(keyType, valType) {\n        return class extends BTreeMap {\n            constructor(registry, value) {\n                super(registry, keyType, valType, value, 'BTreeMap');\n            }\n        };\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;AACO,MAAM,iBAAiB,2KAAQ;IAClC,OAAO,KAAK,OAAO,EAAE,OAAO,EAAE;QAC1B,OAAO,cAAc;YACjB,YAAY,QAAQ,EAAE,KAAK,CAAE;gBACzB,KAAK,CAAC,UAAU,SAAS,SAAS,OAAO;YAC7C;QACJ;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2271, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/utils/compareSet.js"],"sourcesContent":["import { isObject } from '@polkadot/util';\nfunction compareSetArray(a, b) {\n    // equal number of entries and each entry in the array should match\n    return (a.size === b.length) && !b.some((e) => !a.has(e));\n}\nexport function compareSet(a, b) {\n    if (Array.isArray(b)) {\n        return compareSetArray(a, b);\n    }\n    else if (b instanceof Set) {\n        return compareSetArray(a, [...b.values()]);\n    }\n    else if (isObject(b)) {\n        return compareSetArray(a, Object.values(b));\n    }\n    return false;\n}\n"],"names":[],"mappings":";;;;AAAA;;AACA,SAAS,gBAAgB,CAAC,EAAE,CAAC;IACzB,mEAAmE;IACnE,OAAO,AAAC,EAAE,IAAI,KAAK,EAAE,MAAM,IAAK,CAAC,EAAE,IAAI,CAAC,CAAC,IAAM,CAAC,EAAE,GAAG,CAAC;AAC1D;AACO,SAAS,WAAW,CAAC,EAAE,CAAC;IAC3B,IAAI,MAAM,OAAO,CAAC,IAAI;QAClB,OAAO,gBAAgB,GAAG;IAC9B,OACK,IAAI,aAAa,KAAK;QACvB,OAAO,gBAAgB,GAAG;eAAI,EAAE,MAAM;SAAG;IAC7C,OACK,IAAI,IAAA,8JAAQ,EAAC,IAAI;QAClB,OAAO,gBAAgB,GAAG,OAAO,MAAM,CAAC;IAC5C;IACA,OAAO;AACX","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2297, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/extended/BTreeSet.js"],"sourcesContent":["import { compactFromU8aLim, compactToU8a, isHex, isU8a, logger, stringify, u8aConcatStrict, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { compareSet, decodeU8aVec, sortSet, typeToConstructor } from '../utils/index.js';\nconst l = logger('BTreeSet');\n/** @internal */\nfunction decodeSetFromU8a(registry, ValClass, u8a) {\n    const output = new Set();\n    const [offset, count] = compactFromU8aLim(u8a);\n    const result = new Array(count);\n    const [decodedLength] = decodeU8aVec(registry, result, u8a, offset, ValClass);\n    for (let i = 0; i < count; i++) {\n        output.add(result[i]);\n    }\n    return [ValClass, output, decodedLength];\n}\n/** @internal */\nfunction decodeSetFromSet(registry, ValClass, value) {\n    const output = new Set();\n    value.forEach((val) => {\n        try {\n            output.add((val instanceof ValClass) ? val : new ValClass(registry, val));\n        }\n        catch (error) {\n            l.error('Failed to decode key or value:', error.message);\n            throw error;\n        }\n    });\n    return [ValClass, output, 0];\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param ValClass - Type of the map value\n * @param value - Value to decode, one of:\n * - null\n * - undefined\n * - hex\n * - Uint8Array\n * - Set<any>, where both key and value types are either\n *   constructors or decodeable values for their types.\n * @param jsonSet\n * @internal\n */\nfunction decodeSet(registry, valType, value) {\n    const ValClass = typeToConstructor(registry, valType);\n    if (!value) {\n        return [ValClass, new Set(), 0];\n    }\n    else if (isU8a(value) || isHex(value)) {\n        return decodeSetFromU8a(registry, ValClass, u8aToU8a(value));\n    }\n    else if (Array.isArray(value) || value instanceof Set) {\n        return decodeSetFromSet(registry, ValClass, value);\n    }\n    throw new Error('BTreeSet: cannot decode type');\n}\nexport class BTreeSet extends Set {\n    registry;\n    createdAtHash;\n    initialU8aLength;\n    isStorageFallback;\n    #ValClass;\n    constructor(registry, valType, rawValue) {\n        const [ValClass, values, decodedLength] = decodeSet(registry, valType, rawValue);\n        super(sortSet(values));\n        this.registry = registry;\n        this.initialU8aLength = decodedLength;\n        this.#ValClass = ValClass;\n    }\n    static with(valType) {\n        return class extends BTreeSet {\n            constructor(registry, value) {\n                super(registry, valType, value);\n            }\n        };\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        let len = compactToU8a(this.size).length;\n        for (const v of this.values()) {\n            len += v.encodedLength;\n        }\n        return len;\n    }\n    /**\n     * @description Returns a hash of the value\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Checks if the value is an empty value\n     */\n    get isEmpty() {\n        return this.size === 0;\n    }\n    /**\n     * @description The actual set values as a string[]\n     */\n    get strings() {\n        return [...super.values()].map((v) => v.toString());\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        return compareSet(this, other);\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        const inner = [];\n        for (const v of this.values()) {\n            inner.push(v.inspect());\n        }\n        return {\n            inner,\n            outer: [compactToU8a(this.size)]\n        };\n    }\n    /**\n     * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation\n     */\n    toHex() {\n        return u8aToHex(this.toU8a());\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman(isExtended, disableAscii) {\n        const json = [];\n        for (const v of this.values()) {\n            json.push(v.toHuman(isExtended, disableAscii));\n        }\n        return json;\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        const json = [];\n        for (const v of this.values()) {\n            json.push(v.toJSON());\n        }\n        return json;\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return `BTreeSet<${this.registry.getClassName(this.#ValClass) || new this.#ValClass(this.registry).toRawType()}>`;\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive(disableAscii) {\n        const json = [];\n        for (const v of this.values()) {\n            json.push(v.toPrimitive(disableAscii));\n        }\n        return json;\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        return stringify(this.toJSON());\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        const encoded = [];\n        if (!isBare) {\n            encoded.push(compactToU8a(this.size));\n        }\n        for (const v of this.values()) {\n            encoded.push(v.toU8a(isBare));\n        }\n        return u8aConcatStrict(encoded);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2500, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/extended/Bytes.js"],"sourcesContent":["import { compactAddLength, compactFromU8aLim, compactToU8a, isString, isU8a, u8aToU8a } from '@polkadot/util';\nimport { Raw } from '../native/Raw.js';\nconst MAX_LENGTH = 10 * 1024 * 1024;\n/** @internal */\nfunction decodeBytesU8a(value) {\n    if (!value.length) {\n        return [new Uint8Array(), 0];\n    }\n    // handle all other Uint8Array inputs, these do have a length prefix\n    const [offset, length] = compactFromU8aLim(value);\n    const total = offset + length;\n    if (length > MAX_LENGTH) {\n        throw new Error(`Bytes length ${length.toString()} exceeds ${MAX_LENGTH}`);\n    }\n    else if (total > value.length) {\n        throw new Error(`Bytes: required length less than remainder, expected at least ${total}, found ${value.length}`);\n    }\n    return [value.subarray(offset, total), total];\n}\n/**\n * @name Bytes\n * @description\n * A Bytes wrapper for Vec<u8>. The significant difference between this and a normal Uint8Array\n * is that this version allows for length-encoding. (i.e. it is a variable-item codec, the same\n * as what is found in [[Text]] and [[Vec]])\n */\nexport class Bytes extends Raw {\n    constructor(registry, value) {\n        const [u8a, decodedLength] = isU8a(value) && !(value instanceof Raw)\n            ? decodeBytesU8a(value)\n            : Array.isArray(value) || isString(value)\n                ? [u8aToU8a(value), 0]\n                : [value, 0];\n        super(registry, u8a, decodedLength);\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        return this.length + compactToU8a(this.length).length;\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect(isBare) {\n        const clength = compactToU8a(this.length);\n        return {\n            outer: isBare\n                ? [super.toU8a()]\n                : this.length\n                    ? [clength, super.toU8a()]\n                    : [clength]\n        };\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'Bytes';\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        return isBare\n            ? super.toU8a(isBare)\n            : compactAddLength(this);\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AACA,MAAM,aAAa,KAAK,OAAO;AAC/B,cAAc,GACd,SAAS,eAAe,KAAK;IACzB,IAAI,CAAC,MAAM,MAAM,EAAE;QACf,OAAO;YAAC,IAAI;YAAc;SAAE;IAChC;IACA,oEAAoE;IACpE,MAAM,CAAC,QAAQ,OAAO,GAAG,IAAA,6KAAiB,EAAC;IAC3C,MAAM,QAAQ,SAAS;IACvB,IAAI,SAAS,YAAY;QACrB,MAAM,IAAI,MAAM,CAAC,aAAa,EAAE,OAAO,QAAQ,GAAG,SAAS,EAAE,YAAY;IAC7E,OACK,IAAI,QAAQ,MAAM,MAAM,EAAE;QAC3B,MAAM,IAAI,MAAM,CAAC,8DAA8D,EAAE,MAAM,QAAQ,EAAE,MAAM,MAAM,EAAE;IACnH;IACA,OAAO;QAAC,MAAM,QAAQ,CAAC,QAAQ;QAAQ;KAAM;AACjD;AAQO,MAAM,cAAc,oKAAG;IAC1B,YAAY,QAAQ,EAAE,KAAK,CAAE;QACzB,MAAM,CAAC,KAAK,cAAc,GAAG,IAAA,wJAAK,EAAC,UAAU,CAAC,CAAC,iBAAiB,oKAAG,IAC7D,eAAe,SACf,MAAM,OAAO,CAAC,UAAU,IAAA,8JAAQ,EAAC,SAC7B;YAAC,IAAA,8JAAQ,EAAC;YAAQ;SAAE,GACpB;YAAC;YAAO;SAAE;QACpB,KAAK,CAAC,UAAU,KAAK;IACzB;IACA;;KAEC,GACD,IAAI,gBAAgB;QAChB,OAAO,IAAI,CAAC,MAAM,GAAG,IAAA,sKAAY,EAAC,IAAI,CAAC,MAAM,EAAE,MAAM;IACzD;IACA;;KAEC,GACD,QAAQ,MAAM,EAAE;QACZ,MAAM,UAAU,IAAA,sKAAY,EAAC,IAAI,CAAC,MAAM;QACxC,OAAO;YACH,OAAO,SACD;gBAAC,KAAK,CAAC;aAAQ,GACf,IAAI,CAAC,MAAM,GACP;gBAAC;gBAAS,KAAK,CAAC;aAAQ,GACxB;gBAAC;aAAQ;QACvB;IACJ;IACA;;KAEC,GACD,YAAY;QACR,OAAO;IACX;IACA;;;KAGC,GACD,MAAM,MAAM,EAAE;QACV,OAAO,SACD,KAAK,CAAC,MAAM,UACZ,IAAA,8KAAgB,EAAC,IAAI;IAC/B;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2581, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/native/Set.js"],"sourcesContent":["import { BN, bnToBn, bnToU8a, isBn, isNumber, isString, isU8a, isUndefined, objectProperties, stringify, stringPascalCase, u8aToBn, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { compareArray } from '../utils/index.js';\nfunction encodeSet(setValues, values) {\n    const encoded = new BN(0);\n    for (let i = 0, count = values.length; i < count; i++) {\n        encoded.ior(bnToBn(setValues[values[i]] || 0));\n    }\n    return encoded;\n}\n/** @internal */\nfunction decodeSetArray(setValues, values) {\n    const count = values.length;\n    const result = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const key = values[i];\n        if (isUndefined(setValues[key])) {\n            throw new Error(`Set: Invalid key '${key}' passed to Set, allowed ${Object.keys(setValues).join(', ')}`);\n        }\n        result[i] = key;\n    }\n    return result;\n}\n/** @internal */\nfunction decodeSetNumber(setValues, _value) {\n    const bn = bnToBn(_value);\n    const keys = Object.keys(setValues);\n    const result = [];\n    for (let i = 0, count = keys.length; i < count; i++) {\n        const key = keys[i];\n        if (bn.and(bnToBn(setValues[key])).eq(bnToBn(setValues[key]))) {\n            result.push(key);\n        }\n    }\n    const computed = encodeSet(setValues, result);\n    if (!bn.eq(computed)) {\n        throw new Error(`Set: Mismatch decoding '${bn.toString()}', computed as '${computed.toString()}' with ${result.join(', ')}`);\n    }\n    return result;\n}\n/** @internal */\nfunction decodeSet(setValues, value = 0, bitLength) {\n    if (bitLength % 8 !== 0) {\n        throw new Error(`Expected valid bitLength, power of 8, found ${bitLength}`);\n    }\n    const byteLength = bitLength / 8;\n    if (isU8a(value)) {\n        return value.length === 0\n            ? []\n            : decodeSetNumber(setValues, u8aToBn(value.subarray(0, byteLength), { isLe: true }));\n    }\n    else if (isString(value)) {\n        return decodeSet(setValues, u8aToU8a(value), byteLength);\n    }\n    else if (value instanceof Set || Array.isArray(value)) {\n        const input = Array.isArray(value)\n            ? value\n            : [...value.values()];\n        return decodeSetArray(setValues, input);\n    }\n    return decodeSetNumber(setValues, value);\n}\n/**\n * @name Set\n * @description\n * An Set is an array of string values, represented an an encoded type by\n * a bitwise representation of the values.\n */\nexport class CodecSet extends Set {\n    registry;\n    createdAtHash;\n    initialU8aLength;\n    isStorageFallback;\n    #allowed;\n    #byteLength;\n    constructor(registry, setValues, value, bitLength = 8) {\n        super(decodeSet(setValues, value, bitLength));\n        this.registry = registry;\n        this.#allowed = setValues;\n        this.#byteLength = bitLength / 8;\n    }\n    static with(values, bitLength) {\n        return class extends CodecSet {\n            static {\n                const keys = Object.keys(values);\n                const count = keys.length;\n                const isKeys = new Array(count);\n                for (let i = 0; i < count; i++) {\n                    isKeys[i] = `is${stringPascalCase(keys[i])}`;\n                }\n                objectProperties(this.prototype, isKeys, (_, i, self) => self.strings.includes(keys[i]));\n            }\n            constructor(registry, value) {\n                super(registry, values, value, bitLength);\n            }\n        };\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        return this.#byteLength;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description true is the Set contains no values\n     */\n    get isEmpty() {\n        return this.size === 0;\n    }\n    /**\n     * @description The actual set values as a string[]\n     */\n    get strings() {\n        return [...super.values()];\n    }\n    /**\n     * @description The encoded value for the set members\n     */\n    get valueEncoded() {\n        return encodeSet(this.#allowed, this.strings);\n    }\n    /**\n     * @description adds a value to the Set (extended to allow for validity checking)\n     */\n    add = (key) => {\n        // ^^^ add = () property done to assign this instance's this, otherwise Set.add creates \"some\" chaos\n        // we have the isUndefined(this._setValues) in here as well, add is used internally\n        // in the Set constructor (so it is undefined at this point, and should allow)\n        if (this.#allowed && isUndefined(this.#allowed[key])) {\n            throw new Error(`Set: Invalid key '${key}' on add`);\n        }\n        super.add(key);\n        return this;\n    };\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        if (Array.isArray(other)) {\n            // we don't actually care about the order, sort the values\n            return compareArray(this.strings.sort(), other.sort());\n        }\n        else if (other instanceof Set) {\n            return this.eq([...other.values()]);\n        }\n        else if (isNumber(other) || isBn(other)) {\n            return this.valueEncoded.eq(bnToBn(other));\n        }\n        return false;\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return {\n            outer: [this.toU8a()]\n        };\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n    toHex() {\n        return u8aToHex(this.toU8a());\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman() {\n        return this.toJSON();\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        return this.strings;\n    }\n    /**\n     * @description The encoded value for the set members\n     */\n    toNumber() {\n        return this.valueEncoded.toNumber();\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive() {\n        return this.toJSON();\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return stringify({ _set: this.#allowed });\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        return `[${this.strings.join(', ')}]`;\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     */\n    toU8a(_isBare) {\n        return bnToU8a(this.valueEncoded, {\n            bitLength: this.#byteLength * 8,\n            isLe: true\n        });\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2798, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/base/Compact.js"],"sourcesContent":["import { compactFromU8a, compactFromU8aLim, compactToU8a, identity, isU8a } from '@polkadot/util';\nimport { typeToConstructor } from '../utils/index.js';\nfunction decodeCompact(registry, Type, value) {\n    if (isU8a(value)) {\n        const [decodedLength, bn] = (value[0] & 0b11) < 0b11\n            ? compactFromU8aLim(value)\n            : compactFromU8a(value);\n        return [new Type(registry, bn), decodedLength];\n    }\n    else if (value instanceof Compact) {\n        const raw = value.unwrap();\n        return raw instanceof Type\n            ? [raw, 0]\n            : [new Type(registry, raw), 0];\n    }\n    else if (value instanceof Type) {\n        return [value, 0];\n    }\n    return [new Type(registry, value), 0];\n}\n/**\n * @name Compact\n * @description\n * A compact length-encoding codec wrapper. It performs the same function as Length, however\n * differs in that it uses a variable number of bytes to do the actual encoding. This is mostly\n * used by other types to add length-prefixed encoding, or in the case of wrapped types, taking\n * a number and making the compact representation thereof\n */\nexport class Compact {\n    registry;\n    createdAtHash;\n    initialU8aLength;\n    isStorageFallback;\n    #Type;\n    #raw;\n    constructor(registry, Type, value = 0, { definition, setDefinition = identity } = {}) {\n        this.registry = registry;\n        this.#Type = definition || setDefinition(typeToConstructor(registry, Type));\n        const [raw, decodedLength] = decodeCompact(registry, this.#Type, value);\n        this.initialU8aLength = decodedLength;\n        this.#raw = raw;\n    }\n    static with(Type) {\n        let definition;\n        // eslint-disable-next-line no-return-assign\n        const setDefinition = (d) => (definition = d);\n        return class extends Compact {\n            constructor(registry, value) {\n                super(registry, Type, value, { definition, setDefinition });\n            }\n        };\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        return this.toU8a().length;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Checks if the value is an empty value\n     */\n    get isEmpty() {\n        return this.#raw.isEmpty;\n    }\n    /**\n     * @description Returns the number of bits in the value\n     */\n    bitLength() {\n        return this.#raw.bitLength();\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        return this.#raw.eq(other instanceof Compact\n            ? other.#raw\n            : other);\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return {\n            outer: [this.toU8a()]\n        };\n    }\n    /**\n     * @description Returns a BigInt representation of the number\n     */\n    toBigInt() {\n        return this.#raw.toBigInt();\n    }\n    /**\n     * @description Returns the BN representation of the number\n     */\n    toBn() {\n        return this.#raw.toBn();\n    }\n    /**\n     * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation\n     */\n    toHex(isLe) {\n        return this.#raw.toHex(isLe);\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman(isExtended, disableAscii) {\n        return this.#raw.toHuman(isExtended, disableAscii);\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        return this.#raw.toJSON();\n    }\n    /**\n     * @description Returns the number representation for the value\n     */\n    toNumber() {\n        return this.#raw.toNumber();\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive(disableAscii) {\n        return this.#raw.toPrimitive(disableAscii);\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return `Compact<${this.registry.getClassName(this.#Type) || this.#raw.toRawType()}>`;\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        return this.#raw.toString();\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     */\n    toU8a(_isBare) {\n        return compactToU8a(this.#raw.toBn());\n    }\n    /**\n     * @description Returns the embedded [[UInt]] or [[Moment]] value\n     */\n    unwrap() {\n        return this.#raw;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2957, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/extended/HashMap.js"],"sourcesContent":["import { CodecMap } from './Map.js';\nexport class HashMap extends CodecMap {\n    static with(keyType, valType) {\n        return class extends HashMap {\n            constructor(registry, value) {\n                super(registry, keyType, valType, value);\n            }\n        };\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;AACO,MAAM,gBAAgB,2KAAQ;IACjC,OAAO,KAAK,OAAO,EAAE,OAAO,EAAE;QAC1B,OAAO,cAAc;YACjB,YAAY,QAAQ,EAAE,KAAK,CAAE;gBACzB,KAAK,CAAC,UAAU,SAAS,SAAS;YACtC;QACJ;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2976, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/base/Int.js"],"sourcesContent":["import { AbstractInt } from '../abstract/Int.js';\n/**\n * @name Int\n * @description\n * A generic signed integer codec. For Substrate all numbers are Little Endian encoded,\n * this handles the encoding and decoding of those numbers. Upon construction\n * the bitLength is provided and any additional use keeps the number to this\n * length. This extends `BN`, so all methods available on a normal `BN` object\n * is available here.\n * @noInheritDoc\n */\nexport class Int extends AbstractInt {\n    constructor(registry, value = 0, bitLength) {\n        super(registry, value, bitLength, true);\n    }\n    static with(bitLength, typeName) {\n        return class extends Int {\n            constructor(registry, value) {\n                super(registry, value, bitLength);\n            }\n            toRawType() {\n                return typeName || super.toRawType();\n            }\n        };\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;AAWO,MAAM,YAAY,8KAAW;IAChC,YAAY,QAAQ,EAAE,QAAQ,CAAC,EAAE,SAAS,CAAE;QACxC,KAAK,CAAC,UAAU,OAAO,WAAW;IACtC;IACA,OAAO,KAAK,SAAS,EAAE,QAAQ,EAAE;QAC7B,OAAO,cAAc;YACjB,YAAY,QAAQ,EAAE,KAAK,CAAE;gBACzB,KAAK,CAAC,UAAU,OAAO;YAC3B;YACA,YAAY;gBACR,OAAO,YAAY,KAAK,CAAC;YAC7B;QACJ;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3001, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/base/Option.js"],"sourcesContent":["import { identity, isCodec, isNull, isU8a, isUndefined, u8aToHex } from '@polkadot/util';\nimport { typeToConstructor } from '../utils/index.js';\nimport { Null } from './Null.js';\nclass None extends Null {\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'None';\n    }\n}\n/** @internal */\nfunction decodeOption(registry, Type, value) {\n    if (value instanceof Type) {\n        // don't re-create, use as it (which also caters for derived types)\n        return value;\n    }\n    else if (value instanceof Option) {\n        if (value.value instanceof Type) {\n            // same instance, return it\n            return value.value;\n        }\n        else if (value.isNone) {\n            // internal is None, we are also none\n            return new None(registry);\n        }\n        // convert the actual value into known\n        return new Type(registry, value.value);\n    }\n    else if (isNull(value) || isUndefined(value) || value === '0x' || value instanceof None) {\n        // anything empty we pass as-is\n        return new None(registry);\n    }\n    else if (isU8a(value)) {\n        // the isU8a check happens last in the if-tree - since the wrapped value\n        // may be an instance of it, so Type and Option checks go in first\n        return !value.length || value[0] === 0\n            ? new None(registry)\n            : new Type(registry, value.subarray(1));\n    }\n    return new Type(registry, value);\n}\n/**\n * @name Option\n * @description\n * An Option is an optional field. Basically the first byte indicates that there is\n * is value to follow. If the byte is `1` there is an actual value. So the Option\n * implements that - decodes, checks for optionality and wraps the required structure\n * with a value if/as required/found.\n */\nexport class Option {\n    registry;\n    createdAtHash;\n    initialU8aLength;\n    isStorageFallback;\n    #Type;\n    #raw;\n    constructor(registry, typeName, value, { definition, setDefinition = identity } = {}) {\n        const Type = definition || setDefinition(typeToConstructor(registry, typeName));\n        const decoded = isU8a(value) && value.length && !isCodec(value)\n            ? value[0] === 0\n                ? new None(registry)\n                : new Type(registry, value.subarray(1))\n            : decodeOption(registry, Type, value);\n        this.registry = registry;\n        this.#Type = Type;\n        this.#raw = decoded;\n        if (decoded?.initialU8aLength) {\n            this.initialU8aLength = 1 + decoded.initialU8aLength;\n        }\n    }\n    static with(Type) {\n        let definition;\n        const setDefinition = (d) => {\n            definition = d;\n            return d;\n        };\n        return class extends Option {\n            constructor(registry, value) {\n                super(registry, Type, value, { definition, setDefinition });\n            }\n        };\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        // boolean byte (has value, doesn't have) along with wrapped length\n        return 1 + this.#raw.encodedLength;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Checks if the Option has no value\n     */\n    get isEmpty() {\n        return this.isNone;\n    }\n    /**\n     * @description Checks if the Option has no value\n     */\n    get isNone() {\n        return this.#raw instanceof None;\n    }\n    /**\n     * @description Checks if the Option has a value\n     */\n    get isSome() {\n        return !this.isNone;\n    }\n    /**\n     * @description The actual value for the Option\n     */\n    get value() {\n        return this.#raw;\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        if (other instanceof Option) {\n            return (this.isSome === other.isSome) && this.value.eq(other.value);\n        }\n        return this.value.eq(other);\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        if (this.isNone) {\n            return { outer: [new Uint8Array([0])] };\n        }\n        const { inner, outer = [] } = this.#raw.inspect();\n        return {\n            inner,\n            outer: [new Uint8Array([1]), ...outer]\n        };\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n    toHex() {\n        // This attempts to align with the JSON encoding - actually in this case\n        // the isSome value is correct, however the `isNone` may be problematic\n        return this.isNone\n            ? '0x'\n            : u8aToHex(this.toU8a().subarray(1));\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman(isExtended, disableAscii) {\n        return this.#raw.toHuman(isExtended, disableAscii);\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        return this.isNone\n            ? null\n            : this.#raw.toJSON();\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive(disableAscii) {\n        return this.isNone\n            ? null\n            : this.#raw.toPrimitive(disableAscii);\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType(isBare) {\n        const wrapped = this.registry.getClassName(this.#Type) || new this.#Type(this.registry).toRawType();\n        return isBare\n            ? wrapped\n            : `Option<${wrapped}>`;\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        return this.#raw.toString();\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        if (isBare) {\n            return this.#raw.toU8a(true);\n        }\n        const u8a = new Uint8Array(this.encodedLength);\n        if (this.isSome) {\n            u8a.set([1]);\n            u8a.set(this.#raw.toU8a(), 1);\n        }\n        return u8a;\n    }\n    /**\n     * @description Returns the value that the Option represents (if available), throws if null\n     */\n    unwrap() {\n        if (this.isNone) {\n            throw new Error('Option: unwrapping a None value');\n        }\n        return this.#raw;\n    }\n    /**\n     * @description Returns the value that the Option represents (if available) or defaultValue if none\n     * @param defaultValue The value to return if the option isNone\n     */\n    unwrapOr(defaultValue) {\n        return this.isSome\n            ? this.unwrap()\n            : defaultValue;\n    }\n    /**\n     * @description Returns the value that the Option represents (if available) or defaultValue if none\n     * @param defaultValue The value to return if the option isNone\n     */\n    unwrapOrDefault() {\n        return this.isSome\n            ? this.unwrap()\n            : new this.#Type(this.registry);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3215, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/base/Tuple.js"],"sourcesContent":["import { identity, isFunction, isHex, isString, isU8a, stringify, u8aConcatStrict, u8aToU8a } from '@polkadot/util';\nimport { AbstractArray } from '../abstract/Array.js';\nimport { decodeU8a, mapToTypeMap, typesToConstructors, typeToConstructor } from '../utils/index.js';\n/** @internal */\nfunction decodeTuple(registry, result, value, Classes) {\n    if (Array.isArray(value)) {\n        const Types = Classes[0];\n        for (let i = 0, count = Types.length; i < count; i++) {\n            try {\n                const entry = value?.[i];\n                result[i] = entry instanceof Types[i]\n                    ? entry\n                    : new Types[i](registry, entry);\n            }\n            catch (error) {\n                throw new Error(`Tuple: failed on ${i}:: ${error.message}`);\n            }\n        }\n        return [result, 0];\n    }\n    else if (isHex(value)) {\n        return decodeU8a(registry, result, u8aToU8a(value), Classes);\n    }\n    else if (!value || !result.length) {\n        const Types = Classes[0];\n        for (let i = 0, count = Types.length; i < count; i++) {\n            result[i] = new Types[i](registry);\n        }\n        return [result, 0];\n    }\n    throw new Error(`Expected array input to Tuple decoding, found ${typeof value}: ${stringify(value)}`);\n}\n/**\n * @name Tuple\n * @description\n * A Tuple defines an anonymous fixed-length array, where each element has its\n * own type. It extends the base JS `Array` object.\n */\nexport class Tuple extends AbstractArray {\n    #Types;\n    constructor(registry, Types, value, { definition, setDefinition = identity } = {}) {\n        const Classes = definition || setDefinition(Array.isArray(Types)\n            ? [typesToConstructors(registry, Types), []]\n            : isFunction(Types) || isString(Types)\n                ? [[typeToConstructor(registry, Types)], []]\n                : mapToTypeMap(registry, Types));\n        super(registry, Classes[0].length);\n        this.initialU8aLength = (isU8a(value)\n            ? decodeU8a(registry, this, value, Classes)\n            : decodeTuple(registry, this, value, Classes))[1];\n        this.#Types = Classes;\n    }\n    static with(Types) {\n        let definition;\n        // eslint-disable-next-line no-return-assign\n        const setDefinition = (d) => definition = d;\n        return class extends Tuple {\n            constructor(registry, value) {\n                super(registry, Types, value, { definition, setDefinition });\n            }\n        };\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        let total = 0;\n        for (let i = 0, count = this.length; i < count; i++) {\n            total += this[i].encodedLength;\n        }\n        return total;\n    }\n    /**\n     * @description The types definition of the tuple\n     */\n    get Types() {\n        return this.#Types[1].length\n            ? this.#Types[1]\n            : this.#Types[0].map((T) => new T(this.registry).toRawType());\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return {\n            inner: this.inspectInner()\n        };\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        const types = this.#Types[0].map((T) => this.registry.getClassName(T) || new T(this.registry).toRawType());\n        return `(${types.join(',')})`;\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        // Overwrite the default toString representation of Array.\n        return stringify(this.toJSON());\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        return u8aConcatStrict(this.toU8aInner(isBare));\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3335, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/extended/Range.js"],"sourcesContent":["import { Tuple } from '../base/Tuple.js';\n/**\n * @name Range\n * @description\n * Rust `Range<T>` representation\n */\nexport class Range extends Tuple {\n    #rangeName;\n    constructor(registry, Type, value, { rangeName = 'Range' } = {}) {\n        super(registry, [Type, Type], value);\n        this.#rangeName = rangeName;\n    }\n    static with(Type) {\n        return class extends Range {\n            constructor(registry, value) {\n                super(registry, Type, value);\n            }\n        };\n    }\n    /**\n     * @description Returns the starting range value\n     */\n    get start() {\n        return this[0];\n    }\n    /**\n     * @description Returns the ending range value\n     */\n    get end() {\n        return this[1];\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return `${this.#rangeName}<${this.start.toRawType()}>`;\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;AAMO,MAAM,cAAc,sKAAK;IAC5B,CAAA,SAAU,CAAC;IACX,YAAY,QAAQ,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,YAAY,OAAO,EAAE,GAAG,CAAC,CAAC,CAAE;QAC7D,KAAK,CAAC,UAAU;YAAC;YAAM;SAAK,EAAE;QAC9B,IAAI,CAAC,CAAA,SAAU,GAAG;IACtB;IACA,OAAO,KAAK,IAAI,EAAE;QACd,OAAO,cAAc;YACjB,YAAY,QAAQ,EAAE,KAAK,CAAE;gBACzB,KAAK,CAAC,UAAU,MAAM;YAC1B;QACJ;IACJ;IACA;;KAEC,GACD,IAAI,QAAQ;QACR,OAAO,IAAI,CAAC,EAAE;IAClB;IACA;;KAEC,GACD,IAAI,MAAM;QACN,OAAO,IAAI,CAAC,EAAE;IAClB;IACA;;KAEC,GACD,YAAY;QACR,OAAO,GAAG,IAAI,CAAC,CAAA,SAAU,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,SAAS,GAAG,CAAC,CAAC;IAC1D;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3377, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/extended/RangeInclusive.js"],"sourcesContent":["import { Range } from './Range.js';\nexport class RangeInclusive extends Range {\n    constructor(registry, Type, value) {\n        super(registry, Type, value, { rangeName: 'RangeInclusive' });\n    }\n    static with(Type) {\n        return class extends RangeInclusive {\n            constructor(registry, value) {\n                super(registry, Type, value);\n            }\n        };\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;AACO,MAAM,uBAAuB,0KAAK;IACrC,YAAY,QAAQ,EAAE,IAAI,EAAE,KAAK,CAAE;QAC/B,KAAK,CAAC,UAAU,MAAM,OAAO;YAAE,WAAW;QAAiB;IAC/D;IACA,OAAO,KAAK,IAAI,EAAE;QACd,OAAO,cAAc;YACjB,YAAY,QAAQ,EAAE,KAAK,CAAE;gBACzB,KAAK,CAAC,UAAU,MAAM;YAC1B;QACJ;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3401, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/base/Result.js"],"sourcesContent":["import { Enum } from './Enum.js';\n/**\n * @name Result\n * @description\n * A Result maps to the Rust Result type, that can either wrap a success or error value\n */\nexport class Result extends Enum {\n    constructor(registry, Ok, Err, value) {\n        // NOTE This is order-dependent, Ok (with index 0) needs to be first\n        // eslint-disable-next-line sort-keys\n        super(registry, { Ok, Err }, value);\n    }\n    static with(Types) {\n        return class extends Result {\n            constructor(registry, value) {\n                super(registry, Types.Ok, Types.Err, value);\n            }\n        };\n    }\n    /**\n     * @description Returns the wrapper Err value (if isErr)\n     */\n    get asErr() {\n        if (!this.isErr) {\n            throw new Error('Cannot extract Err value from Ok result, check isErr first');\n        }\n        return this.value;\n    }\n    /**\n     * @description Returns the wrapper Ok value (if isOk)\n     */\n    get asOk() {\n        if (!this.isOk) {\n            throw new Error('Cannot extract Ok value from Err result, check isOk first');\n        }\n        return this.value;\n    }\n    /**\n     * @description Checks if the Result has no value\n     */\n    get isEmpty() {\n        return this.isOk && this.value.isEmpty;\n    }\n    /**\n     * @description Checks if the Result wraps an Err value\n     */\n    get isErr() {\n        return !this.isOk;\n    }\n    /**\n     * @description Checks if the Result wraps an Ok value\n     */\n    get isOk() {\n        return this.index === 0;\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        const Types = this._toRawStruct();\n        return `Result<${Types.Ok},${Types.Err}>`;\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;AAMO,MAAM,eAAe,oKAAI;IAC5B,YAAY,QAAQ,EAAE,EAAE,EAAE,GAAG,EAAE,KAAK,CAAE;QAClC,oEAAoE;QACpE,qCAAqC;QACrC,KAAK,CAAC,UAAU;YAAE;YAAI;QAAI,GAAG;IACjC;IACA,OAAO,KAAK,KAAK,EAAE;QACf,OAAO,cAAc;YACjB,YAAY,QAAQ,EAAE,KAAK,CAAE;gBACzB,KAAK,CAAC,UAAU,MAAM,EAAE,EAAE,MAAM,GAAG,EAAE;YACzC;QACJ;IACJ;IACA;;KAEC,GACD,IAAI,QAAQ;QACR,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;YACb,MAAM,IAAI,MAAM;QACpB;QACA,OAAO,IAAI,CAAC,KAAK;IACrB;IACA;;KAEC,GACD,IAAI,OAAO;QACP,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;YACZ,MAAM,IAAI,MAAM;QACpB;QACA,OAAO,IAAI,CAAC,KAAK;IACrB;IACA;;KAEC,GACD,IAAI,UAAU;QACV,OAAO,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO;IAC1C;IACA;;KAEC,GACD,IAAI,QAAQ;QACR,OAAO,CAAC,IAAI,CAAC,IAAI;IACrB;IACA;;KAEC,GACD,IAAI,OAAO;QACP,OAAO,IAAI,CAAC,KAAK,KAAK;IAC1B;IACA;;KAEC,GACD,YAAY;QACR,MAAM,QAAQ,IAAI,CAAC,YAAY;QAC/B,OAAO,CAAC,OAAO,EAAE,MAAM,EAAE,CAAC,CAAC,EAAE,MAAM,GAAG,CAAC,CAAC,CAAC;IAC7C;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3465, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/extended/U8aFixed.js"],"sourcesContent":["import { isU8a, u8aToU8a } from '@polkadot/util';\nimport { Raw } from '../native/Raw.js';\n/** @internal */\nfunction decodeU8aFixed(value, bitLength) {\n    const u8a = u8aToU8a(value);\n    const byteLength = bitLength / 8;\n    if (!u8a.length) {\n        return [new Uint8Array(byteLength), 0];\n    }\n    if (isU8a(value) ? u8a.length < byteLength : u8a.length !== byteLength) {\n        throw new Error(`Expected input with ${byteLength} bytes (${bitLength} bits), found ${u8a.length} bytes`);\n    }\n    return [u8a.subarray(0, byteLength), byteLength];\n}\n/**\n * @name U8aFixed\n * @description\n * A U8a that manages a a sequence of bytes up to the specified bitLength. Not meant\n * to be used directly, rather is should be subclassed with the specific lengths.\n */\nexport class U8aFixed extends Raw {\n    constructor(registry, value = new Uint8Array(), bitLength = 256) {\n        const [u8a, decodedLength] = decodeU8aFixed(value, bitLength);\n        super(registry, u8a, decodedLength);\n    }\n    static with(bitLength, typeName) {\n        return class extends U8aFixed {\n            constructor(registry, value) {\n                super(registry, value, bitLength);\n            }\n            toRawType() {\n                return typeName || super.toRawType();\n            }\n        };\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return `[u8;${this.length}]`;\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;;;AACA,cAAc,GACd,SAAS,eAAe,KAAK,EAAE,SAAS;IACpC,MAAM,MAAM,IAAA,8JAAQ,EAAC;IACrB,MAAM,aAAa,YAAY;IAC/B,IAAI,CAAC,IAAI,MAAM,EAAE;QACb,OAAO;YAAC,IAAI,WAAW;YAAa;SAAE;IAC1C;IACA,IAAI,IAAA,wJAAK,EAAC,SAAS,IAAI,MAAM,GAAG,aAAa,IAAI,MAAM,KAAK,YAAY;QACpE,MAAM,IAAI,MAAM,CAAC,oBAAoB,EAAE,WAAW,QAAQ,EAAE,UAAU,cAAc,EAAE,IAAI,MAAM,CAAC,MAAM,CAAC;IAC5G;IACA,OAAO;QAAC,IAAI,QAAQ,CAAC,GAAG;QAAa;KAAW;AACpD;AAOO,MAAM,iBAAiB,oKAAG;IAC7B,YAAY,QAAQ,EAAE,QAAQ,IAAI,YAAY,EAAE,YAAY,GAAG,CAAE;QAC7D,MAAM,CAAC,KAAK,cAAc,GAAG,eAAe,OAAO;QACnD,KAAK,CAAC,UAAU,KAAK;IACzB;IACA,OAAO,KAAK,SAAS,EAAE,QAAQ,EAAE;QAC7B,OAAO,cAAc;YACjB,YAAY,QAAQ,EAAE,KAAK,CAAE;gBACzB,KAAK,CAAC,UAAU,OAAO;YAC3B;YACA,YAAY;gBACR,OAAO,YAAY,KAAK,CAAC;YAC7B;QACJ;IACJ;IACA;;KAEC,GACD,YAAY;QACR,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;IAChC;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3516, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/base/Vec.js"],"sourcesContent":["import { compactFromU8aLim, identity, isHex, isU8a, logger, stringify, u8aToU8a } from '@polkadot/util';\nimport { AbstractArray } from '../abstract/Array.js';\nimport { decodeU8aVec, typeToConstructor } from '../utils/index.js';\nconst MAX_LENGTH = 512 * 1024;\nconst l = logger('Vec');\nfunction decodeVecLength(value) {\n    if (Array.isArray(value)) {\n        return [value, value.length, 0];\n    }\n    else if (isU8a(value) || isHex(value)) {\n        const u8a = u8aToU8a(value);\n        const [startAt, length] = compactFromU8aLim(u8a);\n        if (length > MAX_LENGTH) {\n            throw new Error(`Vec length ${length.toString()} exceeds ${MAX_LENGTH}`);\n        }\n        return [u8a, length, startAt];\n    }\n    else if (!value) {\n        return [null, 0, 0];\n    }\n    throw new Error(`Expected array/hex input to Vec<*> decoding, found ${typeof value}: ${stringify(value)}`);\n}\nexport function decodeVec(registry, result, value, startAt, Type) {\n    if (Array.isArray(value)) {\n        const count = result.length;\n        for (let i = 0; i < count; i++) {\n            // 26/08/2022 this is actually a false positive - after recent eslint upgdates\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const entry = value[i];\n            try {\n                result[i] = entry instanceof Type\n                    ? entry\n                    : new Type(registry, entry);\n            }\n            catch (error) {\n                l.error(`Unable to decode on index ${i}`, error.message);\n                throw error;\n            }\n        }\n        return [0, 0];\n    }\n    else if (!value) {\n        return [0, 0];\n    }\n    // we don't need more checks, we already limited it via the length decoding\n    return decodeU8aVec(registry, result, u8aToU8a(value), startAt, Type);\n}\n/**\n * @name Vec\n * @description\n * This manages codec arrays. Internally it keeps track of the length (as decoded) and allows\n * construction with the passed `Type` in the constructor. It is an extension to Array, providing\n * specific encoding/decoding on top of the base type.\n */\nexport class Vec extends AbstractArray {\n    #Type;\n    constructor(registry, Type, value = [], { definition, setDefinition = identity } = {}) {\n        const [decodeFrom, length, startAt] = decodeVecLength(value);\n        super(registry, length);\n        this.#Type = definition || setDefinition(typeToConstructor(registry, Type));\n        this.initialU8aLength = (isU8a(decodeFrom)\n            ? decodeU8aVec(registry, this, decodeFrom, startAt, this.#Type)\n            : decodeVec(registry, this, decodeFrom, startAt, this.#Type))[0];\n    }\n    static with(Type) {\n        let definition;\n        // eslint-disable-next-line no-return-assign\n        const setDefinition = (d) => (definition = d);\n        return class extends Vec {\n            constructor(registry, value) {\n                super(registry, Type, value, { definition, setDefinition });\n            }\n        };\n    }\n    /**\n     * @description The type for the items\n     */\n    get Type() {\n        return this.#Type.name;\n    }\n    /**\n     * @description Finds the index of the value in the array\n     */\n    indexOf(other) {\n        // convert type first, this removes overhead from the eq\n        const check = other instanceof this.#Type\n            ? other\n            : new this.#Type(this.registry, other);\n        for (let i = 0, count = this.length; i < count; i++) {\n            if (check.eq(this[i])) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return `Vec<${this.registry.getClassName(this.#Type) || new this.#Type(this.registry).toRawType()}>`;\n    }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;;;;AACA,MAAM,aAAa,MAAM;AACzB,MAAM,IAAI,IAAA,sJAAM,EAAC;AACjB,SAAS,gBAAgB,KAAK;IAC1B,IAAI,MAAM,OAAO,CAAC,QAAQ;QACtB,OAAO;YAAC;YAAO,MAAM,MAAM;YAAE;SAAE;IACnC,OACK,IAAI,IAAA,wJAAK,EAAC,UAAU,IAAA,wJAAK,EAAC,QAAQ;QACnC,MAAM,MAAM,IAAA,8JAAQ,EAAC;QACrB,MAAM,CAAC,SAAS,OAAO,GAAG,IAAA,6KAAiB,EAAC;QAC5C,IAAI,SAAS,YAAY;YACrB,MAAM,IAAI,MAAM,CAAC,WAAW,EAAE,OAAO,QAAQ,GAAG,SAAS,EAAE,YAAY;QAC3E;QACA,OAAO;YAAC;YAAK;YAAQ;SAAQ;IACjC,OACK,IAAI,CAAC,OAAO;QACb,OAAO;YAAC;YAAM;YAAG;SAAE;IACvB;IACA,MAAM,IAAI,MAAM,CAAC,mDAAmD,EAAE,OAAO,MAAM,EAAE,EAAE,IAAA,4JAAS,EAAC,QAAQ;AAC7G;AACO,SAAS,UAAU,QAAQ,EAAE,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE,IAAI;IAC5D,IAAI,MAAM,OAAO,CAAC,QAAQ;QACtB,MAAM,QAAQ,OAAO,MAAM;QAC3B,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,IAAK;YAC5B,8EAA8E;YAC9E,mEAAmE;YACnE,MAAM,QAAQ,KAAK,CAAC,EAAE;YACtB,IAAI;gBACA,MAAM,CAAC,EAAE,GAAG,iBAAiB,OACvB,QACA,IAAI,KAAK,UAAU;YAC7B,EACA,OAAO,OAAO;gBACV,EAAE,KAAK,CAAC,CAAC,0BAA0B,EAAE,GAAG,EAAE,MAAM,OAAO;gBACvD,MAAM;YACV;QACJ;QACA,OAAO;YAAC;YAAG;SAAE;IACjB,OACK,IAAI,CAAC,OAAO;QACb,OAAO;YAAC;YAAG;SAAE;IACjB;IACA,2EAA2E;IAC3E,OAAO,IAAA,kLAAY,EAAC,UAAU,QAAQ,IAAA,8JAAQ,EAAC,QAAQ,SAAS;AACpE;AAQO,MAAM,YAAY,kLAAa;IAClC,CAAA,IAAK,CAAC;IACN,YAAY,QAAQ,EAAE,IAAI,EAAE,QAAQ,EAAE,EAAE,EAAE,UAAU,EAAE,gBAAgB,sJAAQ,EAAE,GAAG,CAAC,CAAC,CAAE;QACnF,MAAM,CAAC,YAAY,QAAQ,QAAQ,GAAG,gBAAgB;QACtD,KAAK,CAAC,UAAU;QAChB,IAAI,CAAC,CAAA,IAAK,GAAG,cAAc,cAAc,IAAA,4LAAiB,EAAC,UAAU;QACrE,IAAI,CAAC,gBAAgB,GAAG,CAAC,IAAA,wJAAK,EAAC,cACzB,IAAA,kLAAY,EAAC,UAAU,IAAI,EAAE,YAAY,SAAS,IAAI,CAAC,CAAA,IAAK,IAC5D,UAAU,UAAU,IAAI,EAAE,YAAY,SAAS,IAAI,CAAC,CAAA,IAAK,CAAC,CAAC,CAAC,EAAE;IACxE;IACA,OAAO,KAAK,IAAI,EAAE;QACd,IAAI;QACJ,4CAA4C;QAC5C,MAAM,gBAAgB,CAAC,IAAO,aAAa;QAC3C,OAAO,cAAc;YACjB,YAAY,QAAQ,EAAE,KAAK,CAAE;gBACzB,KAAK,CAAC,UAAU,MAAM,OAAO;oBAAE;oBAAY;gBAAc;YAC7D;QACJ;IACJ;IACA;;KAEC,GACD,IAAI,OAAO;QACP,OAAO,IAAI,CAAC,CAAA,IAAK,CAAC,IAAI;IAC1B;IACA;;KAEC,GACD,QAAQ,KAAK,EAAE;QACX,wDAAwD;QACxD,MAAM,QAAQ,iBAAiB,IAAI,CAAC,CAAA,IAAK,GACnC,QACA,IAAI,IAAI,CAAC,CAAA,IAAK,CAAC,IAAI,CAAC,QAAQ,EAAE;QACpC,IAAK,IAAI,IAAI,GAAG,QAAQ,IAAI,CAAC,MAAM,EAAE,IAAI,OAAO,IAAK;YACjD,IAAI,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE,GAAG;gBACnB,OAAO;YACX;QACJ;QACA,OAAO,CAAC;IACZ;IACA;;KAEC,GACD,YAAY;QACR,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,CAAA,IAAK,KAAK,IAAI,IAAI,CAAC,CAAA,IAAK,CAAC,IAAI,CAAC,QAAQ,EAAE,SAAS,GAAG,CAAC,CAAC;IACxG;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3639, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/base/VecFixed.js"],"sourcesContent":["import { identity, isU8a, u8aConcatStrict } from '@polkadot/util';\nimport { AbstractArray } from '../abstract/Array.js';\nimport { decodeU8aVec, typeToConstructor } from '../utils/index.js';\nimport { decodeVec } from './Vec.js';\n/**\n * @name VecFixed\n * @description\n * This manages codec arrays of a fixed length\n */\nexport class VecFixed extends AbstractArray {\n    #Type;\n    constructor(registry, Type, length, value = [], { definition, setDefinition = identity } = {}) {\n        super(registry, length);\n        this.#Type = definition || setDefinition(typeToConstructor(registry, Type));\n        this.initialU8aLength = (isU8a(value)\n            ? decodeU8aVec(registry, this, value, 0, this.#Type)\n            : decodeVec(registry, this, value, 0, this.#Type))[1];\n    }\n    static with(Type, length) {\n        let definition;\n        // eslint-disable-next-line no-return-assign\n        const setDefinition = (d) => (definition = d);\n        return class extends VecFixed {\n            constructor(registry, value) {\n                super(registry, Type, length, value, { definition, setDefinition });\n            }\n        };\n    }\n    /**\n     * @description The type for the items\n     */\n    get Type() {\n        return new this.#Type(this.registry).toRawType();\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        let total = 0;\n        for (let i = 0, count = this.length; i < count; i++) {\n            total += this[i].encodedLength;\n        }\n        return total;\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return {\n            inner: this.inspectInner()\n        };\n    }\n    toU8a() {\n        // we override, we don't add the length prefix for ourselves, and at the same time we\n        // ignore isBare on entries, since they should be properly encoded at all times\n        const encoded = this.toU8aInner();\n        return encoded.length\n            ? u8aConcatStrict(encoded)\n            : new Uint8Array([]);\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return `[${this.Type};${this.length}]`;\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;;;;;AAMO,MAAM,iBAAiB,kLAAa;IACvC,CAAA,IAAK,CAAC;IACN,YAAY,QAAQ,EAAE,IAAI,EAAE,MAAM,EAAE,QAAQ,EAAE,EAAE,EAAE,UAAU,EAAE,gBAAgB,sJAAQ,EAAE,GAAG,CAAC,CAAC,CAAE;QAC3F,KAAK,CAAC,UAAU;QAChB,IAAI,CAAC,CAAA,IAAK,GAAG,cAAc,cAAc,IAAA,4LAAiB,EAAC,UAAU;QACrE,IAAI,CAAC,gBAAgB,GAAG,CAAC,IAAA,wJAAK,EAAC,SACzB,IAAA,kLAAY,EAAC,UAAU,IAAI,EAAE,OAAO,GAAG,IAAI,CAAC,CAAA,IAAK,IACjD,IAAA,wKAAS,EAAC,UAAU,IAAI,EAAE,OAAO,GAAG,IAAI,CAAC,CAAA,IAAK,CAAC,CAAC,CAAC,EAAE;IAC7D;IACA,OAAO,KAAK,IAAI,EAAE,MAAM,EAAE;QACtB,IAAI;QACJ,4CAA4C;QAC5C,MAAM,gBAAgB,CAAC,IAAO,aAAa;QAC3C,OAAO,cAAc;YACjB,YAAY,QAAQ,EAAE,KAAK,CAAE;gBACzB,KAAK,CAAC,UAAU,MAAM,QAAQ,OAAO;oBAAE;oBAAY;gBAAc;YACrE;QACJ;IACJ;IACA;;KAEC,GACD,IAAI,OAAO;QACP,OAAO,IAAI,IAAI,CAAC,CAAA,IAAK,CAAC,IAAI,CAAC,QAAQ,EAAE,SAAS;IAClD;IACA;;KAEC,GACD,IAAI,gBAAgB;QAChB,IAAI,QAAQ;QACZ,IAAK,IAAI,IAAI,GAAG,QAAQ,IAAI,CAAC,MAAM,EAAE,IAAI,OAAO,IAAK;YACjD,SAAS,IAAI,CAAC,EAAE,CAAC,aAAa;QAClC;QACA,OAAO;IACX;IACA;;KAEC,GACD,UAAU;QACN,OAAO;YACH,OAAO,IAAI,CAAC,YAAY;QAC5B;IACJ;IACA,QAAQ;QACJ,qFAAqF;QACrF,+EAA+E;QAC/E,MAAM,UAAU,IAAI,CAAC,UAAU;QAC/B,OAAO,QAAQ,MAAM,GACf,IAAA,sKAAe,EAAC,WAChB,IAAI,WAAW,EAAE;IAC3B;IACA;;KAEC,GACD,YAAY;QACR,OAAO,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;IAC1C;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3711, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/extended/WrapperKeepOpaque.js"],"sourcesContent":["import { compactAddLength, compactStripLength, compactToU8a, isHex, isU8a, u8aToU8a } from '@polkadot/util';\nimport { Raw } from '../native/Raw.js';\nimport { typeToConstructor } from '../utils/index.js';\nimport { Bytes } from './Bytes.js';\nfunction decodeRaw(registry, typeName, value) {\n    const Type = typeToConstructor(registry, typeName);\n    if (isU8a(value) || isHex(value)) {\n        try {\n            const [, u8a] = isHex(value)\n                ? [0, u8aToU8a(value)]\n                : (value instanceof Raw)\n                    ? [0, value.subarray()]\n                    : compactStripLength(value);\n            return [Type, new Type(registry, u8a), value];\n        }\n        catch {\n            return [Type, null, value];\n        }\n    }\n    const instance = new Type(registry, value);\n    return [Type, instance, compactAddLength(instance.toU8a())];\n}\nexport class WrapperKeepOpaque extends Bytes {\n    #Type;\n    #decoded;\n    #opaqueName;\n    constructor(registry, typeName, value, { opaqueName = 'WrapperKeepOpaque' } = {}) {\n        const [Type, decoded, u8a] = decodeRaw(registry, typeName, value);\n        super(registry, u8a);\n        this.#Type = Type;\n        this.#decoded = decoded;\n        this.#opaqueName = opaqueName;\n    }\n    static with(Type) {\n        return class extends WrapperKeepOpaque {\n            constructor(registry, value) {\n                super(registry, Type, value);\n            }\n        };\n    }\n    /**\n     * @description Checks if the wrapper is decodable\n     */\n    get isDecoded() {\n        return !!this.#decoded;\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return this.#decoded\n            ? {\n                inner: [this.#decoded.inspect()],\n                outer: [compactToU8a(this.length)]\n            }\n            : {\n                outer: [compactToU8a(this.length), this.toU8a(true)]\n            };\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman(isExtended, disableAscii) {\n        return this.#decoded\n            ? this.#decoded.toHuman(isExtended, disableAscii)\n            : super.toHuman(isExtended, disableAscii);\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive(disableAscii) {\n        return this.#decoded\n            ? this.#decoded.toPrimitive(disableAscii)\n            : super.toPrimitive(disableAscii);\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return `${this.#opaqueName}<${this.registry.getClassName(this.#Type) || (this.#decoded ? this.#decoded.toRawType() : new this.#Type(this.registry).toRawType())}>`;\n    }\n    /**\n     * @description Converts the Object to to a string (either decoded or bytes)\n     */\n    toString() {\n        return this.#decoded\n            ? this.#decoded.toString()\n            : super.toString();\n    }\n    /**\n     * @description Returns the decoded that the WrapperKeepOpaque represents (if available), throws if non-decodable\n     */\n    unwrap() {\n        if (!this.#decoded) {\n            throw new Error(`${this.#opaqueName}: unwrapping an undecodable value`);\n        }\n        return this.#decoded;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3832, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/extended/WrapperOpaque.js"],"sourcesContent":["import { WrapperKeepOpaque } from './WrapperKeepOpaque.js';\nexport class WrapperOpaque extends WrapperKeepOpaque {\n    constructor(registry, typeName, value) {\n        super(registry, typeName, value, { opaqueName: 'WrapperOpaque' });\n    }\n    static with(Type) {\n        return class extends WrapperOpaque {\n            constructor(registry, value) {\n                super(registry, Type, value);\n            }\n        };\n    }\n    /**\n     * @description The inner value for this wrapper, in all cases it _should_ be decodable (unlike KeepOpaque)\n     */\n    get inner() {\n        return this.unwrap();\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;AACO,MAAM,sBAAsB,kMAAiB;IAChD,YAAY,QAAQ,EAAE,QAAQ,EAAE,KAAK,CAAE;QACnC,KAAK,CAAC,UAAU,UAAU,OAAO;YAAE,YAAY;QAAgB;IACnE;IACA,OAAO,KAAK,IAAI,EAAE;QACd,OAAO,cAAc;YACjB,YAAY,QAAQ,EAAE,KAAK,CAAE;gBACzB,KAAK,CAAC,UAAU,MAAM;YAC1B;QACJ;IACJ;IACA;;KAEC,GACD,IAAI,QAAQ;QACR,OAAO,IAAI,CAAC,MAAM;IACtB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3861, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/abstract/Base.js"],"sourcesContent":["/**\n * @name Base\n * @description A type extends the Base class, when it holds a value\n */\nexport class AbstractBase {\n    registry;\n    createdAtHash;\n    initialU8aLength;\n    isStorageFallback;\n    #raw;\n    constructor(registry, value, initialU8aLength) {\n        this.initialU8aLength = initialU8aLength;\n        this.#raw = value;\n        this.registry = registry;\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        return this.toU8a().length;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description returns the inner (wrapped value)\n     */\n    get inner() {\n        return this.#raw;\n    }\n    /**\n     * @description Checks if the value is an empty value\n     */\n    get isEmpty() {\n        return this.#raw.isEmpty;\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        return this.#raw.eq(other);\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return this.#raw.inspect();\n    }\n    /**\n     * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation\n     */\n    toHex(isLe) {\n        return this.#raw.toHex(isLe);\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman(isExtended, disableAscii) {\n        return this.#raw.toHuman(isExtended, disableAscii);\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        return this.#raw.toJSON();\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive(disableAscii) {\n        return this.#raw.toPrimitive(disableAscii);\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        return this.#raw.toString();\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        return this.#raw.toU8a(isBare);\n    }\n    /**\n     * @description Returns the inner wrapped value (equivalent to valueOf)\n     */\n    unwrap() {\n        return this.#raw;\n    }\n    /**\n     * @description Returns the inner wrapped value\n     */\n    valueOf() {\n        return this.#raw;\n    }\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;AACM,MAAM;IACT,SAAS;IACT,cAAc;IACd,iBAAiB;IACjB,kBAAkB;IAClB,CAAA,GAAI,CAAC;IACL,YAAY,QAAQ,EAAE,KAAK,EAAE,gBAAgB,CAAE;QAC3C,IAAI,CAAC,gBAAgB,GAAG;QACxB,IAAI,CAAC,CAAA,GAAI,GAAG;QACZ,IAAI,CAAC,QAAQ,GAAG;IACpB;IACA;;KAEC,GACD,IAAI,gBAAgB;QAChB,OAAO,IAAI,CAAC,KAAK,GAAG,MAAM;IAC9B;IACA;;KAEC,GACD,IAAI,OAAO;QACP,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK;IACxC;IACA;;KAEC,GACD,IAAI,QAAQ;QACR,OAAO,IAAI,CAAC,CAAA,GAAI;IACpB;IACA;;KAEC,GACD,IAAI,UAAU;QACV,OAAO,IAAI,CAAC,CAAA,GAAI,CAAC,OAAO;IAC5B;IACA;;KAEC,GACD,GAAG,KAAK,EAAE;QACN,OAAO,IAAI,CAAC,CAAA,GAAI,CAAC,EAAE,CAAC;IACxB;IACA;;KAEC,GACD,UAAU;QACN,OAAO,IAAI,CAAC,CAAA,GAAI,CAAC,OAAO;IAC5B;IACA;;KAEC,GACD,MAAM,IAAI,EAAE;QACR,OAAO,IAAI,CAAC,CAAA,GAAI,CAAC,KAAK,CAAC;IAC3B;IACA;;KAEC,GACD,QAAQ,UAAU,EAAE,YAAY,EAAE;QAC9B,OAAO,IAAI,CAAC,CAAA,GAAI,CAAC,OAAO,CAAC,YAAY;IACzC;IACA;;KAEC,GACD,SAAS;QACL,OAAO,IAAI,CAAC,CAAA,GAAI,CAAC,MAAM;IAC3B;IACA;;KAEC,GACD,YAAY,YAAY,EAAE;QACtB,OAAO,IAAI,CAAC,CAAA,GAAI,CAAC,WAAW,CAAC;IACjC;IACA;;KAEC,GACD,WAAW;QACP,OAAO,IAAI,CAAC,CAAA,GAAI,CAAC,QAAQ;IAC7B;IACA;;;KAGC,GACD,MAAM,MAAM,EAAE;QACV,OAAO,IAAI,CAAC,CAAA,GAAI,CAAC,KAAK,CAAC;IAC3B;IACA;;KAEC,GACD,SAAS;QACL,OAAO,IAAI,CAAC,CAAA,GAAI;IACpB;IACA;;KAEC,GACD,UAAU;QACN,OAAO,IAAI,CAAC,CAAA,GAAI;IACpB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3955, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/primitive/U64.js"],"sourcesContent":["import { UInt } from '../base/UInt.js';\n/**\n * @name u64\n * @description\n * A 64-bit unsigned integer\n */\nexport class u64 extends UInt.with(64) {\n    // NOTE without this, we cannot properly determine extensions\n    __UIntType = 'u64';\n}\n"],"names":[],"mappings":";;;;AAAA;;AAMO,MAAM,YAAY,oKAAI,CAAC,IAAI,CAAC;IAC/B,6DAA6D;IAC7D,aAAa,MAAM;AACvB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3978, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/native/Bool.js"],"sourcesContent":["import { isU8a, u8aToHex } from '@polkadot/util';\n/**\n * @name bool\n * @description\n * Representation for a boolean value in the system. It extends the base JS `Boolean` class\n * @noInheritDoc\n */\nexport class bool extends Boolean {\n    registry;\n    createdAtHash;\n    initialU8aLength = 1;\n    isStorageFallback;\n    constructor(registry, value = false) {\n        super(isU8a(value)\n            ? value[0] === 1\n            : value instanceof Boolean\n                ? value.valueOf()\n                : !!value);\n        this.registry = registry;\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        return 1 | 0;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Checks if the value is an empty value (true when it wraps false/default)\n     */\n    get isEmpty() {\n        return this.isFalse;\n    }\n    /**\n     * @description Checks if the value is an empty value (always false)\n     */\n    get isFalse() {\n        return !this.isTrue;\n    }\n    /**\n     * @description Checks if the value is an empty value (always false)\n     */\n    get isTrue() {\n        return this.valueOf();\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        return this.valueOf() === (other instanceof Boolean\n            ? other.valueOf()\n            : other);\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return {\n            outer: [this.toU8a()]\n        };\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n    toHex() {\n        return u8aToHex(this.toU8a());\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman() {\n        return this.toJSON();\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        return this.valueOf();\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive() {\n        return this.toJSON();\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'bool';\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        return this.toJSON().toString();\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     */\n    toU8a(_isBare) {\n        return new Uint8Array([this.valueOf() ? 1 : 0]);\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;;AAOO,MAAM,aAAa;IACtB,SAAS;IACT,cAAc;IACd,mBAAmB,EAAE;IACrB,kBAAkB;IAClB,YAAY,QAAQ,EAAE,QAAQ,KAAK,CAAE;QACjC,KAAK,CAAC,IAAA,wJAAK,EAAC,SACN,KAAK,CAAC,EAAE,KAAK,IACb,iBAAiB,UACb,MAAM,OAAO,KACb,CAAC,CAAC;QACZ,IAAI,CAAC,QAAQ,GAAG;IACpB;IACA;;KAEC,GACD,IAAI,gBAAgB;QAChB,OAAO,IAAI;IACf;IACA;;KAEC,GACD,IAAI,OAAO;QACP,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK;IACxC;IACA;;KAEC,GACD,IAAI,UAAU;QACV,OAAO,IAAI,CAAC,OAAO;IACvB;IACA;;KAEC,GACD,IAAI,UAAU;QACV,OAAO,CAAC,IAAI,CAAC,MAAM;IACvB;IACA;;KAEC,GACD,IAAI,SAAS;QACT,OAAO,IAAI,CAAC,OAAO;IACvB;IACA;;KAEC,GACD,GAAG,KAAK,EAAE;QACN,OAAO,IAAI,CAAC,OAAO,OAAO,CAAC,iBAAiB,UACtC,MAAM,OAAO,KACb,KAAK;IACf;IACA;;KAEC,GACD,UAAU;QACN,OAAO;YACH,OAAO;gBAAC,IAAI,CAAC,KAAK;aAAG;QACzB;IACJ;IACA;;KAEC,GACD,QAAQ;QACJ,OAAO,IAAA,8JAAQ,EAAC,IAAI,CAAC,KAAK;IAC9B;IACA;;KAEC,GACD,UAAU;QACN,OAAO,IAAI,CAAC,MAAM;IACtB;IACA;;KAEC,GACD,SAAS;QACL,OAAO,IAAI,CAAC,OAAO;IACvB;IACA;;KAEC,GACD,cAAc;QACV,OAAO,IAAI,CAAC,MAAM;IACtB;IACA;;KAEC,GACD,YAAY;QACR,OAAO;IACX;IACA;;KAEC,GACD,WAAW;QACP,OAAO,IAAI,CAAC,MAAM,GAAG,QAAQ;IACjC;IACA;;KAEC,GACD,MAAM,OAAO,EAAE;QACX,OAAO,IAAI,WAAW;YAAC,IAAI,CAAC,OAAO,KAAK,IAAI;SAAE;IAClD;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4084, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/extended/BitVec.js"],"sourcesContent":["import { compactFromU8aLim, compactToU8a, isString, u8aConcatStrict, u8aToU8a } from '@polkadot/util';\nimport { Raw } from '../native/Raw.js';\n/** @internal */\nfunction decodeBitVecU8a(value) {\n    if (!value?.length) {\n        return [0, new Uint8Array()];\n    }\n    // handle all other Uint8Array inputs, these do have a length prefix which is the number of bits encoded\n    const [offset, length] = compactFromU8aLim(value);\n    const total = offset + Math.ceil(length / 8);\n    if (total > value.length) {\n        throw new Error(`BitVec: required length less than remainder, expected at least ${total}, found ${value.length}`);\n    }\n    return [length, value.subarray(offset, total)];\n}\n/** @internal */\nfunction decodeBitVec(value) {\n    if (Array.isArray(value) || isString(value)) {\n        const u8a = u8aToU8a(value);\n        return [u8a.length * 8, u8a];\n    }\n    return decodeBitVecU8a(value);\n}\n/**\n * @name BitVec\n * @description\n * A BitVec that represents an array of bits. The bits are however stored encoded. The difference between this\n * and a normal Bytes would be that the length prefix indicates the number of bits encoded, not the bytes\n */\nexport class BitVec extends Raw {\n    #decodedLength;\n    #isMsb;\n    // In lieu of having the Msb/Lsb identifiers passed through, we default to assuming\n    // we are dealing with Lsb, which is the default (as of writing) BitVec format used\n    // in the Polkadot code (this only affects the toHuman displays)\n    constructor(registry, value, isMsb = false) {\n        const [decodedLength, u8a] = decodeBitVec(value);\n        super(registry, u8a);\n        this.#decodedLength = decodedLength;\n        this.#isMsb = isMsb;\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        return this.length + compactToU8a(this.#decodedLength).length;\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return {\n            outer: [compactToU8a(this.#decodedLength), super.toU8a()]\n        };\n    }\n    /**\n     * @description Creates a boolean array of the bit values\n     */\n    toBoolArray() {\n        const map = [...this.toU8a(true)].map((v) => [\n            !!(v & 0b1000_0000),\n            !!(v & 0b0100_0000),\n            !!(v & 0b0010_0000),\n            !!(v & 0b0001_0000),\n            !!(v & 0b0000_1000),\n            !!(v & 0b0000_0100),\n            !!(v & 0b0000_0010),\n            !!(v & 0b0000_0001)\n        ]);\n        const count = map.length;\n        const result = new Array(8 * count);\n        for (let i = 0; i < count; i++) {\n            const off = i * 8;\n            const v = map[i];\n            for (let j = 0; j < 8; j++) {\n                result[off + j] = this.#isMsb\n                    ? v[j]\n                    : v[7 - j];\n            }\n        }\n        return result;\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman() {\n        return `0b${[...this.toU8a(true)]\n            .map((d) => `00000000${d.toString(2)}`.slice(-8))\n            .map((s) => this.#isMsb ? s : s.split('').reverse().join(''))\n            .join('_')}`;\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'BitVec';\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        const bitVec = super.toU8a(isBare);\n        return isBare\n            ? bitVec\n            : u8aConcatStrict([compactToU8a(this.#decodedLength), bitVec]);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4204, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/native/Float.js"],"sourcesContent":["import { floatToU8a, isHex, isU8a, u8aToFloat, u8aToHex, u8aToU8a } from '@polkadot/util';\n/**\n * @name Float\n * @description\n * A Codec wrapper for F32 & F64 values. You generally don't want to be using\n * f32/f64 in your runtime, operations on fixed points numbers are preferable. This class\n * was explicitly added since scale-codec has a flag that enables this and it is available\n * in some eth_* RPCs\n */\nexport class Float extends Number {\n    encodedLength;\n    registry;\n    createdAtHash;\n    initialU8aLength;\n    isStorageFallback;\n    #bitLength;\n    constructor(registry, value, { bitLength = 32 } = {}) {\n        super(isU8a(value) || isHex(value)\n            ? value.length === 0\n                ? 0\n                : u8aToFloat(u8aToU8a(value), { bitLength })\n            : (value || 0));\n        this.#bitLength = bitLength;\n        this.encodedLength = bitLength / 8;\n        this.initialU8aLength = this.encodedLength;\n        this.registry = registry;\n    }\n    static with(bitLength) {\n        return class extends Float {\n            constructor(registry, value) {\n                super(registry, value, { bitLength });\n            }\n        };\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Returns true if the type wraps an empty/default all-0 value\n     */\n    get isEmpty() {\n        return this.valueOf() === 0;\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        return this.valueOf() === Number(other);\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return {\n            outer: [this.toU8a()]\n        };\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n    toHex() {\n        return u8aToHex(this.toU8a());\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman() {\n        return this.toString();\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        // Not sure if this is actually a hex or a string value\n        // (would need to check against RPCs to see the result here)\n        return this.toHex();\n    }\n    /**\n     * @description Returns the number representation (Same as valueOf)\n     */\n    toNumber() {\n        return this.valueOf();\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive() {\n        return this.toNumber();\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return `f${this.#bitLength}`;\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     */\n    toU8a(_isBare) {\n        return floatToU8a(this, {\n            bitLength: this.#bitLength\n        });\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASO,MAAM,cAAc;IACvB,cAAc;IACd,SAAS;IACT,cAAc;IACd,iBAAiB;IACjB,kBAAkB;IAClB,CAAA,SAAU,CAAC;IACX,YAAY,QAAQ,EAAE,KAAK,EAAE,EAAE,YAAY,EAAE,EAAE,GAAG,CAAC,CAAC,CAAE;QAClD,KAAK,CAAC,IAAA,wJAAK,EAAC,UAAU,IAAA,wJAAK,EAAC,SACtB,MAAM,MAAM,KAAK,IACb,IACA,IAAA,kKAAU,EAAC,IAAA,8JAAQ,EAAC,QAAQ;YAAE;QAAU,KAC3C,SAAS;QAChB,IAAI,CAAC,CAAA,SAAU,GAAG;QAClB,IAAI,CAAC,aAAa,GAAG,YAAY;QACjC,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,aAAa;QAC1C,IAAI,CAAC,QAAQ,GAAG;IACpB;IACA,OAAO,KAAK,SAAS,EAAE;QACnB,OAAO,cAAc;YACjB,YAAY,QAAQ,EAAE,KAAK,CAAE;gBACzB,KAAK,CAAC,UAAU,OAAO;oBAAE;gBAAU;YACvC;QACJ;IACJ;IACA;;KAEC,GACD,IAAI,OAAO;QACP,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK;IACxC;IACA;;KAEC,GACD,IAAI,UAAU;QACV,OAAO,IAAI,CAAC,OAAO,OAAO;IAC9B;IACA;;KAEC,GACD,GAAG,KAAK,EAAE;QACN,OAAO,IAAI,CAAC,OAAO,OAAO,OAAO;IACrC;IACA;;KAEC,GACD,UAAU;QACN,OAAO;YACH,OAAO;gBAAC,IAAI,CAAC,KAAK;aAAG;QACzB;IACJ;IACA;;KAEC,GACD,QAAQ;QACJ,OAAO,IAAA,8JAAQ,EAAC,IAAI,CAAC,KAAK;IAC9B;IACA;;KAEC,GACD,UAAU;QACN,OAAO,IAAI,CAAC,QAAQ;IACxB;IACA;;KAEC,GACD,SAAS;QACL,uDAAuD;QACvD,4DAA4D;QAC5D,OAAO,IAAI,CAAC,KAAK;IACrB;IACA;;KAEC,GACD,WAAW;QACP,OAAO,IAAI,CAAC,OAAO;IACvB;IACA;;KAEC,GACD,cAAc;QACV,OAAO,IAAI,CAAC,QAAQ;IACxB;IACA;;KAEC,GACD,YAAY;QACR,OAAO,CAAC,CAAC,EAAE,IAAI,CAAC,CAAA,SAAU,EAAE;IAChC;IACA;;KAEC,GACD,MAAM,OAAO,EAAE;QACX,OAAO,IAAA,kKAAU,EAAC,IAAI,EAAE;YACpB,WAAW,IAAI,CAAC,CAAA,SAAU;QAC9B;IACJ;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4308, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/primitive/F32.js"],"sourcesContent":["import { Float } from '../native/Float.js';\n/**\n * @name f32\n * @description\n * A 32-bit float\n */\nexport class f32 extends Float.with(32) {\n    // NOTE without this, we cannot properly determine extensions\n    __FloatType = 'f32';\n}\n"],"names":[],"mappings":";;;;AAAA;;AAMO,MAAM,YAAY,wKAAK,CAAC,IAAI,CAAC;IAChC,6DAA6D;IAC7D,cAAc,MAAM;AACxB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4331, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/primitive/F64.js"],"sourcesContent":["import { Float } from '../native/Float.js';\n/**\n * @name f64\n * @description\n * A 64-bit float\n */\nexport class f64 extends Float.with(64) {\n    // NOTE without this, we cannot properly determine extensions\n    __FloatType = 'f64';\n}\n"],"names":[],"mappings":";;;;AAAA;;AAMO,MAAM,YAAY,wKAAK,CAAC,IAAI,CAAC;IAChC,6DAA6D;IAC7D,cAAc,MAAM;AACxB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4354, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/primitive/I8.js"],"sourcesContent":["import { Int } from '../base/Int.js';\n/**\n * @name i8\n * @description\n * An 8-bit signed integer\n */\nexport class i8 extends Int.with(8) {\n    // NOTE without this, we cannot properly determine extensions\n    __IntType = 'i8';\n}\n"],"names":[],"mappings":";;;;AAAA;;AAMO,MAAM,WAAW,kKAAG,CAAC,IAAI,CAAC;IAC7B,6DAA6D;IAC7D,YAAY,KAAK;AACrB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4377, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/primitive/I16.js"],"sourcesContent":["import { Int } from '../base/Int.js';\n/**\n * @name i16\n * @description\n * A 16-bit signed integer\n */\nexport class i16 extends Int.with(16) {\n    // NOTE without this, we cannot properly determine extensions\n    __IntType = 'i16';\n}\n"],"names":[],"mappings":";;;;AAAA;;AAMO,MAAM,YAAY,kKAAG,CAAC,IAAI,CAAC;IAC9B,6DAA6D;IAC7D,YAAY,MAAM;AACtB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4400, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/primitive/I32.js"],"sourcesContent":["import { Int } from '../base/Int.js';\n/**\n * @name i32\n * @description\n * A 32-bit signed integer\n */\nexport class i32 extends Int.with(32) {\n    // NOTE without this, we cannot properly determine extensions\n    __IntType = 'i32';\n}\n"],"names":[],"mappings":";;;;AAAA;;AAMO,MAAM,YAAY,kKAAG,CAAC,IAAI,CAAC;IAC9B,6DAA6D;IAC7D,YAAY,MAAM;AACtB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4423, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/primitive/I64.js"],"sourcesContent":["import { Int } from '../base/Int.js';\n/**\n * @name i64\n * @description\n * A 64-bit signed integer\n */\nexport class i64 extends Int.with(64) {\n    // NOTE without this, we cannot properly determine extensions\n    __IntType = 'i64';\n}\n"],"names":[],"mappings":";;;;AAAA;;AAMO,MAAM,YAAY,kKAAG,CAAC,IAAI,CAAC;IAC9B,6DAA6D;IAC7D,YAAY,MAAM;AACtB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4446, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/primitive/I128.js"],"sourcesContent":["import { Int } from '../base/Int.js';\n/**\n * @name i128\n * @description\n * A 128-bit signed integer\n */\nexport class i128 extends Int.with(128) {\n    // NOTE without this, we cannot properly determine extensions\n    __IntType = 'i128';\n}\n"],"names":[],"mappings":";;;;AAAA;;AAMO,MAAM,aAAa,kKAAG,CAAC,IAAI,CAAC;IAC/B,6DAA6D;IAC7D,YAAY,OAAO;AACvB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4469, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/primitive/I256.js"],"sourcesContent":["import { Int } from '../base/Int.js';\n/**\n * @name i256\n * @description\n * A 256-bit signed integer\n */\nexport class i256 extends Int.with(256) {\n    // NOTE without this, we cannot properly determine extensions\n    __IntType = 'i256';\n}\n"],"names":[],"mappings":";;;;AAAA;;AAMO,MAAM,aAAa,kKAAG,CAAC,IAAI,CAAC;IAC/B,6DAA6D;IAC7D,YAAY,OAAO;AACvB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4492, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/primitive/ISize.js"],"sourcesContent":["import { i32 } from './I32.js';\n/**\n * @name ISize\n * @description\n * A System default signed number, typically used in RPC to report non-consensus\n * data. It is a wrapper for [[I32]] as a WASM default (as generated by Rust bindings).\n * It is not to be used, since it creates consensus mismatches.\n */\nexport class isize extends i32 {\n    constructor(registry, value) {\n        super(registry, value);\n        throw new Error('The `isize` type should not be used. Since it is platform-specific, it creates incompatibilities between native (generally i64) and WASM (always i32) code. Use one of the `i32` or `i64` types explicitly.');\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;AAQO,MAAM,cAAc,uKAAG;IAC1B,YAAY,QAAQ,EAAE,KAAK,CAAE;QACzB,KAAK,CAAC,UAAU;QAChB,MAAM,IAAI,MAAM;IACpB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4517, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/extended/OptionBool.js"],"sourcesContent":["import { isHex, isU8a, u8aToU8a } from '@polkadot/util';\nimport { Option } from '../base/Option.js';\nimport { bool as Bool } from '../native/Bool.js';\nfunction decodeU8a(registry, value) {\n    // Encoded as -\n    //  - 0 = None\n    //  - 1 = True\n    //  - 2 = False\n    return value[0] === 0\n        ? null\n        : new Bool(registry, value[0] === 1);\n}\n/**\n * @name OptionBool\n * @description A specific implementation of Option<bool> than allows for single-byte encoding\n */\nexport class OptionBool extends Option {\n    constructor(registry, value) {\n        super(registry, Bool, isU8a(value) || isHex(value)\n            ? decodeU8a(registry, u8aToU8a(value))\n            : value);\n        this.initialU8aLength = 1;\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        return 1 | 0;\n    }\n    /**\n     * @description Checks if the value is an empty value (always false)\n     */\n    get isFalse() {\n        return this.isSome\n            ? !this.value.valueOf()\n            : false;\n    }\n    /**\n     * @description Checks if the value is an empty value (always false)\n     */\n    get isTrue() {\n        return this.isSome\n            ? this.value.valueOf()\n            : false;\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        return { outer: [this.toU8a()] };\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType(isBare) {\n        return isBare\n            ? 'bool'\n            : 'Option<bool>';\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        if (isBare) {\n            return super.toU8a(true);\n        }\n        return this.isSome\n            ? new Uint8Array([this.isTrue ? 1 : 2])\n            : new Uint8Array([0]);\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AAAA;AACA;AACA;;;;AACA,SAAS,UAAU,QAAQ,EAAE,KAAK;IAC9B,eAAe;IACf,cAAc;IACd,cAAc;IACd,eAAe;IACf,OAAO,KAAK,CAAC,EAAE,KAAK,IACd,OACA,IAAI,sKAAI,CAAC,UAAU,KAAK,CAAC,EAAE,KAAK;AAC1C;AAKO,MAAM,mBAAmB,wKAAM;IAClC,YAAY,QAAQ,EAAE,KAAK,CAAE;QACzB,KAAK,CAAC,UAAU,sKAAI,EAAE,IAAA,wJAAK,EAAC,UAAU,IAAA,wJAAK,EAAC,SACtC,UAAU,UAAU,IAAA,8JAAQ,EAAC,UAC7B;QACN,IAAI,CAAC,gBAAgB,GAAG;IAC5B;IACA;;KAEC,GACD,IAAI,gBAAgB;QAChB,OAAO,IAAI;IACf;IACA;;KAEC,GACD,IAAI,UAAU;QACV,OAAO,IAAI,CAAC,MAAM,GACZ,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,KACnB;IACV;IACA;;KAEC,GACD,IAAI,SAAS;QACT,OAAO,IAAI,CAAC,MAAM,GACZ,IAAI,CAAC,KAAK,CAAC,OAAO,KAClB;IACV;IACA;;KAEC,GACD,UAAU;QACN,OAAO;YAAE,OAAO;gBAAC,IAAI,CAAC,KAAK;aAAG;QAAC;IACnC;IACA;;KAEC,GACD,UAAU,MAAM,EAAE;QACd,OAAO,SACD,SACA;IACV;IACA;;;KAGC,GACD,MAAM,MAAM,EAAE;QACV,IAAI,QAAQ;YACR,OAAO,KAAK,CAAC,MAAM;QACvB;QACA,OAAO,IAAI,CAAC,MAAM,GACZ,IAAI,WAAW;YAAC,IAAI,CAAC,MAAM,GAAG,IAAI;SAAE,IACpC,IAAI,WAAW;YAAC;SAAE;IAC5B;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4588, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/native/Text.js"],"sourcesContent":["import { compactAddLength, compactFromU8aLim, compactToU8a, hexToU8a, isHex, isString, isU8a, stringToU8a, u8aToHex, u8aToString } from '@polkadot/util';\nimport { Raw } from './Raw.js';\nconst MAX_LENGTH = 128 * 1024;\n/** @internal */\nfunction decodeText(value) {\n    if (isU8a(value)) {\n        if (!value.length) {\n            return ['', 0];\n        }\n        // for Raw, the internal buffer does not have an internal length\n        // (the same applies in e.g. Bytes, where length is added at encoding-time)\n        if (value instanceof Raw) {\n            return [u8aToString(value), 0];\n        }\n        const [offset, length] = compactFromU8aLim(value);\n        const total = offset + length;\n        if (length > MAX_LENGTH) {\n            throw new Error(`Text: length ${length.toString()} exceeds ${MAX_LENGTH}`);\n        }\n        else if (total > value.length) {\n            throw new Error(`Text: required length less than remainder, expected at least ${total}, found ${value.length}`);\n        }\n        return [u8aToString(value.subarray(offset, total)), total];\n    }\n    else if (isHex(value)) {\n        return [u8aToString(hexToU8a(value)), 0];\n    }\n    return [value ? value.toString() : '', 0];\n}\n/**\n * @name Text\n * @description\n * This is a string wrapper, along with the length. It is used both for strings as well\n * as items such as documentation. It simply extends the standard JS `String` built-in\n * object, inheriting all methods exposed from `String`.\n * @noInheritDoc\n */\nexport class Text extends String {\n    registry;\n    createdAtHash;\n    initialU8aLength;\n    isStorageFallback;\n    #override = null;\n    constructor(registry, value) {\n        const [str, decodedLength] = decodeText(value);\n        super(str);\n        this.registry = registry;\n        this.initialU8aLength = decodedLength;\n    }\n    /**\n     * @description The length of the value when encoded as a Uint8Array\n     */\n    get encodedLength() {\n        return this.toU8a().length;\n    }\n    /**\n     * @description returns a hash of the contents\n     */\n    get hash() {\n        return this.registry.hash(this.toU8a());\n    }\n    /**\n     * @description Checks if the value is an empty value\n     */\n    get isEmpty() {\n        return this.length === 0;\n    }\n    /**\n     * @description The length of the value\n     */\n    get length() {\n        // only included here since we ignore inherited docs\n        return super.length;\n    }\n    /**\n     * @description Compares the value of the input to see if there is a match\n     */\n    eq(other) {\n        return isString(other)\n            ? this.toString() === other.toString()\n            : false;\n    }\n    /**\n     * @description Returns a breakdown of the hex encoding for this Codec\n     */\n    inspect() {\n        const value = stringToU8a(super.toString());\n        return {\n            outer: value.length\n                ? [compactToU8a(value.length), value]\n                : [compactToU8a(value.length)]\n        };\n    }\n    /**\n     * @description Set an override value for this\n     */\n    setOverride(override) {\n        this.#override = override;\n    }\n    /**\n     * @description Returns a hex string representation of the value\n     */\n    toHex() {\n        // like with Vec<u8>, when we are encoding to hex, we don't actually add\n        // the length prefix (it is already implied by the actual string length)\n        return u8aToHex(this.toU8a(true));\n    }\n    /**\n     * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n     */\n    toHuman() {\n        return this.toJSON();\n    }\n    /**\n     * @description Converts the Object to JSON, typically used for RPC transfers\n     */\n    toJSON() {\n        return this.toString();\n    }\n    /**\n     * @description Converts the value in a best-fit primitive form\n     */\n    toPrimitive() {\n        return this.toJSON();\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'Text';\n    }\n    /**\n     * @description Returns the string representation of the value\n     */\n    toString() {\n        return this.#override || super.toString();\n    }\n    /**\n     * @description Encodes the value as a Uint8Array as per the SCALE specifications\n     * @param isBare true when the value has none of the type-specific prefixes (internal)\n     */\n    toU8a(isBare) {\n        // NOTE Here we use the super toString (we are not taking overrides into account,\n        // rather encoding the original value the string was constructed with)\n        const encoded = stringToU8a(super.toString());\n        return isBare\n            ? encoded\n            : compactAddLength(encoded);\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AACA,MAAM,aAAa,MAAM;AACzB,cAAc,GACd,SAAS,WAAW,KAAK;IACrB,IAAI,IAAA,wJAAK,EAAC,QAAQ;QACd,IAAI,CAAC,MAAM,MAAM,EAAE;YACf,OAAO;gBAAC;gBAAI;aAAE;QAClB;QACA,gEAAgE;QAChE,2EAA2E;QAC3E,IAAI,iBAAiB,oKAAG,EAAE;YACtB,OAAO;gBAAC,IAAA,oKAAW,EAAC;gBAAQ;aAAE;QAClC;QACA,MAAM,CAAC,QAAQ,OAAO,GAAG,IAAA,6KAAiB,EAAC;QAC3C,MAAM,QAAQ,SAAS;QACvB,IAAI,SAAS,YAAY;YACrB,MAAM,IAAI,MAAM,CAAC,aAAa,EAAE,OAAO,QAAQ,GAAG,SAAS,EAAE,YAAY;QAC7E,OACK,IAAI,QAAQ,MAAM,MAAM,EAAE;YAC3B,MAAM,IAAI,MAAM,CAAC,6DAA6D,EAAE,MAAM,QAAQ,EAAE,MAAM,MAAM,EAAE;QAClH;QACA,OAAO;YAAC,IAAA,oKAAW,EAAC,MAAM,QAAQ,CAAC,QAAQ;YAAS;SAAM;IAC9D,OACK,IAAI,IAAA,wJAAK,EAAC,QAAQ;QACnB,OAAO;YAAC,IAAA,oKAAW,EAAC,IAAA,8JAAQ,EAAC;YAAS;SAAE;IAC5C;IACA,OAAO;QAAC,QAAQ,MAAM,QAAQ,KAAK;QAAI;KAAE;AAC7C;AASO,MAAM,aAAa;IACtB,SAAS;IACT,cAAc;IACd,iBAAiB;IACjB,kBAAkB;IAClB,CAAA,QAAS,GAAG,KAAK;IACjB,YAAY,QAAQ,EAAE,KAAK,CAAE;QACzB,MAAM,CAAC,KAAK,cAAc,GAAG,WAAW;QACxC,KAAK,CAAC;QACN,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,gBAAgB,GAAG;IAC5B;IACA;;KAEC,GACD,IAAI,gBAAgB;QAChB,OAAO,IAAI,CAAC,KAAK,GAAG,MAAM;IAC9B;IACA;;KAEC,GACD,IAAI,OAAO;QACP,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK;IACxC;IACA;;KAEC,GACD,IAAI,UAAU;QACV,OAAO,IAAI,CAAC,MAAM,KAAK;IAC3B;IACA;;KAEC,GACD,IAAI,SAAS;QACT,oDAAoD;QACpD,OAAO,KAAK,CAAC;IACjB;IACA;;KAEC,GACD,GAAG,KAAK,EAAE;QACN,OAAO,IAAA,8JAAQ,EAAC,SACV,IAAI,CAAC,QAAQ,OAAO,MAAM,QAAQ,KAClC;IACV;IACA;;KAEC,GACD,UAAU;QACN,MAAM,QAAQ,IAAA,oKAAW,EAAC,KAAK,CAAC;QAChC,OAAO;YACH,OAAO,MAAM,MAAM,GACb;gBAAC,IAAA,sKAAY,EAAC,MAAM,MAAM;gBAAG;aAAM,GACnC;gBAAC,IAAA,sKAAY,EAAC,MAAM,MAAM;aAAE;QACtC;IACJ;IACA;;KAEC,GACD,YAAY,QAAQ,EAAE;QAClB,IAAI,CAAC,CAAA,QAAS,GAAG;IACrB;IACA;;KAEC,GACD,QAAQ;QACJ,wEAAwE;QACxE,wEAAwE;QACxE,OAAO,IAAA,8JAAQ,EAAC,IAAI,CAAC,KAAK,CAAC;IAC/B;IACA;;KAEC,GACD,UAAU;QACN,OAAO,IAAI,CAAC,MAAM;IACtB;IACA;;KAEC,GACD,SAAS;QACL,OAAO,IAAI,CAAC,QAAQ;IACxB;IACA;;KAEC,GACD,cAAc;QACV,OAAO,IAAI,CAAC,MAAM;IACtB;IACA;;KAEC,GACD,YAAY;QACR,OAAO;IACX;IACA;;KAEC,GACD,WAAW;QACP,OAAO,IAAI,CAAC,CAAA,QAAS,IAAI,KAAK,CAAC;IACnC;IACA;;;KAGC,GACD,MAAM,MAAM,EAAE;QACV,iFAAiF;QACjF,sEAAsE;QACtE,MAAM,UAAU,IAAA,oKAAW,EAAC,KAAK,CAAC;QAClC,OAAO,SACD,UACA,IAAA,8KAAgB,EAAC;IAC3B;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4746, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/extended/Type.js"],"sourcesContent":["import { Text } from '../native/Text.js';\nimport { sanitize } from '../utils/index.js';\n/**\n * @name Type\n * @description\n * This is a extended version of Text, specifically to handle types. Here we rely fully\n * on what Text provides us, however we also adjust the types received from the runtime,\n * i.e. we remove the `T::` prefixes found in some types for consistency across implementation.\n */\nexport class Type extends Text {\n    constructor(registry, value = '') {\n        super(registry, value);\n        this.setOverride(sanitize(this.toString()));\n    }\n    /**\n     * @description Returns the base runtime type name for this instance\n     */\n    toRawType() {\n        return 'Type';\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAQO,MAAM,aAAa,sKAAI;IAC1B,YAAY,QAAQ,EAAE,QAAQ,EAAE,CAAE;QAC9B,KAAK,CAAC,UAAU;QAChB,IAAI,CAAC,WAAW,CAAC,IAAA,6KAAQ,EAAC,IAAI,CAAC,QAAQ;IAC3C;IACA;;KAEC,GACD,YAAY;QACR,OAAO;IACX;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4769, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/primitive/U8.js"],"sourcesContent":["import { UInt } from '../base/UInt.js';\n/**\n * @name u8\n * @description\n * An 8-bit unsigned integer\n */\nexport class u8 extends UInt.with(8) {\n    // NOTE without this, we cannot properly determine extensions\n    __UIntType = 'u8';\n}\n"],"names":[],"mappings":";;;;AAAA;;AAMO,MAAM,WAAW,oKAAI,CAAC,IAAI,CAAC;IAC9B,6DAA6D;IAC7D,aAAa,KAAK;AACtB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4792, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/primitive/U16.js"],"sourcesContent":["import { UInt } from '../base/UInt.js';\n/**\n * @name u16\n * @description\n * A 16-bit unsigned integer\n */\nexport class u16 extends UInt.with(16) {\n    // NOTE without this, we cannot properly determine extensions\n    __UIntType = 'u16';\n}\n"],"names":[],"mappings":";;;;AAAA;;AAMO,MAAM,YAAY,oKAAI,CAAC,IAAI,CAAC;IAC/B,6DAA6D;IAC7D,aAAa,MAAM;AACvB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4815, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/primitive/U128.js"],"sourcesContent":["import { UInt } from '../base/UInt.js';\n/**\n * @name u128\n * @description\n * A 128-bit unsigned integer\n */\nexport class u128 extends UInt.with(128) {\n    // NOTE without this, we cannot properly determine extensions\n    __UIntType = 'u128';\n}\n"],"names":[],"mappings":";;;;AAAA;;AAMO,MAAM,aAAa,oKAAI,CAAC,IAAI,CAAC;IAChC,6DAA6D;IAC7D,aAAa,OAAO;AACxB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4838, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/primitive/U256.js"],"sourcesContent":["import { UInt } from '../base/UInt.js';\n/**\n * @name u256\n * @description\n * A 256-bit unsigned integer\n */\nexport class u256 extends UInt.with(256) {\n    // NOTE without this, we cannot properly determine extensions\n    __UIntType = 'u256';\n}\n"],"names":[],"mappings":";;;;AAAA;;AAMO,MAAM,aAAa,oKAAI,CAAC,IAAI,CAAC;IAChC,6DAA6D;IAC7D,aAAa,OAAO;AACxB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4861, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/types-codec/primitive/USize.js"],"sourcesContent":["import { u32 } from './U32.js';\n/**\n * @name USize\n * @description\n * A System default unsigned number, typically used in RPC to report non-consensus\n * data. It is a wrapper for [[U32]] as a WASM default (as generated by Rust bindings).\n * It is not to be used, since it created consensus mismatches.\n */\nexport class usize extends u32 {\n    constructor(registry, value) {\n        super(registry, value);\n        throw new Error('The `usize` type should not be used. Since it is platform-specific, it creates incompatibilities between native (generally u64) and WASM (always u32) code. Use one of the `u32` or `u64` types explicitly.');\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;AAQO,MAAM,cAAc,uKAAG;IAC1B,YAAY,QAAQ,EAAE,KAAK,CAAE;QACzB,KAAK,CAAC,UAAU;QAChB,MAAM,IAAI,MAAM;IACpB;AACJ","ignoreList":[0],"debugId":null}}]
}