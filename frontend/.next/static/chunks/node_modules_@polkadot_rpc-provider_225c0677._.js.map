{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/rpc-provider/packageInfo.js"],"sourcesContent":["export const packageInfo = { name: '@polkadot/rpc-provider', path: (import.meta && import.meta.url) ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf('/') + 1) : 'auto', type: 'esm', version: '16.4.8' };\n"],"names":[],"mappings":";;;;;;;;;AAAO,MAAM,cAAc;IAAE,MAAM;IAA0B,MAAM,AAAC,iCAAe,8BAAY,GAAG,GAAI,IAAI,IAAI,8BAAY,GAAG,EAAE,QAAQ,CAAC,SAAS,CAAC,GAAG,IAAI,IAAI,8BAAY,GAAG,EAAE,QAAQ,CAAC,WAAW,CAAC,OAAO,KAAK;IAAQ,MAAM;IAAO,SAAS;AAAS","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/rpc-provider/coder/error.js"],"sourcesContent":["import { isFunction } from '@polkadot/util';\nconst UNKNOWN = -99999;\nfunction extend(that, name, value) {\n    Object.defineProperty(that, name, {\n        configurable: true,\n        enumerable: false,\n        value\n    });\n}\n/**\n * @name RpcError\n * @summary Extension to the basic JS Error.\n * @description\n * The built-in JavaScript Error class is extended by adding a code to allow for Error categorization. In addition to the normal `stack`, `message`, the numeric `code` and `data` (any types) parameters are available on the object.\n * @example\n * <BR>\n *\n * ```javascript\n * const { RpcError } from '@polkadot/util');\n *\n * throw new RpcError('some message', RpcError.CODES.METHOD_NOT_FOUND); // => error.code = -32601\n * ```\n */\nexport default class RpcError extends Error {\n    code;\n    data;\n    message;\n    name;\n    stack;\n    constructor(message = '', code = UNKNOWN, data) {\n        super();\n        extend(this, 'message', String(message));\n        extend(this, 'name', this.constructor.name);\n        extend(this, 'data', data);\n        extend(this, 'code', code);\n        if (isFunction(Error.captureStackTrace)) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n        else {\n            const { stack } = new Error(message);\n            stack && extend(this, 'stack', stack);\n        }\n    }\n    static CODES = {\n        ASSERT: -90009,\n        INVALID_JSONRPC: -99998,\n        METHOD_NOT_FOUND: -32601, // Rust client\n        UNKNOWN\n    };\n}\n"],"names":[],"mappings":";;;;;AAAA;;;AACA,MAAM,UAAU,CAAC;AACjB,SAAS,OAAO,IAAI,EAAE,IAAI,EAAE,KAAK;IAC7B,OAAO,cAAc,CAAC,MAAM,MAAM;QAC9B,cAAc;QACd,YAAY;QACZ;IACJ;AACJ;AAee,MAAM,iBAAiB;IAMlC,YAAY,UAAU,EAAE,EAAE,OAAO,OAAO,EAAE,IAAI,CAAE;QAC5C,KAAK,IANT,+KAAA,QAAA,KAAA,IACA,+KAAA,QAAA,KAAA,IACA,+KAAA,WAAA,KAAA,IACA,+KAAA,QAAA,KAAA,IACA,+KAAA,SAAA,KAAA;QAGI,OAAO,IAAI,EAAE,WAAW,OAAO;QAC/B,OAAO,IAAI,EAAE,QAAQ,IAAI,CAAC,WAAW,CAAC,IAAI;QAC1C,OAAO,IAAI,EAAE,QAAQ;QACrB,OAAO,IAAI,EAAE,QAAQ;QACrB,IAAI,IAAA,qKAAU,EAAC,MAAM,iBAAiB,GAAG;YACrC,MAAM,iBAAiB,CAAC,IAAI,EAAE,IAAI,CAAC,WAAW;QAClD,OACK;YACD,MAAM,EAAE,KAAK,EAAE,GAAG,IAAI,MAAM;YAC5B,SAAS,OAAO,IAAI,EAAE,SAAS;QACnC;IACJ;AAOJ;AANI,yKApBiB,UAoBV,SAAQ;IACX,QAAQ,CAAC;IACT,iBAAiB,CAAC;IAClB,kBAAkB,CAAC;IACnB;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 65, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/rpc-provider/coder/index.js"],"sourcesContent":["import { isNumber, isString, isUndefined, stringify } from '@polkadot/util';\nimport RpcError from './error.js';\nfunction formatErrorData(data) {\n    if (isUndefined(data)) {\n        return '';\n    }\n    const formatted = `: ${isString(data)\n        ? data.replace(/Error\\(\"/g, '').replace(/\\(\"/g, '(').replace(/\"\\)/g, ')').replace(/\\(/g, ', ').replace(/\\)/g, '')\n        : stringify(data)}`;\n    // We need some sort of cut-off here since these can be very large and\n    // very nested, pick a number and trim the result display to it\n    return formatted.length <= 256\n        ? formatted\n        : `${formatted.substring(0, 255)}â€¦`;\n}\nfunction checkError(error) {\n    if (error) {\n        const { code, data, message } = error;\n        throw new RpcError(`${code}: ${message}${formatErrorData(data)}`, code, data);\n    }\n}\n/** @internal */\nexport class RpcCoder {\n    #id = 0;\n    decodeResponse(response) {\n        if (!response || response.jsonrpc !== '2.0') {\n            throw new Error('Invalid jsonrpc field in decoded object');\n        }\n        const isSubscription = !isUndefined(response.params) && !isUndefined(response.method);\n        if (!isNumber(response.id) &&\n            (!isSubscription || (!isNumber(response.params.subscription) &&\n                !isString(response.params.subscription)))) {\n            throw new Error('Invalid id field in decoded object');\n        }\n        checkError(response.error);\n        if (response.result === undefined && !isSubscription) {\n            throw new Error('No result found in jsonrpc response');\n        }\n        if (isSubscription) {\n            checkError(response.params.error);\n            return response.params.result;\n        }\n        return response.result;\n    }\n    encodeJson(method, params) {\n        const [id, data] = this.encodeObject(method, params);\n        return [id, stringify(data)];\n    }\n    encodeObject(method, params) {\n        const id = ++this.#id;\n        return [id, {\n                id,\n                jsonrpc: '2.0',\n                method,\n                params\n            }];\n    }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;AAAA;AAAA;AACA;;;;;AACA,SAAS,gBAAgB,IAAI;IACzB,IAAI,IAAA,uKAAW,EAAC,OAAO;QACnB,OAAO;IACX;IACA,MAAM,YAAY,AAAC,KAEG,OAFC,IAAA,iKAAQ,EAAC,QAC1B,KAAK,OAAO,CAAC,aAAa,IAAI,OAAO,CAAC,QAAQ,KAAK,OAAO,CAAC,QAAQ,KAAK,OAAO,CAAC,OAAO,MAAM,OAAO,CAAC,OAAO,MAC5G,IAAA,+JAAS,EAAC;IAChB,sEAAsE;IACtE,+DAA+D;IAC/D,OAAO,UAAU,MAAM,IAAI,MACrB,YACA,AAAC,GAA8B,OAA5B,UAAU,SAAS,CAAC,GAAG,MAAK;AACzC;AACA,SAAS,WAAW,KAAK;IACrB,IAAI,OAAO;QACP,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE,GAAG;QAChC,MAAM,IAAI,6KAAQ,CAAC,AAAC,GAAW,OAAT,MAAK,MAAc,OAAV,SAAgC,OAAtB,gBAAgB,QAAS,MAAM;IAC5E;AACJ;IAGI;AADG,MAAM;IAET,eAAe,QAAQ,EAAE;QACrB,IAAI,CAAC,YAAY,SAAS,OAAO,KAAK,OAAO;YACzC,MAAM,IAAI,MAAM;QACpB;QACA,MAAM,iBAAiB,CAAC,IAAA,uKAAW,EAAC,SAAS,MAAM,KAAK,CAAC,IAAA,uKAAW,EAAC,SAAS,MAAM;QACpF,IAAI,CAAC,IAAA,iKAAQ,EAAC,SAAS,EAAE,KACrB,CAAC,CAAC,kBAAmB,CAAC,IAAA,iKAAQ,EAAC,SAAS,MAAM,CAAC,YAAY,KACvD,CAAC,IAAA,iKAAQ,EAAC,SAAS,MAAM,CAAC,YAAY,CAAE,GAAG;YAC/C,MAAM,IAAI,MAAM;QACpB;QACA,WAAW,SAAS,KAAK;QACzB,IAAI,SAAS,MAAM,KAAK,aAAa,CAAC,gBAAgB;YAClD,MAAM,IAAI,MAAM;QACpB;QACA,IAAI,gBAAgB;YAChB,WAAW,SAAS,MAAM,CAAC,KAAK;YAChC,OAAO,SAAS,MAAM,CAAC,MAAM;QACjC;QACA,OAAO,SAAS,MAAM;IAC1B;IACA,WAAW,MAAM,EAAE,MAAM,EAAE;QACvB,MAAM,CAAC,IAAI,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC,QAAQ;QAC7C,OAAO;YAAC;YAAI,IAAA,+JAAS,EAAC;SAAM;IAChC;IACA,aAAa,MAAM,EAAE,MAAM,EAAE;QACzB,MAAM,KAAK,sLAAE,IAAI,EAAC;QAClB,OAAO;YAAC;YAAI;gBACJ;gBACA,SAAS;gBACT;gBACA;YACJ;SAAE;IACV;;QAjCA,wLAAA;;mBAAM;;;AAkCV","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 145, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/rpc-provider/defaults.js"],"sourcesContent":["const HTTP_URL = 'http://127.0.0.1:9933';\nconst WS_URL = 'ws://127.0.0.1:9944';\nexport default {\n    HTTP_URL,\n    WS_URL\n};\n"],"names":[],"mappings":";;;;AAAA,MAAM,WAAW;AACjB,MAAM,SAAS;uCACA;IACX;IACA;AACJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 159, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/rpc-provider/lru.js"],"sourcesContent":["export const DEFAULT_CAPACITY = 1024;\nexport const DEFAULT_TTL = 30000; // 30 seconds\nconst MAX_TTL = 1800_000; // 30 minutes\nconst DISABLED_TTL = 31_536_000_000;\nclass LRUNode {\n    key;\n    #expires;\n    #ttl;\n    createdAt;\n    next;\n    prev;\n    constructor(key, ttl) {\n        this.key = key;\n        this.#ttl = ttl;\n        this.#expires = Date.now() + ttl;\n        this.createdAt = Date.now();\n        this.next = this.prev = this;\n    }\n    refresh() {\n        this.#expires = Date.now() + this.#ttl;\n    }\n    get expiry() {\n        return this.#expires;\n    }\n}\nexport class LRUCache {\n    capacity;\n    #data = new Map();\n    #refs = new Map();\n    #length = 0;\n    #head;\n    #tail;\n    #ttl;\n    constructor(capacity = DEFAULT_CAPACITY, ttl = DEFAULT_TTL) {\n        // Validate capacity\n        if (!Number.isInteger(capacity) || capacity < 0) {\n            throw new Error(`LRUCache initialization error: 'capacity' must be a non-negative integer. Received: ${capacity}`);\n        }\n        // Validate ttl\n        if (ttl !== null && (!Number.isFinite(ttl) || ttl < 0 || ttl > MAX_TTL)) {\n            throw new Error(`LRUCache initialization error: 'ttl' must be between 0 and ${MAX_TTL} ms or null to disable. Received: ${ttl}`);\n        }\n        this.capacity = capacity;\n        ttl ? this.#ttl = ttl : this.#ttl = DISABLED_TTL;\n        this.#head = this.#tail = new LRUNode('<empty>', this.#ttl);\n    }\n    get ttl() {\n        return this.#ttl;\n    }\n    get length() {\n        return this.#length;\n    }\n    get lengthData() {\n        return this.#data.size;\n    }\n    get lengthRefs() {\n        return this.#refs.size;\n    }\n    entries() {\n        const keys = this.keys();\n        const count = keys.length;\n        const entries = new Array(count);\n        for (let i = 0; i < count; i++) {\n            const key = keys[i];\n            entries[i] = [key, this.#data.get(key)];\n        }\n        return entries;\n    }\n    keys() {\n        const keys = [];\n        if (this.#length) {\n            let curr = this.#head;\n            while (curr !== this.#tail) {\n                keys.push(curr.key);\n                curr = curr.next;\n            }\n            keys.push(curr.key);\n        }\n        return keys;\n    }\n    get(key) {\n        const data = this.#data.get(key);\n        if (data) {\n            this.#toHead(key);\n            // Evict TTL once data is refreshed\n            this.#evictTTL();\n            return data;\n        }\n        this.#evictTTL();\n        return null;\n    }\n    set(key, value) {\n        if (this.#data.has(key)) {\n            this.#toHead(key);\n        }\n        else {\n            const node = new LRUNode(key, this.#ttl);\n            this.#refs.set(node.key, node);\n            if (this.length === 0) {\n                this.#head = this.#tail = node;\n            }\n            else {\n                this.#head.prev = node;\n                node.next = this.#head;\n                this.#head = node;\n            }\n            if (this.#length === this.capacity) {\n                this.#data.delete(this.#tail.key);\n                this.#refs.delete(this.#tail.key);\n                this.#tail = this.#tail.prev;\n                this.#tail.next = this.#head;\n            }\n            else {\n                this.#length += 1;\n            }\n        }\n        // Evict TTL once data is refreshed or added\n        this.#evictTTL();\n        this.#data.set(key, value);\n    }\n    #evictTTL() {\n        // Find last node to keep\n        // traverse map to find the expired nodes\n        while (this.#tail.expiry && this.#tail.expiry < Date.now() && this.#length > 0) {\n            this.#refs.delete(this.#tail.key);\n            this.#data.delete(this.#tail.key);\n            this.#length -= 1;\n            this.#tail = this.#tail.prev;\n            this.#tail.next = this.#head;\n        }\n        if (this.#length === 0) {\n            this.#head = this.#tail = new LRUNode('<empty>', this.#ttl);\n        }\n    }\n    #toHead(key) {\n        const ref = this.#refs.get(key);\n        if (ref && ref !== this.#head) {\n            ref.refresh();\n            ref.prev.next = ref.next;\n            ref.next.prev = ref.prev;\n            ref.next = this.#head;\n            this.#head.prev = ref;\n            this.#head = ref;\n        }\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 357, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/rpc-provider/http/index.js"],"sourcesContent":["import { logger, noop, stringify } from '@polkadot/util';\nimport { fetch } from '@polkadot/x-fetch';\nimport { RpcCoder } from '../coder/index.js';\nimport defaults from '../defaults.js';\nimport { DEFAULT_CAPACITY, DEFAULT_TTL, LRUCache } from '../lru.js';\nconst ERROR_SUBSCRIBE = 'HTTP Provider does not have subscriptions, use WebSockets instead';\nconst l = logger('api-http');\n/**\n * # @polkadot/rpc-provider\n *\n * @name HttpProvider\n *\n * @description The HTTP Provider allows sending requests using HTTP to a HTTP RPC server TCP port. It does not support subscriptions so you won't be able to listen to events such as new blocks or balance changes. It is usually preferable using the [[WsProvider]].\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Api from '@polkadot/api/promise';\n * import { HttpProvider } from '@polkadot/rpc-provider';\n *\n * const provider = new HttpProvider('http://127.0.0.1:9933');\n * const api = new Api(provider);\n * ```\n *\n * @see [[WsProvider]]\n */\nexport class HttpProvider {\n    #callCache;\n    #cacheCapacity;\n    #coder;\n    #endpoint;\n    #headers;\n    #stats;\n    #ttl;\n    /**\n     * @param {string} endpoint The endpoint url starting with http://\n     * @param {Record<string, string>} headers The headers provided to the underlying Http Endpoint\n     * @param {number} [cacheCapacity] Custom size of the HttpProvider LRUCache. Defaults to `DEFAULT_CAPACITY` (1024)\n     * @param {number} [cacheTtl] Custom TTL of the HttpProvider LRUCache. Determines how long an object can live in the cache. Defaults to `DEFAULT_TTL` (30000)\n     */\n    constructor(endpoint = defaults.HTTP_URL, headers = {}, cacheCapacity, cacheTtl) {\n        if (!/^(https|http):\\/\\//.test(endpoint)) {\n            throw new Error(`Endpoint should start with 'http://' or 'https://', received '${endpoint}'`);\n        }\n        this.#coder = new RpcCoder();\n        this.#endpoint = endpoint;\n        this.#headers = headers;\n        this.#cacheCapacity = cacheCapacity === 0 ? 0 : cacheCapacity || DEFAULT_CAPACITY;\n        const ttl = cacheTtl === undefined ? DEFAULT_TTL : cacheTtl;\n        this.#callCache = new LRUCache(cacheCapacity === 0 ? 0 : cacheCapacity || DEFAULT_CAPACITY, ttl);\n        this.#ttl = cacheTtl;\n        this.#stats = {\n            active: { requests: 0, subscriptions: 0 },\n            total: { bytesRecv: 0, bytesSent: 0, cached: 0, errors: 0, requests: 0, subscriptions: 0, timeout: 0 }\n        };\n    }\n    /**\n     * @summary `true` when this provider supports subscriptions\n     */\n    get hasSubscriptions() {\n        return !!false;\n    }\n    /**\n     * @description Returns a clone of the object\n     */\n    clone() {\n        return new HttpProvider(this.#endpoint, this.#headers);\n    }\n    /**\n     * @description Manually connect from the connection\n     */\n    async connect() {\n        // noop\n    }\n    /**\n     * @description Manually disconnect from the connection\n     */\n    async disconnect() {\n        // noop\n    }\n    /**\n     * @description Returns the connection stats\n     */\n    get stats() {\n        return this.#stats;\n    }\n    /**\n    * @description Returns the connection stats\n    */\n    get ttl() {\n        return this.#ttl;\n    }\n    /**\n     * @summary `true` when this provider supports clone()\n     */\n    get isClonable() {\n        return !!true;\n    }\n    /**\n     * @summary Whether the node is connected or not.\n     * @return {boolean} true if connected\n     */\n    get isConnected() {\n        return !!true;\n    }\n    /**\n     * @summary Events are not supported with the HttpProvider, see [[WsProvider]].\n     * @description HTTP Provider does not have 'on' emitters. WebSockets should be used instead.\n     */\n    on(_type, _sub) {\n        l.error('HTTP Provider does not have \\'on\\' emitters, use WebSockets instead');\n        return noop;\n    }\n    /**\n     * @summary Send HTTP POST Request with Body to configured HTTP Endpoint.\n     */\n    async send(method, params, isCacheable) {\n        this.#stats.total.requests++;\n        const [, body] = this.#coder.encodeJson(method, params);\n        if (this.#cacheCapacity === 0) {\n            return this.#send(body);\n        }\n        const cacheKey = isCacheable ? `${method}::${stringify(params)}` : '';\n        let resultPromise = isCacheable\n            ? this.#callCache.get(cacheKey)\n            : null;\n        if (!resultPromise) {\n            resultPromise = this.#send(body);\n            if (isCacheable) {\n                this.#callCache.set(cacheKey, resultPromise);\n            }\n        }\n        else {\n            this.#stats.total.cached++;\n        }\n        return resultPromise;\n    }\n    async #send(body) {\n        this.#stats.active.requests++;\n        this.#stats.total.bytesSent += body.length;\n        try {\n            const response = await fetch(this.#endpoint, {\n                body,\n                headers: {\n                    Accept: 'application/json',\n                    'Content-Length': `${body.length}`,\n                    'Content-Type': 'application/json',\n                    ...this.#headers\n                },\n                method: 'POST'\n            });\n            if (!response.ok) {\n                throw new Error(`[${response.status}]: ${response.statusText}`);\n            }\n            const result = await response.text();\n            this.#stats.total.bytesRecv += result.length;\n            const decoded = this.#coder.decodeResponse(JSON.parse(result));\n            this.#stats.active.requests--;\n            return decoded;\n        }\n        catch (e) {\n            this.#stats.active.requests--;\n            this.#stats.total.errors++;\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const { method, params } = JSON.parse(body);\n            const rpcError = e;\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const failedRequest = `\\nFailed HTTP Request: ${JSON.stringify({ method, params })}`;\n            // Provide HTTP Request alongside the error\n            rpcError.message = `${rpcError.message}${failedRequest}`;\n            throw rpcError;\n        }\n    }\n    /**\n     * @summary Subscriptions are not supported with the HttpProvider, see [[WsProvider]].\n     */\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async subscribe(_types, _method, _params, _cb) {\n        l.error(ERROR_SUBSCRIBE);\n        throw new Error(ERROR_SUBSCRIBE);\n    }\n    /**\n     * @summary Subscriptions are not supported with the HttpProvider, see [[WsProvider]].\n     */\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async unsubscribe(_type, _method, _id) {\n        l.error(ERROR_SUBSCRIBE);\n        throw new Error(ERROR_SUBSCRIBE);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 575, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/rpc-provider/substrate-connect/Health.js"],"sourcesContent":["import { stringify } from '@polkadot/util';\n/*\n * Creates a new health checker.\n *\n * The role of the health checker is to report to the user the health of a smoldot chain.\n *\n * In order to use it, start by creating a health checker, and call `setSendJsonRpc` to set the\n * way to send a JSON-RPC request to a chain. The health checker is disabled by default. Use\n * `start()` in order to start the health checks. The `start()` function must be passed a callback called\n * when an update to the health of the node is available.\n *\n * In order to send a JSON-RPC request to the chain, you **must** use the `sendJsonRpc` function\n * of the health checker. The health checker rewrites the `id` of the requests it receives.\n *\n * When the chain send a JSON-RPC response, it must be passed to `responsePassThrough()`. This\n * function intercepts the responses destined to the requests that have been emitted by the health\n * checker and returns `null`. If the response doesn't concern the health checker, the response is\n * simply returned by the function.\n *\n * # How it works\n *\n * The health checker periodically calls the `system_health` JSON-RPC call in order to determine\n * the health of the chain.\n *\n * In addition to this, as long as the health check reports that `isSyncing` is `true`, the\n * health checker also maintains a subscription to new best blocks using `chain_subscribeNewHeads`.\n * Whenever a new block is notified, a health check is performed immediately in order to determine\n * whether `isSyncing` has changed to `false`.\n *\n * Thanks to this subscription, the latency of the report of the switch from `isSyncing: true` to\n * `isSyncing: false` is very low.\n *\n */\nexport function healthChecker() {\n    // `null` if health checker is not started.\n    let checker = null;\n    let sendJsonRpc = null;\n    return {\n        responsePassThrough: (jsonRpcResponse) => {\n            if (checker === null) {\n                return jsonRpcResponse;\n            }\n            return checker.responsePassThrough(jsonRpcResponse);\n        },\n        sendJsonRpc: (request) => {\n            if (!sendJsonRpc) {\n                throw new Error('setSendJsonRpc must be called before sending requests');\n            }\n            if (checker === null) {\n                sendJsonRpc(request);\n            }\n            else {\n                checker.sendJsonRpc(request);\n            }\n        },\n        setSendJsonRpc: (cb) => {\n            sendJsonRpc = cb;\n        },\n        start: (healthCallback) => {\n            if (checker !== null) {\n                throw new Error(\"Can't start the health checker multiple times in parallel\");\n            }\n            else if (!sendJsonRpc) {\n                throw new Error('setSendJsonRpc must be called before starting the health checks');\n            }\n            checker = new InnerChecker(healthCallback, sendJsonRpc);\n            checker.update(true);\n        },\n        stop: () => {\n            if (checker === null) {\n                return;\n            } // Already stopped.\n            checker.destroy();\n            checker = null;\n        }\n    };\n}\nclass InnerChecker {\n    #healthCallback;\n    #currentHealthCheckId = null;\n    #currentHealthTimeout = null;\n    #currentSubunsubRequestId = null;\n    #currentSubscriptionId = null;\n    #requestToSmoldot;\n    #isSyncing = false;\n    #nextRequestId = 0;\n    constructor(healthCallback, requestToSmoldot) {\n        this.#healthCallback = healthCallback;\n        this.#requestToSmoldot = (request) => requestToSmoldot(stringify(request));\n    }\n    sendJsonRpc = (request) => {\n        // Replace the `id` in the request to prefix the request ID with `extern:`.\n        let parsedRequest;\n        try {\n            parsedRequest = JSON.parse(request);\n        }\n        catch {\n            return;\n        }\n        if (parsedRequest.id) {\n            const newId = 'extern:' + stringify(parsedRequest.id);\n            parsedRequest.id = newId;\n        }\n        this.#requestToSmoldot(parsedRequest);\n    };\n    responsePassThrough = (jsonRpcResponse) => {\n        let parsedResponse;\n        try {\n            parsedResponse = JSON.parse(jsonRpcResponse);\n        }\n        catch {\n            return jsonRpcResponse;\n        }\n        // Check whether response is a response to `system_health`.\n        if (parsedResponse.id && this.#currentHealthCheckId === parsedResponse.id) {\n            this.#currentHealthCheckId = null;\n            // Check whether query was successful. It is possible for queries to fail for\n            // various reasons, such as the client being overloaded.\n            if (!parsedResponse.result) {\n                this.update(false);\n                return null;\n            }\n            this.#healthCallback(parsedResponse.result);\n            this.#isSyncing = parsedResponse.result.isSyncing;\n            this.update(false);\n            return null;\n        }\n        // Check whether response is a response to the subscription or unsubscription.\n        if (parsedResponse.id &&\n            this.#currentSubunsubRequestId === parsedResponse.id) {\n            this.#currentSubunsubRequestId = null;\n            // Check whether query was successful. It is possible for queries to fail for\n            // various reasons, such as the client being overloaded.\n            if (!parsedResponse.result) {\n                this.update(false);\n                return null;\n            }\n            if (this.#currentSubscriptionId) {\n                this.#currentSubscriptionId = null;\n            }\n            else {\n                this.#currentSubscriptionId = parsedResponse.result;\n            }\n            this.update(false);\n            return null;\n        }\n        // Check whether response is a notification to a subscription.\n        if (parsedResponse.params &&\n            this.#currentSubscriptionId &&\n            parsedResponse.params.subscription === this.#currentSubscriptionId) {\n            // Note that after a successful subscription, a notification containing\n            // the current best block is always returned. Considering that a\n            // subscription is performed in response to a health check, calling\n            // `startHealthCheck()` here will lead to a second health check.\n            // It might seem redundant to perform two health checks in a quick\n            // succession, but doing so doesn't lead to any problem, and it is\n            // actually possible for the health to have changed in between as the\n            // current best block might have been updated during the subscription\n            // request.\n            this.update(true);\n            return null;\n        }\n        // Response doesn't concern us.\n        if (parsedResponse.id) {\n            const id = parsedResponse.id;\n            // Need to remove the `extern:` prefix.\n            if (!id.startsWith('extern:')) {\n                throw new Error('State inconsistency in health checker');\n            }\n            const newId = JSON.parse(id.slice('extern:'.length));\n            parsedResponse.id = newId;\n        }\n        return stringify(parsedResponse);\n    };\n    update = (startNow) => {\n        // If `startNow`, clear `#currentHealthTimeout` so that it is set below.\n        if (startNow && this.#currentHealthTimeout) {\n            clearTimeout(this.#currentHealthTimeout);\n            this.#currentHealthTimeout = null;\n        }\n        if (!this.#currentHealthTimeout) {\n            const startHealthRequest = () => {\n                this.#currentHealthTimeout = null;\n                // No matter what, don't start a health request if there is already one in progress.\n                // This is sane to do because receiving a response to a health request calls `update()`.\n                if (this.#currentHealthCheckId) {\n                    return;\n                }\n                // Actual request starting.\n                this.#currentHealthCheckId = `health-checker:${this.#nextRequestId}`;\n                this.#nextRequestId += 1;\n                this.#requestToSmoldot({\n                    id: this.#currentHealthCheckId,\n                    jsonrpc: '2.0',\n                    method: 'system_health',\n                    params: []\n                });\n            };\n            if (startNow) {\n                startHealthRequest();\n            }\n            else {\n                this.#currentHealthTimeout = setTimeout(startHealthRequest, 1000);\n            }\n        }\n        if (this.#isSyncing &&\n            !this.#currentSubscriptionId &&\n            !this.#currentSubunsubRequestId) {\n            this.startSubscription();\n        }\n        if (!this.#isSyncing &&\n            this.#currentSubscriptionId &&\n            !this.#currentSubunsubRequestId) {\n            this.endSubscription();\n        }\n    };\n    startSubscription = () => {\n        if (this.#currentSubunsubRequestId || this.#currentSubscriptionId) {\n            throw new Error('Internal error in health checker');\n        }\n        this.#currentSubunsubRequestId = `health-checker:${this.#nextRequestId}`;\n        this.#nextRequestId += 1;\n        this.#requestToSmoldot({\n            id: this.#currentSubunsubRequestId,\n            jsonrpc: '2.0',\n            method: 'chain_subscribeNewHeads',\n            params: []\n        });\n    };\n    endSubscription = () => {\n        if (this.#currentSubunsubRequestId || !this.#currentSubscriptionId) {\n            throw new Error('Internal error in health checker');\n        }\n        this.#currentSubunsubRequestId = `health-checker:${this.#nextRequestId}`;\n        this.#nextRequestId += 1;\n        this.#requestToSmoldot({\n            id: this.#currentSubunsubRequestId,\n            jsonrpc: '2.0',\n            method: 'chain_unsubscribeNewHeads',\n            params: [this.#currentSubscriptionId]\n        });\n    };\n    destroy = () => {\n        if (this.#currentHealthTimeout) {\n            clearTimeout(this.#currentHealthTimeout);\n            this.#currentHealthTimeout = null;\n        }\n    };\n}\nexport class HealthCheckError extends Error {\n    #cause;\n    getCause() {\n        return this.#cause;\n    }\n    constructor(response, message = 'Got error response asking for system health') {\n        super(message);\n        this.#cause = response;\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 838, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/rpc-provider/substrate-connect/index.js"],"sourcesContent":["import { EventEmitter } from 'eventemitter3';\nimport { isError, isFunction, isObject, logger, noop, objectSpread } from '@polkadot/util';\nimport { RpcCoder } from '../coder/index.js';\nimport { healthChecker } from './Health.js';\nconst l = logger('api-substrate-connect');\nconst subscriptionUnsubscriptionMethods = new Map([\n    ['author_submitAndWatchExtrinsic', 'author_unwatchExtrinsic'],\n    ['chain_subscribeAllHeads', 'chain_unsubscribeAllHeads'],\n    ['chain_subscribeFinalizedHeads', 'chain_unsubscribeFinalizedHeads'],\n    ['chain_subscribeFinalisedHeads', 'chain_subscribeFinalisedHeads'],\n    ['chain_subscribeNewHeads', 'chain_unsubscribeNewHeads'],\n    ['chain_subscribeNewHead', 'chain_unsubscribeNewHead'],\n    ['chain_subscribeRuntimeVersion', 'chain_unsubscribeRuntimeVersion'],\n    ['subscribe_newHead', 'unsubscribe_newHead'],\n    ['state_subscribeRuntimeVersion', 'state_unsubscribeRuntimeVersion'],\n    ['state_subscribeStorage', 'state_unsubscribeStorage']\n]);\nconst scClients = new WeakMap();\nexport class ScProvider {\n    #Sc;\n    #coder = new RpcCoder();\n    #spec;\n    #sharedSandbox;\n    #subscriptions = new Map();\n    #resubscribeMethods = new Map();\n    #requests = new Map();\n    #wellKnownChains;\n    #eventemitter = new EventEmitter();\n    #chain = null;\n    #isChainReady = false;\n    constructor(Sc, spec, sharedSandbox) {\n        if (!isObject(Sc) || !isObject(Sc.WellKnownChain) || !isFunction(Sc.createScClient)) {\n            throw new Error('Expected an @substrate/connect interface as first parameter to ScProvider');\n        }\n        this.#Sc = Sc;\n        this.#spec = spec;\n        this.#sharedSandbox = sharedSandbox;\n        this.#wellKnownChains = new Set(Object.values(Sc.WellKnownChain));\n    }\n    get hasSubscriptions() {\n        // Indicates that subscriptions are supported\n        return !!true;\n    }\n    get isClonable() {\n        return !!false;\n    }\n    get isConnected() {\n        return !!this.#chain && this.#isChainReady;\n    }\n    clone() {\n        throw new Error('clone() is not supported.');\n    }\n    // Config details can be found in @substrate/connect repo following the link:\n    // https://github.com/paritytech/substrate-connect/blob/main/packages/connect/src/connector/index.ts\n    async connect(config, checkerFactory = healthChecker) {\n        if (this.isConnected) {\n            throw new Error('Already connected!');\n        }\n        // it could happen that after emitting `disconnected` due to the fact that\n        // smoldot is syncing, the consumer tries to reconnect after a certain amount\n        // of time... In which case we want to make sure that we don't create a new\n        // chain.\n        if (this.#chain) {\n            await this.#chain;\n            return;\n        }\n        if (this.#sharedSandbox && !this.#sharedSandbox.isConnected) {\n            await this.#sharedSandbox.connect();\n        }\n        const client = this.#sharedSandbox\n            ? scClients.get(this.#sharedSandbox)\n            : this.#Sc.createScClient(config);\n        if (!client) {\n            throw new Error('Unknown ScProvider!');\n        }\n        scClients.set(this, client);\n        const hc = checkerFactory();\n        const onResponse = (res) => {\n            const hcRes = hc.responsePassThrough(res);\n            if (!hcRes) {\n                return;\n            }\n            const response = JSON.parse(hcRes);\n            let decodedResponse;\n            try {\n                decodedResponse = this.#coder.decodeResponse(response);\n            }\n            catch (e) {\n                decodedResponse = e;\n            }\n            // It's not a subscription message, but rather a standar RPC response\n            if (response.params?.subscription === undefined || !response.method) {\n                return this.#requests.get(response.id)?.(decodedResponse);\n            }\n            // We are dealing with a subscription message\n            const subscriptionId = `${response.method}::${response.params.subscription}`;\n            const callback = this.#subscriptions.get(subscriptionId)?.[0];\n            callback?.(decodedResponse);\n        };\n        const addChain = this.#sharedSandbox\n            ? (async (...args) => {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const source = this.#sharedSandbox;\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                return (await source.#chain).addChain(...args);\n            })\n            : this.#wellKnownChains.has(this.#spec)\n                ? client.addWellKnownChain\n                : client.addChain;\n        this.#chain = addChain(this.#spec, onResponse).then((chain) => {\n            hc.setSendJsonRpc(chain.sendJsonRpc);\n            this.#isChainReady = false;\n            const cleanup = () => {\n                // If there are any callbacks left, we have to reject/error them.\n                // Otherwise, that would cause a memory leak.\n                const disconnectionError = new Error('Disconnected');\n                this.#requests.forEach((cb) => cb(disconnectionError));\n                this.#subscriptions.forEach(([cb]) => cb(disconnectionError));\n                this.#subscriptions.clear();\n            };\n            const staleSubscriptions = [];\n            const killStaleSubscriptions = () => {\n                if (staleSubscriptions.length === 0) {\n                    return;\n                }\n                const stale = staleSubscriptions.pop();\n                if (!stale) {\n                    throw new Error('Unable to get stale subscription');\n                }\n                const { id, unsubscribeMethod } = stale;\n                Promise\n                    .race([\n                    this.send(unsubscribeMethod, [id]).catch(noop),\n                    new Promise((resolve) => setTimeout(resolve, 500))\n                ])\n                    .then(killStaleSubscriptions)\n                    .catch(noop);\n            };\n            hc.start((health) => {\n                const isReady = !health.isSyncing && (health.peers > 0 || !health.shouldHavePeers);\n                // if it's the same as before, then nothing has changed and we are done\n                if (this.#isChainReady === isReady) {\n                    return;\n                }\n                this.#isChainReady = isReady;\n                if (!isReady) {\n                    // If we've reached this point, that means that the chain used to be \"ready\"\n                    // and now we are about to emit `disconnected`.\n                    //\n                    // This will cause the PolkadotJs API think that the connection is\n                    // actually dead. In reality the smoldot chain is not dead, of course.\n                    // However, we have to cleanup all the existing callbacks because when\n                    // the smoldot chain stops syncing, then we will emit `connected` and\n                    // the PolkadotJs API will try to re-create the previous\n                    // subscriptions and requests. Although, now is not a good moment\n                    // to be sending unsubscription messages to the smoldot chain, we\n                    // should wait until is no longer syncing to send the unsubscription\n                    // messages from the stale subscriptions of the previous connection.\n                    //\n                    // That's why -before we perform the cleanup of `this.#subscriptions`-\n                    // we keep the necessary information that we will need later on to\n                    // kill the stale subscriptions.\n                    [...this.#subscriptions.values()].forEach((s) => {\n                        staleSubscriptions.push(s[1]);\n                    });\n                    cleanup();\n                    this.#eventemitter.emit('disconnected');\n                }\n                else {\n                    killStaleSubscriptions();\n                    this.#eventemitter.emit('connected');\n                    if (this.#resubscribeMethods.size) {\n                        this.#resubscribe();\n                    }\n                }\n            });\n            return objectSpread({}, chain, {\n                remove: () => {\n                    hc.stop();\n                    chain.remove();\n                    cleanup();\n                },\n                sendJsonRpc: hc.sendJsonRpc.bind(hc)\n            });\n        });\n        try {\n            await this.#chain;\n        }\n        catch (e) {\n            this.#chain = null;\n            this.#eventemitter.emit('error', e);\n            throw e;\n        }\n    }\n    #resubscribe = () => {\n        const promises = [];\n        this.#resubscribeMethods.forEach((subDetails) => {\n            // only re-create subscriptions which are not in author (only area where\n            // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'\n            // are not included (and will not be re-broadcast)\n            if (subDetails.type.startsWith('author_')) {\n                return;\n            }\n            try {\n                const promise = new Promise((resolve) => {\n                    this.subscribe(subDetails.type, subDetails.method, subDetails.params, subDetails.callback).catch((error) => console.log(error));\n                    resolve();\n                });\n                promises.push(promise);\n            }\n            catch (error) {\n                l.error(error);\n            }\n        });\n        Promise.all(promises).catch((err) => l.log(err));\n    };\n    async disconnect() {\n        if (!this.#chain) {\n            return;\n        }\n        const chain = await this.#chain;\n        this.#chain = null;\n        this.#isChainReady = false;\n        try {\n            chain.remove();\n        }\n        catch (_) { }\n        this.#eventemitter.emit('disconnected');\n    }\n    on(type, sub) {\n        // It's possible. Although, quite unlikely, that by the time that polkadot\n        // subscribes to the `connected` event, the Provider is already connected.\n        // In that case, we must emit to let the consumer know that we are connected.\n        if (type === 'connected' && this.isConnected) {\n            sub();\n        }\n        this.#eventemitter.on(type, sub);\n        return () => {\n            this.#eventemitter.removeListener(type, sub);\n        };\n    }\n    async send(method, params) {\n        if (!this.isConnected || !this.#chain) {\n            throw new Error('Provider is not connected');\n        }\n        const chain = await this.#chain;\n        const [id, json] = this.#coder.encodeJson(method, params);\n        const result = new Promise((resolve, reject) => {\n            this.#requests.set(id, (response) => {\n                (isError(response) ? reject : resolve)(response);\n            });\n            try {\n                chain.sendJsonRpc(json);\n            }\n            catch (e) {\n                this.#chain = null;\n                try {\n                    chain.remove();\n                }\n                catch (_) { }\n                this.#eventemitter.emit('error', e);\n            }\n        });\n        try {\n            return await result;\n        }\n        finally {\n            // let's ensure that once the Promise is resolved/rejected, then we remove\n            // remove its entry from the internal #requests\n            this.#requests.delete(id);\n        }\n    }\n    async subscribe(type, method, params, callback) {\n        if (!subscriptionUnsubscriptionMethods.has(method)) {\n            throw new Error(`Unsupported subscribe method: ${method}`);\n        }\n        const id = await this.send(method, params);\n        const subscriptionId = `${type}::${id}`;\n        const cb = (response) => {\n            if (response instanceof Error) {\n                callback(response, undefined);\n            }\n            else {\n                callback(null, response);\n            }\n        };\n        const unsubscribeMethod = subscriptionUnsubscriptionMethods.get(method);\n        if (!unsubscribeMethod) {\n            throw new Error('Invalid unsubscribe method found');\n        }\n        this.#resubscribeMethods.set(subscriptionId, { callback, method, params, type });\n        this.#subscriptions.set(subscriptionId, [cb, { id, unsubscribeMethod }]);\n        return id;\n    }\n    unsubscribe(type, method, id) {\n        if (!this.isConnected) {\n            throw new Error('Provider is not connected');\n        }\n        const subscriptionId = `${type}::${id}`;\n        if (!this.#subscriptions.has(subscriptionId)) {\n            return Promise.reject(new Error(`Unable to find active subscription=${subscriptionId}`));\n        }\n        this.#resubscribeMethods.delete(subscriptionId);\n        this.#subscriptions.delete(subscriptionId);\n        return this.send(method, [id]);\n    }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1245, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/rpc-provider/ws/errors.js"],"sourcesContent":["const known = {\n    1000: 'Normal Closure',\n    1001: 'Going Away',\n    1002: 'Protocol Error',\n    1003: 'Unsupported Data',\n    1004: '(For future)',\n    1005: 'No Status Received',\n    1006: 'Abnormal Closure',\n    1007: 'Invalid frame payload data',\n    1008: 'Policy Violation',\n    1009: 'Message too big',\n    1010: 'Missing Extension',\n    1011: 'Internal Error',\n    1012: 'Service Restart',\n    1013: 'Try Again Later',\n    1014: 'Bad Gateway',\n    1015: 'TLS Handshake'\n};\nexport function getWSErrorString(code) {\n    if (code >= 0 && code <= 999) {\n        return '(Unused)';\n    }\n    else if (code >= 1016) {\n        if (code <= 1999) {\n            return '(For WebSocket standard)';\n        }\n        else if (code <= 2999) {\n            return '(For WebSocket extensions)';\n        }\n        else if (code <= 3999) {\n            return '(For libraries and frameworks)';\n        }\n        else if (code <= 4999) {\n            return '(For applications)';\n        }\n    }\n    return known[code] || '(Unknown)';\n}\n"],"names":[],"mappings":";;;;AAAA,MAAM,QAAQ;IACV,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM;AACV;AACO,SAAS,iBAAiB,IAAI;IACjC,IAAI,QAAQ,KAAK,QAAQ,KAAK;QAC1B,OAAO;IACX,OACK,IAAI,QAAQ,MAAM;QACnB,IAAI,QAAQ,MAAM;YACd,OAAO;QACX,OACK,IAAI,QAAQ,MAAM;YACnB,OAAO;QACX,OACK,IAAI,QAAQ,MAAM;YACnB,OAAO;QACX,OACK,IAAI,QAAQ,MAAM;YACnB,OAAO;QACX;IACJ;IACA,OAAO,KAAK,CAAC,KAAK,IAAI;AAC1B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1287, "column": 0}, "map": {"version":3,"sources":["file:///Users/mark/SplitWiseX/frontend/node_modules/%40polkadot/rpc-provider/ws/index.js"],"sourcesContent":["import { EventEmitter } from 'eventemitter3';\nimport { isChildClass, isNull, isUndefined, logger, noop, objectSpread, stringify } from '@polkadot/util';\nimport { xglobal } from '@polkadot/x-global';\nimport { WebSocket } from '@polkadot/x-ws';\nimport { RpcCoder } from '../coder/index.js';\nimport defaults from '../defaults.js';\nimport { DEFAULT_CAPACITY, DEFAULT_TTL, LRUCache } from '../lru.js';\nimport { getWSErrorString } from './errors.js';\nconst ALIASES = {\n    chain_finalisedHead: 'chain_finalizedHead',\n    chain_subscribeFinalisedHeads: 'chain_subscribeFinalizedHeads',\n    chain_unsubscribeFinalisedHeads: 'chain_unsubscribeFinalizedHeads'\n};\nconst RETRY_DELAY = 2_500;\nconst DEFAULT_TIMEOUT_MS = 60 * 1000;\nconst TIMEOUT_INTERVAL = 5_000;\nconst l = logger('api-ws');\n/** @internal Clears a Record<*> of all keys, optionally with all callback on clear */\nfunction eraseRecord(record, cb) {\n    Object.keys(record).forEach((key) => {\n        if (cb) {\n            cb(record[key]);\n        }\n        delete record[key];\n    });\n}\n/** @internal Creates a default/empty stats object */\nfunction defaultEndpointStats() {\n    return { bytesRecv: 0, bytesSent: 0, cached: 0, errors: 0, requests: 0, subscriptions: 0, timeout: 0 };\n}\n/**\n * # @polkadot/rpc-provider/ws\n *\n * @name WsProvider\n *\n * @description The WebSocket Provider allows sending requests using WebSocket to a WebSocket RPC server TCP port. Unlike the [[HttpProvider]], it does support subscriptions and allows listening to events such as new blocks or balance changes.\n *\n * @example\n * <BR>\n *\n * ```javascript\n * import Api from '@polkadot/api/promise';\n * import { WsProvider } from '@polkadot/rpc-provider/ws';\n *\n * const provider = new WsProvider('ws://127.0.0.1:9944');\n * const api = new Api(provider);\n * ```\n *\n * @see [[HttpProvider]]\n */\nexport class WsProvider {\n    #callCache;\n    #coder;\n    #endpoints;\n    #headers;\n    #eventemitter;\n    #handlers = {};\n    #isReadyPromise;\n    #stats;\n    #waitingForId = {};\n    #cacheCapacity;\n    #ttl;\n    #autoConnectMs;\n    #endpointIndex;\n    #endpointStats;\n    #isConnected = false;\n    #subscriptions = {};\n    #timeoutId = null;\n    #websocket;\n    #timeout;\n    /**\n     * @param {string | string[]} endpoint The endpoint url. Usually `ws://ip:9944` or `wss://ip:9944`, may provide an array of endpoint strings.\n     * @param {number | false} autoConnectMs Whether to connect automatically or not (default). Provided value is used as a delay between retries.\n     * @param {Record<string, string>} headers The headers provided to the underlying WebSocket\n     * @param {number} [timeout] Custom timeout value used per request . Defaults to `DEFAULT_TIMEOUT_MS`\n     * @param {number} [cacheCapacity] Custom size of the WsProvider LRUCache. Defaults to `DEFAULT_CAPACITY` (1024)\n     * @param {number} [cacheTtl] Custom TTL of the WsProvider LRUCache. Determines how long an object can live in the cache. Defaults to DEFAULT_TTL` (30000)\n     */\n    constructor(endpoint = defaults.WS_URL, autoConnectMs = RETRY_DELAY, headers = {}, timeout, cacheCapacity, cacheTtl) {\n        const endpoints = Array.isArray(endpoint)\n            ? endpoint\n            : [endpoint];\n        if (endpoints.length === 0) {\n            throw new Error('WsProvider requires at least one Endpoint');\n        }\n        endpoints.forEach((endpoint) => {\n            if (!/^(wss|ws):\\/\\//.test(endpoint)) {\n                throw new Error(`Endpoint should start with 'ws://', received '${endpoint}'`);\n            }\n        });\n        const ttl = cacheTtl === undefined ? DEFAULT_TTL : cacheTtl;\n        this.#callCache = new LRUCache(cacheCapacity === 0 ? 0 : cacheCapacity || DEFAULT_CAPACITY, ttl);\n        this.#ttl = cacheTtl;\n        this.#cacheCapacity = cacheCapacity || DEFAULT_CAPACITY;\n        this.#eventemitter = new EventEmitter();\n        this.#autoConnectMs = autoConnectMs || 0;\n        this.#coder = new RpcCoder();\n        this.#endpointIndex = -1;\n        this.#endpoints = endpoints;\n        this.#headers = headers;\n        this.#websocket = null;\n        this.#stats = {\n            active: { requests: 0, subscriptions: 0 },\n            total: defaultEndpointStats()\n        };\n        this.#endpointStats = defaultEndpointStats();\n        this.#timeout = timeout || DEFAULT_TIMEOUT_MS;\n        if (autoConnectMs && autoConnectMs > 0) {\n            this.connectWithRetry().catch(noop);\n        }\n        this.#isReadyPromise = new Promise((resolve) => {\n            this.#eventemitter.once('connected', () => {\n                resolve(this);\n            });\n        });\n    }\n    /**\n     * @summary `true` when this provider supports subscriptions\n     */\n    get hasSubscriptions() {\n        return !!true;\n    }\n    /**\n     * @summary `true` when this provider supports clone()\n     */\n    get isClonable() {\n        return !!true;\n    }\n    /**\n     * @summary Whether the node is connected or not.\n     * @return {boolean} true if connected\n     */\n    get isConnected() {\n        return this.#isConnected;\n    }\n    /**\n     * @description Promise that resolves the first time we are connected and loaded\n     */\n    get isReady() {\n        return this.#isReadyPromise;\n    }\n    get endpoint() {\n        return this.#endpoints[this.#endpointIndex];\n    }\n    /**\n     * @description Returns a clone of the object\n     */\n    clone() {\n        return new WsProvider(this.#endpoints);\n    }\n    selectEndpointIndex(endpoints) {\n        return (this.#endpointIndex + 1) % endpoints.length;\n    }\n    /**\n     * @summary Manually connect\n     * @description The [[WsProvider]] connects automatically by default, however if you decided otherwise, you may\n     * connect manually using this method.\n     */\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async connect() {\n        if (this.#websocket) {\n            throw new Error('WebSocket is already connected');\n        }\n        try {\n            this.#endpointIndex = this.selectEndpointIndex(this.#endpoints);\n            // the as here is Deno-specific - not available on the globalThis\n            this.#websocket = typeof xglobal.WebSocket !== 'undefined' && isChildClass(xglobal.WebSocket, WebSocket)\n                ? new WebSocket(this.endpoint)\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore - WS may be an instance of ws, which supports options\n                : new WebSocket(this.endpoint, undefined, {\n                    headers: this.#headers\n                });\n            if (this.#websocket) {\n                this.#websocket.onclose = this.#onSocketClose;\n                this.#websocket.onerror = this.#onSocketError;\n                this.#websocket.onmessage = this.#onSocketMessage;\n                this.#websocket.onopen = this.#onSocketOpen;\n            }\n            // timeout any handlers that have not had a response\n            this.#timeoutId = setInterval(() => this.#timeoutHandlers(), TIMEOUT_INTERVAL);\n        }\n        catch (error) {\n            l.error(error);\n            this.#emit('error', error);\n            throw error;\n        }\n    }\n    /**\n     * @description Connect, never throwing an error, but rather forcing a retry\n     */\n    async connectWithRetry() {\n        if (this.#autoConnectMs > 0) {\n            try {\n                await this.connect();\n            }\n            catch {\n                setTimeout(() => {\n                    this.connectWithRetry().catch(noop);\n                }, this.#autoConnectMs);\n            }\n        }\n    }\n    /**\n     * @description Manually disconnect from the connection, clearing auto-connect logic\n     */\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async disconnect() {\n        // switch off autoConnect, we are in manual mode now\n        this.#autoConnectMs = 0;\n        try {\n            if (this.#websocket) {\n                // 1000 - Normal closure; the connection successfully completed\n                this.#websocket.close(1000);\n            }\n        }\n        catch (error) {\n            l.error(error);\n            this.#emit('error', error);\n            throw error;\n        }\n    }\n    /**\n     * @description Returns the connection stats\n     */\n    get stats() {\n        return {\n            active: {\n                requests: Object.keys(this.#handlers).length,\n                subscriptions: Object.keys(this.#subscriptions).length\n            },\n            total: this.#stats.total\n        };\n    }\n    /**\n    * @description Returns the connection stats\n    */\n    get ttl() {\n        return this.#ttl;\n    }\n    get endpointStats() {\n        return this.#endpointStats;\n    }\n    /**\n     * @summary Listens on events after having subscribed using the [[subscribe]] function.\n     * @param  {ProviderInterfaceEmitted} type Event\n     * @param  {ProviderInterfaceEmitCb}  sub  Callback\n     * @return unsubscribe function\n     */\n    on(type, sub) {\n        this.#eventemitter.on(type, sub);\n        return () => {\n            this.#eventemitter.removeListener(type, sub);\n        };\n    }\n    /**\n     * @summary Send JSON data using WebSockets to configured HTTP Endpoint or queue.\n     * @param method The RPC methods to execute\n     * @param params Encoded parameters as applicable for the method\n     * @param subscription Subscription details (internally used)\n     */\n    send(method, params, isCacheable, subscription) {\n        this.#endpointStats.requests++;\n        this.#stats.total.requests++;\n        const [id, body] = this.#coder.encodeJson(method, params);\n        if (this.#cacheCapacity === 0) {\n            return this.#send(id, body, method, params, subscription);\n        }\n        const cacheKey = isCacheable ? `${method}::${stringify(params)}` : '';\n        let resultPromise = isCacheable\n            ? this.#callCache.get(cacheKey)\n            : null;\n        if (!resultPromise) {\n            resultPromise = this.#send(id, body, method, params, subscription);\n            if (isCacheable) {\n                this.#callCache.set(cacheKey, resultPromise);\n            }\n        }\n        else {\n            this.#endpointStats.cached++;\n            this.#stats.total.cached++;\n        }\n        return resultPromise;\n    }\n    async #send(id, body, method, params, subscription) {\n        return new Promise((resolve, reject) => {\n            try {\n                if (!this.isConnected || this.#websocket === null) {\n                    throw new Error('WebSocket is not connected');\n                }\n                const callback = (error, result) => {\n                    error\n                        ? reject(error)\n                        : resolve(result);\n                };\n                l.debug(() => ['calling', method, body]);\n                this.#handlers[id] = {\n                    callback,\n                    method,\n                    params,\n                    start: Date.now(),\n                    subscription\n                };\n                const bytesSent = body.length;\n                this.#endpointStats.bytesSent += bytesSent;\n                this.#stats.total.bytesSent += bytesSent;\n                this.#websocket.send(body);\n            }\n            catch (error) {\n                this.#endpointStats.errors++;\n                this.#stats.total.errors++;\n                const rpcError = error;\n                const failedRequest = `\\nFailed WS Request: ${JSON.stringify({ method, params })}`;\n                // Provide WS Request alongside the error\n                rpcError.message = `${rpcError.message}${failedRequest}`;\n                reject(rpcError);\n            }\n        });\n    }\n    /**\n     * @name subscribe\n     * @summary Allows subscribing to a specific event.\n     *\n     * @example\n     * <BR>\n     *\n     * ```javascript\n     * const provider = new WsProvider('ws://127.0.0.1:9944');\n     * const rpc = new Rpc(provider);\n     *\n     * rpc.state.subscribeStorage([[storage.system.account, <Address>]], (_, values) => {\n     *   console.log(values)\n     * }).then((subscriptionId) => {\n     *   console.log('balance changes subscription id: ', subscriptionId)\n     * })\n     * ```\n     */\n    subscribe(type, method, params, callback) {\n        this.#endpointStats.subscriptions++;\n        this.#stats.total.subscriptions++;\n        // subscriptions are not cached, LRU applies to .at(<blockHash>) only\n        return this.send(method, params, false, { callback, type });\n    }\n    /**\n     * @summary Allows unsubscribing to subscriptions made with [[subscribe]].\n     */\n    async unsubscribe(type, method, id) {\n        const subscription = `${type}::${id}`;\n        // FIXME This now could happen with re-subscriptions. The issue is that with a re-sub\n        // the assigned id now does not match what the API user originally received. It has\n        // a slight complication in solving - since we cannot rely on the send id, but rather\n        // need to find the actual subscription id to map it\n        if (isUndefined(this.#subscriptions[subscription])) {\n            l.debug(() => `Unable to find active subscription=${subscription}`);\n            return false;\n        }\n        delete this.#subscriptions[subscription];\n        try {\n            return this.isConnected && !isNull(this.#websocket)\n                ? this.send(method, [id])\n                : true;\n        }\n        catch {\n            return false;\n        }\n    }\n    #emit = (type, ...args) => {\n        this.#eventemitter.emit(type, ...args);\n    };\n    #onSocketClose = (event) => {\n        const error = new Error(`disconnected from ${this.endpoint}: ${event.code}:: ${event.reason || getWSErrorString(event.code)}`);\n        if (this.#autoConnectMs > 0) {\n            l.error(error.message);\n        }\n        this.#isConnected = false;\n        if (this.#websocket) {\n            this.#websocket.onclose = null;\n            this.#websocket.onerror = null;\n            this.#websocket.onmessage = null;\n            this.#websocket.onopen = null;\n            this.#websocket = null;\n        }\n        if (this.#timeoutId) {\n            clearInterval(this.#timeoutId);\n            this.#timeoutId = null;\n        }\n        // reject all hanging requests\n        eraseRecord(this.#handlers, (h) => {\n            try {\n                h.callback(error, undefined);\n            }\n            catch (err) {\n                // does not throw\n                l.error(err);\n            }\n        });\n        eraseRecord(this.#waitingForId);\n        // Reset stats for active endpoint\n        this.#endpointStats = defaultEndpointStats();\n        this.#emit('disconnected');\n        if (this.#autoConnectMs > 0) {\n            setTimeout(() => {\n                this.connectWithRetry().catch(noop);\n            }, this.#autoConnectMs);\n        }\n    };\n    #onSocketError = (error) => {\n        l.debug(() => ['socket error', error]);\n        this.#emit('error', error);\n    };\n    #onSocketMessage = (message) => {\n        l.debug(() => ['received', message.data]);\n        const bytesRecv = message.data.length;\n        this.#endpointStats.bytesRecv += bytesRecv;\n        this.#stats.total.bytesRecv += bytesRecv;\n        const response = JSON.parse(message.data);\n        return isUndefined(response.method)\n            ? this.#onSocketMessageResult(response)\n            : this.#onSocketMessageSubscribe(response);\n    };\n    #onSocketMessageResult = (response) => {\n        const handler = this.#handlers[response.id];\n        if (!handler) {\n            l.debug(() => `Unable to find handler for id=${response.id}`);\n            return;\n        }\n        try {\n            const { method, params, subscription } = handler;\n            const result = this.#coder.decodeResponse(response);\n            // first send the result - in case of subs, we may have an update\n            // immediately if we have some queued results already\n            handler.callback(null, result);\n            if (subscription) {\n                const subId = `${subscription.type}::${result}`;\n                this.#subscriptions[subId] = objectSpread({}, subscription, {\n                    method,\n                    params\n                });\n                // if we have a result waiting for this subscription already\n                if (this.#waitingForId[subId]) {\n                    this.#onSocketMessageSubscribe(this.#waitingForId[subId]);\n                }\n            }\n        }\n        catch (error) {\n            this.#endpointStats.errors++;\n            this.#stats.total.errors++;\n            handler.callback(error, undefined);\n        }\n        delete this.#handlers[response.id];\n    };\n    #onSocketMessageSubscribe = (response) => {\n        if (!response.method) {\n            throw new Error('No method found in JSONRPC response');\n        }\n        const method = ALIASES[response.method] || response.method;\n        const subId = `${method}::${response.params.subscription}`;\n        const handler = this.#subscriptions[subId];\n        if (!handler) {\n            // store the JSON, we could have out-of-order subid coming in\n            this.#waitingForId[subId] = response;\n            l.debug(() => `Unable to find handler for subscription=${subId}`);\n            return;\n        }\n        // housekeeping\n        delete this.#waitingForId[subId];\n        try {\n            const result = this.#coder.decodeResponse(response);\n            handler.callback(null, result);\n        }\n        catch (error) {\n            this.#endpointStats.errors++;\n            this.#stats.total.errors++;\n            handler.callback(error, undefined);\n        }\n    };\n    #onSocketOpen = () => {\n        if (this.#websocket === null) {\n            throw new Error('WebSocket cannot be null in onOpen');\n        }\n        l.debug(() => ['connected to', this.endpoint]);\n        this.#isConnected = true;\n        this.#resubscribe();\n        this.#emit('connected');\n        return true;\n    };\n    #resubscribe = () => {\n        const subscriptions = this.#subscriptions;\n        this.#subscriptions = {};\n        Promise.all(Object.keys(subscriptions).map(async (id) => {\n            const { callback, method, params, type } = subscriptions[id];\n            // only re-create subscriptions which are not in author (only area where\n            // transactions are created, i.e. submissions such as 'author_submitAndWatchExtrinsic'\n            // are not included (and will not be re-broadcast)\n            if (type.startsWith('author_')) {\n                return;\n            }\n            try {\n                await this.subscribe(type, method, params, callback);\n            }\n            catch (error) {\n                l.error(error);\n            }\n        })).catch(l.error);\n    };\n    #timeoutHandlers = () => {\n        const now = Date.now();\n        const ids = Object.keys(this.#handlers);\n        for (let i = 0, count = ids.length; i < count; i++) {\n            const handler = this.#handlers[ids[i]];\n            if ((now - handler.start) > this.#timeout) {\n                try {\n                    handler.callback(new Error(`No response received from RPC endpoint in ${this.#timeout / 1000}s`), undefined);\n                }\n                catch {\n                    // ignore\n                }\n                this.#endpointStats.timeout++;\n                this.#stats.total.timeout++;\n                delete this.#handlers[ids[i]];\n            }\n        }\n    };\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AACA,MAAM,UAAU;IACZ,qBAAqB;IACrB,+BAA+B;IAC/B,iCAAiC;AACrC;AACA,MAAM,cAAc;AACpB,MAAM,qBAAqB,KAAK;AAChC,MAAM,mBAAmB;AACzB,MAAM,IAAI,IAAA,yJAAM,EAAC;AACjB,oFAAoF,GACpF,SAAS,YAAY,MAAM,EAAE,EAAE;IAC3B,OAAO,IAAI,CAAC,QAAQ,OAAO,CAAC,CAAC;QACzB,IAAI,IAAI;YACJ,GAAG,MAAM,CAAC,IAAI;QAClB;QACA,OAAO,MAAM,CAAC,IAAI;IACtB;AACJ;AACA,mDAAmD,GACnD,SAAS;IACL,OAAO;QAAE,WAAW;QAAG,WAAW;QAAG,QAAQ;QAAG,QAAQ;QAAG,UAAU;QAAG,eAAe;QAAG,SAAS;IAAE;AACzG;IAsBI,0CACA,sCACA,0CACA,wCACA,6CACA,yCACA,+CACA,sCACA,6CACA,8CACA,oCACA,8CACA,8CACA,8CACA,4CACA,8CACA,0CACA,0CACA,wCAuNM,qCAkFN,qCAGA,8CAqCA,8CAIA,gDAUA,sDA+BA,yDAyBA,6CAUA,4CAmBA;AAvcG,MAAM;IAkET;;KAEC,GACD,IAAI,mBAAmB;QACnB,OAAO,CAAC,CAAC;IACb;IACA;;KAEC,GACD,IAAI,aAAa;QACb,OAAO,CAAC,CAAC;IACb;IACA;;;KAGC,GACD,IAAI,cAAc;QACd,wLAAO,IAAI,EAAC;IAChB;IACA;;KAEC,GACD,IAAI,UAAU;QACV,wLAAO,IAAI,EAAC;IAChB;IACA,IAAI,WAAW;QACX,OAAO,iLAAA,IAAI,EAAC,WAAU,kLAAC,IAAI,EAAC,gBAAe;IAC/C;IACA;;KAEC,GACD,QAAQ;QACJ,OAAO,IAAI,4LAAW,IAAI,EAAC;IAC/B;IACA,oBAAoB,SAAS,EAAE;QAC3B,OAAO,CAAC,iLAAA,IAAI,EAAC,kBAAiB,CAAC,IAAI,UAAU,MAAM;IACvD;IACA;;;;KAIC,GACD,4DAA4D;IAC5D,MAAM,UAAU;QACZ,qLAAI,IAAI,EAAC,aAAY;YACjB,MAAM,IAAI,MAAM;QACpB;QACA,IAAI;mMACK,gBAAiB,IAAI,CAAC,mBAAmB,kLAAC,IAAI,EAAC;YACpD,iEAAiE;mMAC5D,YAAa,OAAO,gLAAO,CAAC,SAAS,KAAK,eAAe,IAAA,yKAAY,EAAC,gLAAO,CAAC,SAAS,EAAE,gLAAS,IACjG,IAAI,gLAAS,CAAC,IAAI,CAAC,QAAQ,IAG3B,IAAI,gLAAS,CAAC,IAAI,CAAC,QAAQ,EAAE,WAAW;gBACtC,OAAO,mLAAE,IAAI,EAAC;YAClB;YACJ,qLAAI,IAAI,EAAC,aAAY;gBACjB,iLAAA,IAAI,EAAC,YAAW,OAAO,oLAAG,IAAI,EAAC;gBAC/B,iLAAA,IAAI,EAAC,YAAW,OAAO,oLAAG,IAAI,EAAC;gBAC/B,iLAAA,IAAI,EAAC,YAAW,SAAS,oLAAG,IAAI,EAAC;gBACjC,iLAAA,IAAI,EAAC,YAAW,MAAM,oLAAG,IAAI,EAAC;YAClC;YACA,oDAAoD;mMAC/C,YAAa,YAAY,IAAM,iLAAA,IAAI,EAAC,uBAAL,IAAI,GAAqB;QACjE,EACA,OAAO,OAAO;YACV,EAAE,KAAK,CAAC;YACR,iLAAA,IAAI,EAAC,YAAL,IAAI,EAAO,SAAS;YACpB,MAAM;QACV;IACJ;IACA;;KAEC,GACD,MAAM,mBAAmB;QACrB,IAAI,iLAAA,IAAI,EAAC,kBAAiB,GAAG;YACzB,IAAI;gBACA,MAAM,IAAI,CAAC,OAAO;YACtB,EACA,UAAM;gBACF,WAAW;oBACP,IAAI,CAAC,gBAAgB,GAAG,KAAK,CAAC,qJAAI;gBACtC,oLAAG,IAAI,EAAC;YACZ;QACJ;IACJ;IACA;;KAEC,GACD,4DAA4D;IAC5D,MAAM,aAAa;QACf,oDAAoD;+LAC/C,gBAAiB;QACtB,IAAI;YACA,qLAAI,IAAI,EAAC,aAAY;gBACjB,+DAA+D;gBAC/D,iLAAA,IAAI,EAAC,YAAW,KAAK,CAAC;YAC1B;QACJ,EACA,OAAO,OAAO;YACV,EAAE,KAAK,CAAC;YACR,iLAAA,IAAI,EAAC,YAAL,IAAI,EAAO,SAAS;YACpB,MAAM;QACV;IACJ;IACA;;KAEC,GACD,IAAI,QAAQ;QACR,OAAO;YACH,QAAQ;gBACJ,UAAU,OAAO,IAAI,kLAAC,IAAI,EAAC,YAAW,MAAM;gBAC5C,eAAe,OAAO,IAAI,kLAAC,IAAI,EAAC,iBAAgB,MAAM;YAC1D;YACA,OAAO,iLAAA,IAAI,EAAC,QAAO,KAAK;QAC5B;IACJ;IACA;;IAEA,GACA,IAAI,MAAM;QACN,wLAAO,IAAI,EAAC;IAChB;IACA,IAAI,gBAAgB;QAChB,wLAAO,IAAI,EAAC;IAChB;IACA;;;;;KAKC,GACD,GAAG,IAAI,EAAE,GAAG,EAAE;QACV,iLAAA,IAAI,EAAC,eAAc,EAAE,CAAC,MAAM;QAC5B,OAAO;YACH,iLAAA,IAAI,EAAC,eAAc,cAAc,CAAC,MAAM;QAC5C;IACJ;IACA;;;;;KAKC,GACD,KAAK,MAAM,EAAE,MAAM,EAAE,WAAW,EAAE,YAAY,EAAE;QAC5C,oLAAA,IAAI,EAAC,sBAAe,QAAQ;QAC5B,oLAAA,IAAI,EAAC,cAAO,KAAK,CAAC,QAAQ;QAC1B,MAAM,CAAC,IAAI,KAAK,GAAG,iLAAA,IAAI,EAAC,QAAO,UAAU,CAAC,QAAQ;QAClD,IAAI,iLAAA,IAAI,EAAC,oBAAmB,GAAG;YAC3B,OAAO,kLAAA,IAAI,EAAC,OAAA,WAAL,IAAI,EAAO,IAAI,MAAM,QAAQ,QAAQ;QAChD;QACA,MAAM,WAAW,cAAc,AAAC,GAAa,OAAX,QAAO,MAAsB,OAAlB,IAAA,+JAAS,EAAC,WAAY;QACnE,IAAI,gBAAgB,cACd,iLAAA,IAAI,EAAC,YAAW,GAAG,CAAC,YACpB;QACN,IAAI,CAAC,eAAe;YAChB,gBAAgB,kLAAA,IAAI,EAAC,OAAA,WAAL,IAAI,EAAO,IAAI,MAAM,QAAQ,QAAQ;YACrD,IAAI,aAAa;gBACb,iLAAA,IAAI,EAAC,YAAW,GAAG,CAAC,UAAU;YAClC;QACJ,OACK;YACD,oLAAA,IAAI,EAAC,sBAAe,MAAM;YAC1B,oLAAA,IAAI,EAAC,cAAO,KAAK,CAAC,MAAM;QAC5B;QACA,OAAO;IACX;IAoCA;;;;;;;;;;;;;;;;;KAiBC,GACD,UAAU,IAAI,EAAE,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE;QACtC,oLAAA,IAAI,EAAC,sBAAe,aAAa;QACjC,oLAAA,IAAI,EAAC,cAAO,KAAK,CAAC,aAAa;QAC/B,qEAAqE;QACrE,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,QAAQ,OAAO;YAAE;YAAU;QAAK;IAC7D;IACA;;KAEC,GACD,MAAM,YAAY,IAAI,EAAE,MAAM,EAAE,EAAE,EAAE;QAChC,MAAM,eAAe,AAAC,GAAW,OAAT,MAAK,MAAO,OAAH;QACjC,qFAAqF;QACrF,mFAAmF;QACnF,qFAAqF;QACrF,oDAAoD;QACpD,IAAI,IAAA,uKAAW,EAAC,iLAAA,IAAI,EAAC,eAAc,CAAC,aAAa,GAAG;YAChD,EAAE,KAAK,CAAC,IAAM,AAAC,sCAAkD,OAAb;YACpD,OAAO;QACX;QACA,OAAO,iLAAA,IAAI,EAAC,eAAc,CAAC,aAAa;QACxC,IAAI;YACA,OAAO,IAAI,CAAC,WAAW,IAAI,CAAC,IAAA,6JAAM,mLAAC,IAAI,EAAC,eAClC,IAAI,CAAC,IAAI,CAAC,QAAQ;gBAAC;aAAG,IACtB;QACV,EACA,UAAM;YACF,OAAO;QACX;IACJ;IAvSA;;;;;;;KAOC,GACD,YAAY,WAAW,uKAAQ,CAAC,MAAM,EAAE,gBAAgB,WAAW,EAAE,UAAU,CAAC,CAAC,EAAE,OAAO,EAAE,aAAa,EAAE,QAAQ,CAAE;;QA8MrH,yLAAM;QAzON,wLAAA;;mBAAA,KAAA;;QACA,wLAAA;;mBAAA,KAAA;;QACA,wLAAA;;mBAAA,KAAA;;QACA,wLAAA;;mBAAA,KAAA;;QACA,wLAAA;;mBAAA,KAAA;;QACA,wLAAA;;mBAAY,CAAC;;QACb,wLAAA;;mBAAA,KAAA;;QACA,wLAAA;;mBAAA,KAAA;;QACA,wLAAA;;mBAAgB,CAAC;;QACjB,wLAAA;;mBAAA,KAAA;;QACA,wLAAA;;mBAAA,KAAA;;QACA,wLAAA;;mBAAA,KAAA;;QACA,wLAAA;;mBAAA,KAAA;;QACA,wLAAA;;mBAAA,KAAA;;QACA,wLAAA;;mBAAe;;QACf,wLAAA;;mBAAiB,CAAC;;QAClB,wLAAA;;mBAAa;;QACb,wLAAA;;mBAAA,KAAA;;QACA,wLAAA;;mBAAA,KAAA;;QAySA,wLAAA;;mBAAQ,SAAC;iDAAS;oBAAA;;gBACd,wLAAK,eAAc,IAAI,CAAC,SAAS;YACrC;;QACA,wLAAA;;mBAAiB,CAAC;gBACd,MAAM,QAAQ,IAAI,MAAM,AAAC,qBAAsC,OAAlB,IAAI,CAAC,QAAQ,EAAC,MAAoB,OAAhB,MAAM,IAAI,EAAC,OAAkD,OAA7C,MAAM,MAAM,IAAI,IAAA,oLAAgB,EAAC,MAAM,IAAI;gBAC1H,IAAI,iLAAA,IAAI,EAAC,kBAAiB,GAAG;oBACzB,EAAE,KAAK,CAAC,MAAM,OAAO;gBACzB;uMACK,cAAe;gBACpB,qLAAI,IAAI,EAAC,aAAY;oBACjB,iLAAA,IAAI,EAAC,YAAW,OAAO,GAAG;oBAC1B,iLAAA,IAAI,EAAC,YAAW,OAAO,GAAG;oBAC1B,iLAAA,IAAI,EAAC,YAAW,SAAS,GAAG;oBAC5B,iLAAA,IAAI,EAAC,YAAW,MAAM,GAAG;2MACpB,YAAa;gBACtB;gBACA,qLAAI,IAAI,EAAC,aAAY;oBACjB,+LAAc,IAAI,EAAC;2MACd,YAAa;gBACtB;gBACA,8BAA8B;gBAC9B,6LAAY,IAAI,EAAC,YAAW,CAAC;oBACzB,IAAI;wBACA,EAAE,QAAQ,CAAC,OAAO;oBACtB,EACA,OAAO,KAAK;wBACR,iBAAiB;wBACjB,EAAE,KAAK,CAAC;oBACZ;gBACJ;gBACA,6LAAY,IAAI,EAAC;gBACjB,kCAAkC;uMAC7B,gBAAiB;gBACtB,iLAAA,IAAI,EAAC,YAAL,IAAI,EAAO;gBACX,IAAI,iLAAA,IAAI,EAAC,kBAAiB,GAAG;oBACzB,WAAW;wBACP,IAAI,CAAC,gBAAgB,GAAG,KAAK,CAAC,qJAAI;oBACtC,oLAAG,IAAI,EAAC;gBACZ;YACJ;;QACA,wLAAA;;mBAAiB,CAAC;gBACd,EAAE,KAAK,CAAC,IAAM;wBAAC;wBAAgB;qBAAM;gBACrC,iLAAA,IAAI,EAAC,YAAL,IAAI,EAAO,SAAS;YACxB;;QACA,wLAAA;;mBAAmB,CAAC;gBAChB,EAAE,KAAK,CAAC,IAAM;wBAAC;wBAAY,QAAQ,IAAI;qBAAC;gBACxC,MAAM,YAAY,QAAQ,IAAI,CAAC,MAAM;gBACrC,iLAAA,IAAI,EAAC,gBAAe,SAAS,IAAI;gBACjC,iLAAA,IAAI,EAAC,QAAO,KAAK,CAAC,SAAS,IAAI;gBAC/B,MAAM,WAAW,KAAK,KAAK,CAAC,QAAQ,IAAI;gBACxC,OAAO,IAAA,uKAAW,EAAC,SAAS,MAAM,IAC5B,iLAAA,IAAI,EAAC,6BAAL,IAAI,EAAwB,YAC5B,iLAAA,IAAI,EAAC,gCAAL,IAAI,EAA2B;YACzC;;QACA,wLAAA;;mBAAyB,CAAC;gBACtB,MAAM,UAAU,iLAAA,IAAI,EAAC,UAAS,CAAC,SAAS,EAAE,CAAC;gBAC3C,IAAI,CAAC,SAAS;oBACV,EAAE,KAAK,CAAC,IAAM,AAAC,iCAA4C,OAAZ,SAAS,EAAE;oBAC1D;gBACJ;gBACA,IAAI;oBACA,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,YAAY,EAAE,GAAG;oBACzC,MAAM,SAAS,iLAAA,IAAI,EAAC,QAAO,cAAc,CAAC;oBAC1C,iEAAiE;oBACjE,qDAAqD;oBACrD,QAAQ,QAAQ,CAAC,MAAM;oBACvB,IAAI,cAAc;wBACd,MAAM,QAAQ,AAAC,GAAwB,OAAtB,aAAa,IAAI,EAAC,MAAW,OAAP;wBACvC,iLAAA,IAAI,EAAC,eAAc,CAAC,MAAM,GAAG,IAAA,yKAAY,EAAC,CAAC,GAAG,cAAc;4BACxD;4BACA;wBACJ;wBACA,4DAA4D;wBAC5D,IAAI,iLAAA,IAAI,EAAC,cAAa,CAAC,MAAM,EAAE;4BAC3B,iLAAA,IAAI,EAAC,gCAAL,IAAI,EAA2B,iLAAA,IAAI,EAAC,cAAa,CAAC,MAAM;wBAC5D;oBACJ;gBACJ,EACA,OAAO,OAAO;oBACV,oLAAA,IAAI,EAAC,sBAAe,MAAM;oBAC1B,oLAAA,IAAI,EAAC,cAAO,KAAK,CAAC,MAAM;oBACxB,QAAQ,QAAQ,CAAC,OAAO;gBAC5B;gBACA,OAAO,iLAAA,IAAI,EAAC,UAAS,CAAC,SAAS,EAAE,CAAC;YACtC;;QACA,wLAAA;;mBAA4B,CAAC;gBACzB,IAAI,CAAC,SAAS,MAAM,EAAE;oBAClB,MAAM,IAAI,MAAM;gBACpB;gBACA,MAAM,SAAS,OAAO,CAAC,SAAS,MAAM,CAAC,IAAI,SAAS,MAAM;gBAC1D,MAAM,QAAQ,AAAC,GAAa,OAAX,QAAO,MAAiC,OAA7B,SAAS,MAAM,CAAC,YAAY;gBACxD,MAAM,UAAU,iLAAA,IAAI,EAAC,eAAc,CAAC,MAAM;gBAC1C,IAAI,CAAC,SAAS;oBACV,6DAA6D;oBAC7D,iLAAA,IAAI,EAAC,cAAa,CAAC,MAAM,GAAG;oBAC5B,EAAE,KAAK,CAAC,IAAM,AAAC,2CAAgD,OAAN;oBACzD;gBACJ;gBACA,eAAe;gBACf,OAAO,iLAAA,IAAI,EAAC,cAAa,CAAC,MAAM;gBAChC,IAAI;oBACA,MAAM,SAAS,iLAAA,IAAI,EAAC,QAAO,cAAc,CAAC;oBAC1C,QAAQ,QAAQ,CAAC,MAAM;gBAC3B,EACA,OAAO,OAAO;oBACV,oLAAA,IAAI,EAAC,sBAAe,MAAM;oBAC1B,oLAAA,IAAI,EAAC,cAAO,KAAK,CAAC,MAAM;oBACxB,QAAQ,QAAQ,CAAC,OAAO;gBAC5B;YACJ;;QACA,wLAAA;;mBAAgB;gBACZ,IAAI,iLAAA,IAAI,EAAC,gBAAe,MAAM;oBAC1B,MAAM,IAAI,MAAM;gBACpB;gBACA,EAAE,KAAK,CAAC,IAAM;wBAAC;wBAAgB,IAAI,CAAC,QAAQ;qBAAC;uMACxC,cAAe;gBACpB,iLAAA,IAAI,EAAC,mBAAL,IAAI;gBACJ,iLAAA,IAAI,EAAC,YAAL,IAAI,EAAO;gBACX,OAAO;YACX;;QACA,wLAAA;;mBAAe;gBACX,MAAM,iMAAgB,IAAI,EAAC;uMACtB,gBAAiB,CAAC;gBACvB,QAAQ,GAAG,CAAC,OAAO,IAAI,CAAC,eAAe,GAAG,CAAC,OAAO;oBAC9C,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,aAAa,CAAC,GAAG;oBAC5D,wEAAwE;oBACxE,sFAAsF;oBACtF,kDAAkD;oBAClD,IAAI,KAAK,UAAU,CAAC,YAAY;wBAC5B;oBACJ;oBACA,IAAI;wBACA,MAAM,IAAI,CAAC,SAAS,CAAC,MAAM,QAAQ,QAAQ;oBAC/C,EACA,OAAO,OAAO;wBACV,EAAE,KAAK,CAAC;oBACZ;gBACJ,IAAI,KAAK,CAAC,EAAE,KAAK;YACrB;;QACA,wLAAA;;mBAAmB;gBACf,MAAM,MAAM,KAAK,GAAG;gBACpB,MAAM,MAAM,OAAO,IAAI,kLAAC,IAAI,EAAC;gBAC7B,IAAK,IAAI,IAAI,GAAG,QAAQ,IAAI,MAAM,EAAE,IAAI,OAAO,IAAK;oBAChD,MAAM,UAAU,iLAAA,IAAI,EAAC,UAAS,CAAC,GAAG,CAAC,EAAE,CAAC;oBACtC,IAAI,AAAC,MAAM,QAAQ,KAAK,oLAAI,IAAI,EAAC,WAAU;wBACvC,IAAI;4BACA,QAAQ,QAAQ,CAAC,IAAI,MAAM,AAAC,6CAAiE,OAArB,iLAAA,IAAI,EAAC,YAAW,MAAK,OAAK;wBACtG,EACA,UAAM;wBACF,SAAS;wBACb;wBACA,oLAAA,IAAI,EAAC,sBAAe,OAAO;wBAC3B,oLAAA,IAAI,EAAC,cAAO,KAAK,CAAC,OAAO;wBACzB,OAAO,iLAAA,IAAI,EAAC,UAAS,CAAC,GAAG,CAAC,EAAE,CAAC;oBACjC;gBACJ;YACJ;;QA3bI,MAAM,YAAY,MAAM,OAAO,CAAC,YAC1B,WACA;YAAC;SAAS;QAChB,IAAI,UAAU,MAAM,KAAK,GAAG;YACxB,MAAM,IAAI,MAAM;QACpB;QACA,UAAU,OAAO,CAAC,CAAC;YACf,IAAI,CAAC,iBAAiB,IAAI,CAAC,WAAW;gBAClC,MAAM,IAAI,MAAM,AAAC,iDAAyD,OAAT,UAAS;YAC9E;QACJ;QACA,MAAM,MAAM,aAAa,YAAY,sKAAW,GAAG;+LAC9C,YAAa,IAAI,mKAAQ,CAAC,kBAAkB,IAAI,IAAI,iBAAiB,2KAAgB,EAAE;+LACvF,MAAO;+LACP,gBAAiB,iBAAiB,2KAAgB;+LAClD,eAAgB,IAAI,oMAAY;+LAChC,gBAAiB,iBAAiB;+LAClC,QAAS,IAAI,8KAAQ;+LACrB,gBAAiB,CAAC;+LAClB,YAAa;+LACb,UAAW;+LACX,YAAa;+LACb,QAAS;YACV,QAAQ;gBAAE,UAAU;gBAAG,eAAe;YAAE;YACxC,OAAO;QACX;+LACK,gBAAiB;+LACjB,UAAW,WAAW;QAC3B,IAAI,iBAAiB,gBAAgB,GAAG;YACpC,IAAI,CAAC,gBAAgB,GAAG,KAAK,CAAC,qJAAI;QACtC;+LACK,iBAAkB,IAAI,QAAQ,CAAC;YAChC,iLAAA,IAAI,EAAC,eAAc,IAAI,CAAC,aAAa;gBACjC,QAAQ,IAAI;YAChB;QACJ;IACJ;AAwZJ;AA/OI,eAAA,KAAY,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM,EAAE,YAAY;IAC9C,OAAO,IAAI,QAAQ,CAAC,SAAS;QACzB,IAAI;YACA,IAAI,CAAC,IAAI,CAAC,WAAW,IAAI,iLAAA,IAAI,EAAC,gBAAe,MAAM;gBAC/C,MAAM,IAAI,MAAM;YACpB;YACA,MAAM,WAAW,CAAC,OAAO;gBACrB,QACM,OAAO,SACP,QAAQ;YAClB;YACA,EAAE,KAAK,CAAC,IAAM;oBAAC;oBAAW;oBAAQ;iBAAK;YACvC,iLAAA,IAAI,EAAC,UAAS,CAAC,GAAG,GAAG;gBACjB;gBACA;gBACA;gBACA,OAAO,KAAK,GAAG;gBACf;YACJ;YACA,MAAM,YAAY,KAAK,MAAM;YAC7B,iLAAA,IAAI,EAAC,gBAAe,SAAS,IAAI;YACjC,iLAAA,IAAI,EAAC,QAAO,KAAK,CAAC,SAAS,IAAI;YAC/B,iLAAA,IAAI,EAAC,YAAW,IAAI,CAAC;QACzB,EACA,OAAO,OAAO;YACV,oLAAA,IAAI,EAAC,sBAAe,MAAM;YAC1B,oLAAA,IAAI,EAAC,cAAO,KAAK,CAAC,MAAM;YACxB,MAAM,WAAW;YACjB,MAAM,gBAAgB,AAAC,wBAA0D,OAAnC,KAAK,SAAS,CAAC;gBAAE;gBAAQ;YAAO;YAC9E,yCAAyC;YACzC,SAAS,OAAO,GAAG,AAAC,GAAqB,OAAnB,SAAS,OAAO,EAAiB,OAAd;YACzC,OAAO;QACX;IACJ;AACJ","ignoreList":[0],"debugId":null}}]
}